//
// this file is automatically generated
//
package org.marketcetera.eventbus.data.event;

import java.util.Collection;
import java.util.Comparator;
import java.util.Date;
import java.util.Objects;
import java.util.Set;
import java.util.SortedSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import javax.annotation.PostConstruct;

import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.builder.CompareToBuilder;
import org.marketcetera.core.PlatformServices;
import org.marketcetera.core.Preserve;
import org.marketcetera.eventbus.EventBusService;
import org.marketcetera.util.log.SLF4JLoggerProxy;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.stereotype.Component;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.eventbus.Subscribe;

/* $License$ */

/**
 * Provides services for {@link DataEvent} actions.
 * 
 * <p>This service is intended to provide information about {@link DataEvent} objects. These objects
 * provide updates when particular types of data change. The primary intent is for UI display: notifications
 * about data being displayed will trigger update requests. There's no specific limitation for this to be
 * user for UI.</p>
 * 
 * <p>When subscribing for updates, there's the chance of a race condition where an update comes in just
 * after the request is generated but before the bookkeeping is done for the request, which would allow
 * an update to never be sent to the requester, even though it happened after the request was submitted.
 * To address this race condition, a cache of {@link DataEvent} objects is stored with a TTL defined 
 * {@link #dataEventCacheTtlSeconds here}. Any event that occurred after the request was made but before
 * the bookkeeping is finalized will be sent to the requester, before the {@link #subscribeToDataEvents(String, Date, Consumer, Class...) request}
 * returns.</p>
 *
 * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
 * @version $Id$
 * @since $Release$
 */
@Preserve
@Component
@EnableAutoConfiguration
public class DataEventServiceImpl
        implements DataEventService
{
    /* (non-Javadoc)
     * @see org.marketcetera.eventbus.data.event.DataEventService#subscribeToDataEvents(java.lang.String, java.util.Date, java.util.function.Consumer, java.lang.Class<?>...)
     */
    @Override
    public void subscribeToDataEvents(String inRequestId,
                                      Date inTimestamp,
                                      Consumer<DataEvent> inConsumer,
                                      Class<?>...inTypes)
    {
        // the caller supplies the request id in order to prevent a race condition: events may be returned before the call returns
        // however, this requires that the caller be aware enough to create a universally unique id among all callers
        // verify this contract
        if(subscribersByRequestId.asMap().containsKey(inRequestId)) {
            throw new IllegalArgumentException("Duplicate request id: '" + inRequestId + "'");
        }
        // the given types, if any, indicate which DataEvent types the caller is interested in
        // the types have to match exactly without expansion in order to distinguish between different subclasses of DataEvent
        Set<Class<?>> allTypes = Sets.newHashSet();
        if(inTypes == null || inTypes.length == 0) {
            // if no types are specified, that means send events for all DataEvent subclasses
            allTypes.add(DataEvent.class);
        } else {
            for(Class<?> type : inTypes) {
                // TODO verify that the type is assignable from DataEvent
                allTypes.add(type);
            }
        }
        // as soon as the new subscriber gets added to the subscriber collection, it's eligible to receive new events. probably want
        //  to send the old events *before* adding the new subscriber to the collection
        SortedSet<DataEvent> previousEvents = Sets.newTreeSet(DataEventTimestampComparator.instance);
        dataEventTimeCache.asMap().values().forEach(event-> {
            if(allTypes.contains(event.getClass()) && event.getTimestamp().compareTo(inTimestamp) != -1) {
                previousEvents.add(event);
            }
        });
        previousEvents.forEach(event -> inConsumer.accept(event));
        // create the new subscriber
        DataEventSubscriber subscriber = new DataEventSubscriber(inRequestId,
                                                                 inConsumer);
        // store the subscriber both by its requestId and by each of its requested types
        subscribersByRequestId.put(inRequestId,
                                   subscriber);
        allTypes.forEach(type -> {
            subscribersByClass.getUnchecked(type).add(subscriber);
        });
    }
    /**
     * Get the dataEventTtlSeconds value.
     *
     * @return an <code>int</code> value
     */
    public int getDataEventCacheTtlSeconds()
    {
        return dataEventCacheTtlSeconds;
    }
    /**
     * Get the classLookupCacheTtlSeconds value.
     *
     * @return an <code>int</code> value
     */
    public int getClassLookupCacheTtlSeconds()
    {
        return classLookupCacheTtlSeconds;
    }
    /**
     * Cancels data event request.
     *
     * @param inRequestId a <code>String</code> value
     */
    @Override
    public void unsubscribeToDataEvents(String inRequestId)
    {
        throw new UnsupportedOperationException(); // TODO
    }
    /**
     * Accept incoming DataEvent values.
     *
     * @param inEvent a <code>DataEvent</code> value
     */
    @Subscribe
    public void accept(DataEvent inEvent)
    {
        SLF4JLoggerProxy.trace(this,
                               "Received {}",
                               inEvent);
        dataEventTimeCache.put(inEvent.getId(),
                               inEvent);
        doAcceptEvent(inEvent);
    }
    /**
     * Validate and start the object.
     */
    @PostConstruct
    public void start()
    {
        SLF4JLoggerProxy.info(this,
                              "Starting {}",
                              PlatformServices.getServiceName(getClass()));
        eventBusService.register(this);
        dataEventTimeCache = CacheBuilder.newBuilder().expireAfterWrite(dataEventCacheTtlSeconds, TimeUnit.SECONDS).build();
        expandedClassesByClass = CacheBuilder.newBuilder().expireAfterAccess(classLookupCacheTtlSeconds,TimeUnit.SECONDS)
                .build(new CacheLoader<Class<?>,Collection<Class<?>>>() {
            @Override
            public Collection<Class<?>> load(Class<?> inKey)
                    throws Exception
            {
                return determineExpandedTypes(inKey);
            }}
        );
    }
    /**
     * Get the cached expanded types for the given types.
     *
     * @param inTypes a <code>Class&lt;?&gt;[]</code> value
     * @return a <code>Collection&lt;Class&lt;?&gt;&gt;</code> value
     */
    private Collection<Class<?>> getCachedExpandedTypes(Class<?>...inTypes)
    {
        Collection<Class<?>> expandedTypes = Lists.newArrayList();
        for(Class<?> type : inTypes) {
            expandedTypes.addAll(expandedClassesByClass.getUnchecked(type));
        }
        return expandedTypes;
    }
    /**
     * Determine the expanded types for the given single type, explicitly not using the cache.
     *
     * @param inType a <code>Class&lt;?&gt;</code> value
     * @return a <code>Collection&lt;Class&lt;?&gt;&gt;</code> value
     */
    private Collection<Class<?>> determineExpandedTypes(Class<?> inType)
    {
        Collection<Class<?>> expandedTypes = Lists.newArrayList();
        expandedTypes.add(inType);
        expandedTypes.addAll(ClassUtils.getAllInterfaces(inType));
        expandedTypes.addAll(ClassUtils.getAllSuperclasses(inType));
        return expandedTypes;
    }
    /**
     * Accept the given event and notify all interested subscribers.
     *
     * @param inEvent a <code>DataEvent</code> value
     */
    private void doAcceptEvent(DataEvent inEvent)
    {
        Class<?> eventType = inEvent.getClass();
        // this gets all the class types that this event might match
        Collection<Class<?>> expandedTypes = getCachedExpandedTypes(eventType);
        // subscribers will hold all the subscribers to whom this event will be sent - made a set in order to avoid duplicate notifications
        Set<DataEventSubscriber> subscribers = Sets.newHashSet();
        // go through all the class types that apply to the event and grab all the subscribers that are interested in each type in the expanded list
        for(Class<?> type : expandedTypes) {
            subscribers.addAll(subscribersByClass.getUnchecked(type));
        }
        // now, subscribers holds the unique set of subscribers interested in the event we just received
        subscribers.forEach(subscriber -> {
            try {
                subscriber.accept(inEvent);
            } catch (Exception e) {
                SLF4JLoggerProxy.warn(DataEventServiceImpl.this,
                                      e);
            }
        });
    }
    /**
     * Manages a data event subscription request.
     *
     * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
     * @version $Id$
     * @since $Release$
     */
    private static class DataEventSubscriber
            implements Consumer<DataEvent>
    {
        /* (non-Javadoc)
         * @see java.util.function.Consumer#accept(java.lang.Object)
         */
        @Override
        public void accept(DataEvent inEvent)
        {
            consumer.accept(inEvent);
        }
        /* (non-Javadoc)
         * @see java.lang.Object#hashCode()
         */
        @Override
        public int hashCode()
        {
            return Objects.hash(requestId);
        }
        /* (non-Javadoc)
         * @see java.lang.Object#equals(java.lang.Object)
         */
        @Override
        public boolean equals(Object obj)
        {
            if (this == obj) {
                return true;
            }
            if (!(obj instanceof DataEventSubscriber)) {
                return false;
            }
            DataEventSubscriber other = (DataEventSubscriber) obj;
            return Objects.equals(requestId,
                                  other.requestId);
        }
        /**
         * Create a new DataEventSubscriber instance.
         *
         * @param inRequestId a <code>String</code> value
         * @param inConsumer a <code>Consumer&lt;DataEvent&gt;</code> value
         */
        private DataEventSubscriber(String inRequestId,
                                    Consumer<DataEvent> inConsumer)
        {
            requestId = inRequestId;
            consumer = inConsumer;
        }
        /**
         * universally unique identifier for this request
         */
        private final String requestId;
        /**
         * event consumer provided by the caller
         */
        private final Consumer<DataEvent> consumer;
    }
    /**
     * Compares to {@link DataEvent} objects and compares them by timestamp, maintaining event uniqueness.
     *
     * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
     * @version $Id$
     * @since $Release$
     */
    private static class DataEventTimestampComparator
            implements Comparator<DataEvent>
    {
        /* (non-Javadoc)
         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
         */
        @Override
        public int compare(DataEvent inO1,
                           DataEvent inO2)
        {
            return new CompareToBuilder().append(inO1.getTimestamp(),inO2.getTimestamp()).append(inO1.getId(),inO2.getId()).toComparison();
        }
        /**
         * static instance for easy use
         */
        private static final DataEventTimestampComparator instance = new DataEventTimestampComparator();
    }
    /**
     * caches {@link DataEvent} values received from the system event bus allowing them to expire over time in order to make
     * sure no events are missed on new subscriptions
     */
    private Cache<Long,DataEvent> dataEventTimeCache;
    /**
     * holds subscribers for a particular class type - note that the value is thread-safe
     */
    private final LoadingCache<Class<?>,Set<DataEventSubscriber>> subscribersByClass = CacheBuilder.newBuilder().build(new CacheLoader<Class<?>,Set<DataEventSubscriber>>(){
        @Override
        public Set<DataEventSubscriber> load(Class<?> inKey)
                throws Exception
        {
            return ConcurrentHashMap.newKeySet();
        }}
    );
    /**
     * lists data event subscribers by request id
     */
    private final Cache<String,DataEventSubscriber> subscribersByRequestId = CacheBuilder.newBuilder().build();
    /**
     * caches expanded type lookups by class
     */
    private LoadingCache<Class<?>,Collection<Class<?>>> expandedClassesByClass;
    /**
     * provides access to event services
     */
    @Autowired
    private EventBusService eventBusService;
    /**
     * number of seconds for data events to survive in the cache
     */
    @Value("${metc.data.event.cache.ttl.seconds:10}")
    private int dataEventCacheTtlSeconds;
    /**
     * number of seconds for expanded class lookups to survive in the cache
     */
    @Value("${metc.data.event.class.lookup.cache.ttl.seconds:600}")
    private int classLookupCacheTtlSeconds;
}
