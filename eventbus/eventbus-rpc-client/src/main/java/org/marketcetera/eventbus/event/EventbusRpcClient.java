//
// this file is automatically generated
//
package org.marketcetera.eventbus.event;

import java.util.concurrent.Callable;

import org.marketcetera.core.Preserve;
import org.marketcetera.rpc.base.BaseRpcUtil;
import org.marketcetera.rpc.base.BaseRpcUtil.AbstractClientListenerProxy;
import org.marketcetera.util.log.SLF4JLoggerProxy;
import org.springframework.beans.factory.annotation.Autowired;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;

/* $License$ */

/**
 * Provides an RPC Client for EventbusRpc services.
 *
 * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
 * @version $Id$
 * @since $Release$
 */
@Preserve
@org.springframework.stereotype.Component
@org.springframework.context.annotation.Scope(org.springframework.beans.factory.config.ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class EventbusRpcClient
        extends org.marketcetera.rpc.client.AbstractRpcClient<org.marketcetera.eventbus.event.EventbusRpcServiceGrpc.EventbusRpcServiceBlockingStub,org.marketcetera.eventbus.event.EventbusRpcServiceGrpc.EventbusRpcServiceStub,EventbusRpcClientParameters>
        implements EventbusClient
{
    /* (non-Javadoc)
     * @see org.marketcetera.eventbus.event.EventbusClient#getEvents()
     */
    @Override
    public void getEvents(EventbusEventListener inListener)
    {
        // check to see if this listener is already registered
        if(listenerProxies.asMap().containsKey(inListener)) {
            return;
        }
        // make sure that this listener wasn't just whisked out from under us
        final AbstractClientListenerProxy<?,?,?> listener = listenerProxies.getUnchecked(inListener);
        if(listener == null) {
            return;
        }
        executeCall(new Callable<Void>() {
            @Override
            public Void call()
                    throws Exception
            {
                SLF4JLoggerProxy.trace(EventbusRpcClient.this,
                                       "{} adding event listener",
                                       getSessionId());
                EventbusRpc.AddEventListenerRequest.Builder requestBuilder = EventbusRpc.AddEventListenerRequest.newBuilder();
                requestBuilder.setSessionId(getSessionId().getValue());
                requestBuilder.setListenerId(listener.getId());
                EventbusRpc.AddEventListenerRequest addEventbusListenerRequest = requestBuilder.build();
                SLF4JLoggerProxy.trace(EventbusRpcClient.this,
                                       "{} sending {}",
                                       getSessionId(),
                                       addEventbusListenerRequest);
                getAsyncStub().addEventListener(addEventbusListenerRequest,
                                                (EventbusEventListenerProxy)listener);
                return null;
            }
        });
    }
    /* (non-Javadoc)
     * @see org.marketcetera.eventbus.event.EventbusClient#cancelEventRequest(org.marketcetera.eventbus.event.EventbusEventListener)
     */
    @Override
    public void cancelEventRequest(EventbusEventListener inListener)
    {
        final AbstractClientListenerProxy<?,?,?> proxy = listenerProxies.getIfPresent(inListener);
        listenerProxies.invalidate(inListener);
        if(proxy == null) {
            return;
        }
        listenerProxiesById.invalidate(proxy.getId());
        executeCall(new Callable<Void>() {
            @Override
            public Void call()
                    throws Exception
            {
                SLF4JLoggerProxy.trace(EventbusRpcClient.this,
                                       "{} removing market data status listener",
                                       getSessionId());
                EventbusRpc.RemoveEventListenerRequest.Builder requestBuilder = EventbusRpc.RemoveEventListenerRequest.newBuilder();
                requestBuilder.setSessionId(getSessionId().getValue());
                requestBuilder.setListenerId(proxy.getId());
                EventbusRpc.RemoveEventListenerRequest removeMarketDataStatusListenerRequest = requestBuilder.build();
                SLF4JLoggerProxy.trace(EventbusRpcClient.this,
                                       "{} sending {}",
                                       getSessionId(),
                                       removeMarketDataStatusListenerRequest);
                EventbusRpc.RemoveEventListenerResponse response = getBlockingStub().removeEventListener(removeMarketDataStatusListenerRequest);
                SLF4JLoggerProxy.trace(EventbusRpcClient.this,
                                       "{} received {}",
                                       getSessionId(),
                                       response);
                return null;
            }
        });
    }
    /* (non-Javadoc)
     * @see org.marketcetera.rpc.client.AbstractRpcClient#getBlockingStub(io.grpc.Channel)
     */
    @Override
    protected org.marketcetera.eventbus.event.EventbusRpcServiceGrpc.EventbusRpcServiceBlockingStub getBlockingStub(io.grpc.Channel inChannel)
    {
        return org.marketcetera.eventbus.event.EventbusRpcServiceGrpc.newBlockingStub(inChannel);
    }
    /* (non-Javadoc)
     * @see org.marketcetera.rpc.client.AbstractRpcClient#getAsyncStub(io.grpc.Channel)
     */
    @Override
    protected org.marketcetera.eventbus.event.EventbusRpcServiceGrpc.EventbusRpcServiceStub getAsyncStub(io.grpc.Channel inChannel)
    {
        return org.marketcetera.eventbus.event.EventbusRpcServiceGrpc.newStub(inChannel);
    }
    /* (non-Javadoc)
     * @see org.marketcetera.rpc.client.AbstractRpcClient#executeLogin(org.marketcetera.rpc.base.BaseRpc.LoginRequest)
     */
    @Override
    protected org.marketcetera.rpc.base.BaseRpc.LoginResponse executeLogin(org.marketcetera.rpc.base.BaseRpc.LoginRequest inRequest)
    {
        return getBlockingStub().login(inRequest);
    }
    /* (non-Javadoc)
     * @see org.marketcetera.rpc.client.AbstractRpcClient#executeLogout(org.marketcetera.rpc.base.BaseRpc.LogoutRequest)
     */
    @Override
    protected org.marketcetera.rpc.base.BaseRpc.LogoutResponse executeLogout(org.marketcetera.rpc.base.BaseRpc.LogoutRequest inRequest)
    {
        return getBlockingStub().logout(inRequest);
    }
    /* (non-Javadoc)
     * @see org.marketcetera.rpc.client.AbstractRpcClient#executeHeartbeat(org.marketcetera.rpc.base.BaseRpc.HeartbeatRequest)
     */
    @Override
    protected org.marketcetera.rpc.base.BaseRpc.HeartbeatResponse executeHeartbeat(org.marketcetera.rpc.base.BaseRpc.HeartbeatRequest inRequest)
    {
        return getBlockingStub().heartbeat(inRequest);
    }
    /* (non-Javadoc)
     * @see org.marketcetera.rpc.client.AbstractRpcClient#getAppId()
     */
    @Override
    protected org.marketcetera.util.ws.tags.AppId getAppId()
    {
        return APP_ID;
    }
    /* (non-Javadoc)
     * @see org.marketcetera.rpc.client.AbstractRpcClient#getVersionInfo()
     */
    @Override
    protected org.marketcetera.core.VersionInfo getVersionInfo()
    {
        return APP_ID_VERSION;
    }
    /**
     * Create an new EventbusRpc instance.
     *
     * @param inParameters an <code>EventbusRpcClientParameters</code> value
     */
    protected EventbusRpcClient(EventbusRpcClientParameters inParameters)
    {
        super(inParameters);
    }
    /**
     * Creates the appropriate proxy for the given listener.
     *
     * @param inListener an <code>Object</code> value
     * @return an <code>AbstractListenerProxy&lt;?,?,?&gt;</code> value
     */
    private AbstractClientListenerProxy<?,?,?> getListenerFor(Object inListener)
    {
        if(inListener instanceof EventbusEventListener) {
            return new EventbusEventListenerProxy((EventbusEventListener)inListener);
        } else {
            throw new UnsupportedOperationException();
        }
    }
    /**
     * Provides an interface between market data status stream listeners and their handlers.
     *
     * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
     * @version $Id$
     * @since $Release$
     */
    private class EventbusEventListenerProxy
            extends BaseRpcUtil.AbstractClientListenerProxy<EventbusRpc.EventResponse,Event,EventbusEventListener>
    {
        /* (non-Javadoc)
         * @see org.marketcetera.rpc.base.BaseUtil.AbstractClientListenerProxy#translateMessage(java.lang.Object)
         */
        @Override
        protected Event translateMessage(EventbusRpc.EventResponse inResponse)
        {
            return EventbusRpcUtil.getEvent(inResponse.getEvent(),
                                            eventFactory).orElse(null);
        }
        /* (non-Javadoc)
         * @see org.marketcetera.rpc.base.BaseUtil.AbstractClientListenerProxy#sendMessage(java.lang.Object, java.lang.Object)
         */
        @Override
        protected void sendMessage(EventbusEventListener inMessageListener,
                                   Event inMessage)
        {
            inMessageListener.receiveEventbusEvent(inMessage);
        }
        /**
         * Create a new EventbusStatusListenerProxy instance.
         *
         * @param inMessageListener a <code>EventbusEventListener</code> value
         */
        private EventbusEventListenerProxy(EventbusEventListener inMessageListener)
        {
            super(inMessageListener);
        }
    }
    /**
     * holds report listeners by their id or the market data request id
     */
    private final Cache<String,BaseRpcUtil.AbstractClientListenerProxy<?,?,?>> listenerProxiesById = CacheBuilder.newBuilder().build();
    /**
     * holds listener proxies keyed by the listener
     */
    private final LoadingCache<Object,BaseRpcUtil.AbstractClientListenerProxy<?,?,?>> listenerProxies = CacheBuilder.newBuilder().build(new CacheLoader<Object,AbstractClientListenerProxy<?,?,?>>() {
        @Override
        public BaseRpcUtil.AbstractClientListenerProxy<?,?,?> load(Object inKey)
                throws Exception
        {
            BaseRpcUtil.AbstractClientListenerProxy<?,?,?> proxy = getListenerFor(inKey);
            listenerProxiesById.put(proxy.getId(),
                                    proxy);
            return proxy;
        }}
    );
    /**
     * creates new {@link Event} objects
     */
    @Autowired
    private EventFactory eventFactory;
   /**
     * The client's application ID: the application name.
     */
    public static final String APP_ID_NAME = "EventbusRpc"; //$NON-NLS-1$
    /**
     * The client's application ID: the version.
     */
    public static final org.marketcetera.core.VersionInfo APP_ID_VERSION = org.marketcetera.core.ApplicationVersion.getVersion(org.marketcetera.eventbus.event.EventbusClient.class);
    /**
     * The client's application ID: the ID.
     */
    public static final org.marketcetera.util.ws.tags.AppId APP_ID = org.marketcetera.core.Util.getAppId(APP_ID_NAME,APP_ID_VERSION.getVersionInfo());
}
