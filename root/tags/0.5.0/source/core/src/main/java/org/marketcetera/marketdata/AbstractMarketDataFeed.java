package org.marketcetera.marketdata;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.marketcetera.core.ClassVersion;
import org.marketcetera.core.IFeedComponentListener;
import org.marketcetera.core.InMemoryIDFactory;
import org.marketcetera.core.InternalID;
import org.marketcetera.core.LoggerAdapter;
import org.marketcetera.core.MSymbol;
import org.marketcetera.core.MessageKey;
import org.marketcetera.core.NoMoreIDsException;
import org.marketcetera.core.publisher.ISubscriber;
import org.marketcetera.core.publisher.PublisherEngine;
import org.marketcetera.event.EventBase;
import org.marketcetera.event.IEventTranslator;
import org.marketcetera.marketdata.IMarketDataFeedToken.Status;
import org.marketcetera.quickfix.FIXMessageUtil;
import org.marketcetera.quickfix.FIXVersion;
import org.marketcetera.quickfix.IMessageTranslator;

import quickfix.Message;
import quickfix.field.MarketDepth;
import quickfix.field.SubscriptionRequestType;

/* $License$ */

/**
 * An abstract base class for all market data feeds. 
 * 
 * <p>Contains logic common to all market data feed implementations with 
 * the mechanics of adding/removing symbol/feed component listeners and keeping track of the feed 
 * status.
 * 
 * <p>Subclasses represent a connection to a specific market data feed.
 * 
 * <p>The generic types required are defined as follows:
 * <ul>
 *   <li>T - The token class for this feed</li>
 *   <li>C - The credentials class for this feed</li>
 *   <li>X - The message translator class for this feed</li>
 *   <li>E - The event translator class for this feed</li>
 *   <li>D - The type returned from {@link IMessageTranslator#translate(Message)}.</li>
 *   <li>F - The market data feed type itself</li>
 * </ul>
 *
 * @author andrei@lissovski.org
 * @author gmiller
 * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
 * @since 0.5.0
 */
@ClassVersion("$Id$")
public abstract class AbstractMarketDataFeed<T extends AbstractMarketDataFeedToken<F,C>, 
                                             C extends IMarketDataFeedCredentials, 
                                             X extends IMessageTranslator<D>, 
                                             E extends IEventTranslator,
                                             D,
                                             F extends AbstractMarketDataFeed<?,?,?,?,?,?>> 
    implements IMarketDataFeed<T,C> 
{
    /**
     * default FIX message factory to use to construct messages
     */
    public static final FIXVersion DEFAULT_MESSAGE_FACTORY = FIXVersion.FIX44;
    /**
     * the id factory used to generate unique IDs within the context of all feeds for this JVM session
     */
    private static final InMemoryIDFactory sIDFactory = new InMemoryIDFactory(0,
                                                                              Long.toString(System.currentTimeMillis()));
    /**
     * the singleton instance that aggregates the actual connections to the server 
     */
    private static ExecutorService sPool = Executors.newFixedThreadPool(10);
    /**
     * the status of the feed
     */
    private FeedStatus mFeedStatus = FeedStatus.UNKNOWN;
    /**
     * the type of the feed
     */
    private final FeedType mFeedType;
    /**
     * the feed ID
     */
    private final InternalID mID;
    /**
     * helper object to track the tokens and associated handles from requests and responses
     */
    private final HandleHolder mHandleHolder = new HandleHolder();
    /**
     * provider name associated with the data feed
     */
    private final String mProviderName;
    /**
     * publish/subscribe engine to manage feed status changes
     */
    private final PublisherEngine mFeedStatusPublisher = new PublisherEngine();
    /**
     * publish/subscribe engine for market data messages
     */
    private final PublisherEngine mAllPublisher = new PublisherEngine();
    /**
     * the last set of credentials passed to the feed
     */
    private C mLatestCredentials;
    /**
     * common logging category for messages generated by the data feed themselves
     */
    public final static String DATAFEED_MESSAGES = "marketdatafeed.messages";
    /**
     * Creates a Level I FIX message requesting market data on the given symbols.
     *
     * @param inSymbols a <code>List&lt;MSymbol&gt;</code> value containing the symbols on which to make requests
     * @param inSubscribeToResults a <code>boolean</code> value indicating whether the request should be a single snapshot or an
     *  ongoing subscription
     * @return a <code>Message</code> value
     * @throws FeedException if an error occurs constructing the <code>Message</code>
     */
    public static Message levelOneMarketDataRequest(List<MSymbol> inSymbols,
                                                    boolean inSubscribeToResults) 
        throws FeedException 
    {
        return marketDataRequest(inSymbols,
                                 inSubscribeToResults,
                                 FIXMessageUtil.TOP_OF_BOOK_DEPTH);
    }
    /**
     * Creates a Level II FIX message requesting market data on the given symbols.
     *
     * @param inSymbols a <code>List&lt;MSymbol&gt;</code> value containing the symbols on which to make requests
     * @param inSubscribeToResults a <code>boolean</code> value indicating whether the request should be a single snapshot or an
     *  ongoing subscription
     * @return a <code>Message</code> value
     * @throws FeedException if an error occurs constructing the <code>Message</code>
     */
    public static Message levelTwoMarketDataRequest(List<MSymbol> inSymbols,
                                                    boolean inSubscribeToResults) 
        throws FeedException 
    {
        return marketDataRequest(inSymbols,
                                 inSubscribeToResults,
                                 FIXMessageUtil.FULL_BOOK_DEPTH);
    }
    /**
     * Creates a FIX message for the given symbols at the given depth with subscription set accordingly.
     *
     * @param inSymbols a <code>List&lt;MSymbol&gt;</code> value containing the symbols on which to make requests
     * @param inSubscribeToResults a <code>boolean</code> value indicating whether the request should be a single snapshot or an
     *  ongoing subscription
     * @return a <code>Message</code> value
     * @throws FeedException if an error occurs constructing the <code>Message</code>
     */
    private static Message marketDataRequest(List<MSymbol> inSymbols,
                                             boolean inSubscribeToResults,
                                             int inMarketDepth)
        throws FeedException
    {
        try {
            // generate a unique ID for this FIX message
            InternalID id = getNextID();
            // generate the message using the current FIXMessageFactory
            Message message = DEFAULT_MESSAGE_FACTORY.getMessageFactory().newMarketDataRequest(id.toString(), 
                                                                                               inSymbols);
            message.setInt(MarketDepth.FIELD, 
                           inMarketDepth);
            // this little bit determines whether we subscribe to updates or not
            message.setChar(SubscriptionRequestType.FIELD, 
                            inSubscribeToResults ? '1' : '0');
            return message;
        } catch (NoMoreIDsException e) {
            throw new FeedException(MessageKey.ERROR_MARKET_DATA_FEED_CANNOT_GENERATE_MESSAGE.getLocalizedMessage(),
                                    e);
        }
    }
    /**
     * Gets the next ID in sequence for assigning unique identifiers to market data feed objects.
     *
     * @return an <code>InternalID</code> value
     * @throws NoMoreIDsException if no more IDs are available
     */
    private static InternalID getNextID() 
        throws NoMoreIDsException
    {
        return new InternalID(sIDFactory.getNext());
    }
    /**
     * Create a new <code>AbstractMarketDataFeed</code> instance.
     *
     * @param inFeedType a <code>FeedType</code> value
     * @param inCredentials a <code>C</code> value or null
     * @throws NoMoreIDsException if no more ids are available to be assigned to this feed
     * @throws NullPointerException if the <code>FeedType</code> is null
     */
    protected AbstractMarketDataFeed(FeedType inFeedType,
                                     String inProviderName, 
                                     C inCredentials) 
        throws NoMoreIDsException
    {
        if(inFeedType == null) {
            throw new NullPointerException();
        }
        if(inProviderName == null) {
            throw new NullPointerException();
        }
        mFeedType = inFeedType;
        mID = getNextID();
        mProviderName = inProviderName;
        mFeedStatus = FeedStatus.OFFLINE;
        mLatestCredentials = inCredentials;
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IMarketDataFeed#execute(org.marketcetera.marketdata.AbstractMarketDataFeedCredentials, quickfix.Message, org.marketcetera.core.publisher.ISubscriber)
     */
    public final T execute(MarketDataFeedTokenSpec<C> inTokenSpec)
            throws FeedException
    {
        // check the status of the feed - if it's not running, the feed isn't
        //  ready to be used
        if(!getFeedStatus().isRunning()) {
            throw new FeedException(String.format("The feed is at status \"%s\" and cannot execute requests.",
                                                  getFeedStatus()));
        }
        C credentials = inTokenSpec.getCredentials();
        // the credentials supplied are the best available to us - either given
        //  as part of this query or those originally supplied - either way,
        //  they must at this time be non-null
        if(credentials == null) {
            // this should not be possible, but add it for completeness
            throw new NullPointerException();
        }
        // record these as the latest credentials
        setLatestCredentials(credentials);
        // these subscribers are all the ones that are interested in the results
        //  of the query we're about to execute - this list may be empty or null
        List<? extends ISubscriber> subscribers = inTokenSpec.getSubscribers();
        // the token is used to track the request and its responses
        // generate a new token for this request
        T token;
        try {
            token = generateToken(inTokenSpec);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new FeedException(MessageKey.ERROR_MARKET_DATA_FEED_EXECUTION_FAILED.getLocalizedMessage(),
                                    e);
        } catch (Throwable t) {
            throw new FeedException(MessageKey.ERROR_MARKET_DATA_FEED_EXECUTION_FAILED.getLocalizedMessage(),
                                    t);
        }
        // it's possible that some messages won't need subscribers, perhaps if the caller doesn't care
        //  about responses.  if the subscriber is null, ignore it.  otherwise, set the token to receive
        //  the responses        
        if(subscribers != null) {
            token.subscribeAll(subscribers);
        }
        try {
            return submitToken(token,
                               credentials);
        } catch (TimeoutException e) {
            throw new FeedException(MessageKey.ERROR_MARKET_DATA_FEED_EXECUTION_FAILED.getLocalizedMessage(),
                                    e);
        }
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IMarketDataFeed#execute(org.marketcetera.marketdata.IMarketDataFeedCredentials, quickfix.Message, org.marketcetera.core.publisher.ISubscriber)
     */
    public T execute(C inCredentials,
                     Message inMessage,
                     ISubscriber inSubscriber) 
        throws FeedException
    {
        if(inSubscriber == null) {
            throw new NullPointerException();
        }
        return execute(inCredentials,
                       inMessage,
                       Arrays.asList(new ISubscriber[] { inSubscriber } ));
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IMarketDataFeed#execute(org.marketcetera.marketdata.IMarketDataFeedCredentials, quickfix.Message, java.util.List)
     */
    public T execute(C inCredentials,
                     Message inMessage,
                     List<? extends ISubscriber> inSubscribers) 
        throws FeedException
    {
        if(inSubscribers == null) {
            throw new NullPointerException();
        }
        return execute(MarketDataFeedTokenSpec.generateTokenSpec((inCredentials == null ? getLatestCredentials() : inCredentials), 
                                                                 inMessage, 
                                                                 inSubscribers));
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IMarketDataFeed#execute(quickfix.Message, org.marketcetera.core.publisher.ISubscriber)
     */
    public T execute(Message inMessage,
                     ISubscriber inSubscriber)
            throws FeedException
    {
        if(inSubscriber == null) {
            throw new NullPointerException();
        }
        return execute(getLatestCredentials(),
                       inMessage,
                       inSubscriber);
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IMarketDataFeed#execute(quickfix.Message, java.util.List)
     */
    public T execute(Message inMessage,
                     List<? extends ISubscriber> inSubscribers)
            throws FeedException
    {
        if(inSubscribers == null) {
            throw new NullPointerException();
        }
        return execute(getLatestCredentials(),
                       inMessage,
                       inSubscribers);
    }    
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IMarketDataFeed#subscribeToAll(org.marketcetera.core.publisher.ISubscriber)
     */
    @Override
    public void subscribeToAll(ISubscriber inSubscriber)
    {
        synchronized(mAllPublisher) {
            mAllPublisher.subscribe(inSubscriber);
        }
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IMarketDataFeed#unsubscribeFromAll(org.marketcetera.core.publisher.ISubscriber)
     */
    @Override
    public void unsubscribeFromAll(ISubscriber inSubscriber)
    {
        synchronized(mAllPublisher) {
            mAllPublisher.unsubscribe(inSubscriber);
        }
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IFeedComponent#getFeedStatus()
     */
    public final FeedStatus getFeedStatus()
    {
        return mFeedStatus;
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IFeedComponent#getFeedType()
     */
    public final FeedType getFeedType()
    {
        return mFeedType;
    }
    /* (non-Javadoc)
     * @see org.springframework.context.Lifecycle#isRunning()
     */
    public boolean isRunning()
    {
        return getFeedStatus().isRunning();
    }
    /* (non-Javadoc)
     * @see org.springframework.context.Lifecycle#start()
     */
    public void start()
    {
        setFeedStatus(FeedStatus.AVAILABLE);
    }
    /* (non-Javadoc)
     * @see org.springframework.context.Lifecycle#stop()
     */
    public void stop()
    {
        // get all the tokens from active queries
        List<T> tokens = mHandleHolder.getTokens();
        for(T token : tokens) {
            // for each token, suspend the query.  this amounts to canceling the query
            //  on the datafeed side but keeping the token in the active list.  this
            //  accomplishes two goals:
            //   1) if the feed is truly stopping and not restarting, we clean up our
            //      connections with the datafeed
            //   2) if the feed is being restarted, we have a record of all the queries
            //      that were active before
            if(LoggerAdapter.isDebugEnabled(this)) {
                LoggerAdapter.debug(String.format("Suspending %s",
                                                  token),
                                    this);
            }
            token.setStatus(Status.SUSPENDED);
            // this performs the cancel on the datafeed side
            doHandleInvalidation(mHandleHolder.getHandles(token));
        }
        try {
            doLogout();
        } catch (InterruptedException e) {
            if(LoggerAdapter.isDebugEnabled(this)) {
                LoggerAdapter.debug("Interrupted while logging out of feed, skipping",
                                    e,
                                    this);
            }
        }
        setFeedStatus(FeedStatus.OFFLINE);
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IFeedComponent#getID()
     */
    public final String getID()
    {
        return mID.toString();
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IFeedComponent#addFeedComponentListener(org.marketcetera.core.IFeedComponentListener)
     */
    public final void addFeedComponentListener(IFeedComponentListener inListener)
    {
        mFeedStatusPublisher.subscribe(new FeedComponentListenerWrapper(inListener,
                                                                        this));
    }
    /* (non-Javadoc)
     * @see org.marketcetera.marketdata.IFeedComponent#removeFeedComponentListener(org.marketcetera.core.IFeedComponentListener)
     */
    public final void removeFeedComponentListener(IFeedComponentListener inListener)
    {
        mFeedStatusPublisher.unsubscribe(new FeedComponentListenerWrapper(inListener,
                                                                          this));
    }
    /*
     * the following methods must be implemented by the feed subclasses and
     * represent the contract between subclass and parent
     */
    /**
     * Generates a token encapsulating the given request.
     * 
     * <p>The object returned is dedicated to the execution of the given message.
     * 
     * @param inTokenSpec a <code>MarketDataFeedTokenSpec&lt;C&gt;</code> value encapsulating the data feed request
     * @return a <code>AbstractMarketDataFeedToken</code> value
     * @throws InterruptedException if the thread was interrupted during execution
     * @throws FeedException if an error occurs
     */
    protected abstract T generateToken(MarketDataFeedTokenSpec<C> inTokenSpec)
        throws InterruptedException, FeedException;
    /**
     * Executes the market data request represented by the passed value.
     * 
     * <p>The values returned in the handle list must be unique with respect
     * to the current JVM invocation for this data feed.
     *
     * @param inData a <code>D</code> value containing the data returned by
     *   the corresponding {@link IMessageTranslator}.
     * @return a <code>List&lt;String&gt;</code> value containing the set of
     *   handles to be associated with this request
     * @throws InterruptedException if the thread was interrupted during execution
     * @throws FeedException if the request cannot be transmitted to the feed
     * @see IMessageTranslator#translate(Message)
     */
    protected abstract List<String> doMarketDataRequest(D inData)
        throws InterruptedException, FeedException;
    /**
     * Executes the derivative security list request represented by the passed value.
     * 
     * <p>The values returned in the handle list must be unique with respect
     * to the current JVM invocation for this data feed.
     *
     * @param inData a <code>D</code> value containing the data returned by
     *   the corresponding {@link IMessageTranslator}.
     * @return a <code>List&lt;String&gt;</code> value containing the set of
     *   handles to be associated with this request
     * @throws InterruptedException if the thread was interrupted during execution
     * @throws FeedException if the request cannot be transmitted to the feed
     * @see IMessageTranslator#translate(Message)
     */
    protected abstract List<String> doDerivativeSecurityListRequest(D inData)
        throws InterruptedException, FeedException;
    /**
     * Executes the security list request represented by the passed value.
     * 
     * <p>The values returned in the handle list must be unique with respect
     * to the current JVM invocation for this data feed.
     *
     * @param inData a <code>D</code> value containing the data returned by
     *   the corresponding {@link IMessageTranslator}.
     * @return a <code>List&lt;String&gt;</code> value containing the set of
     *   handles to be associated with this request
     * @throws InterruptedException if the thread was interrupted during execution
     * @throws FeedException if the request cannot be transmitted to the feed
     * @see IMessageTranslator#translate(Message)
     */
    protected abstract List<String> doSecurityListRequest(D inData)
        throws InterruptedException, FeedException;
    /**
     * Returns an instance of {@link IMessageTranslator} appropriate for this feed.
     *
     * <p>The {@link IMessageTranslator} translates a FIX message to a data-type
     * appropriate for this feed.
     * 
     * @return an <code>X</code> value
     * @throws InterruptedException if the thread was interrupted during execution
     */
    protected abstract X getMessageTranslator()
        throws InterruptedException;
    /**
     * Determines if there exists an active and valid connection to the feed.
     * 
     * <p>Returns true if there exists a connection to the feed and the
     * credentials used to open that connection match the given credentials.
     *
     * @param inCredentials a <code>C</code> value
     * @return a <code>boolean</code> value
     * @throws InterruptedException if the thread was interrupted during execution
     */
    protected abstract boolean isLoggedIn(C inCredentials)
        throws InterruptedException;
    /**
     * Connects to the feed and supplies the given credentials.
     *
     * @param inCredentials a <code>C</code> value
     * @return a <code>boolean<code> value indicating whether the login
     *   was successful or not
     * @throws InterruptedException if the thread was interrupted during execution
     */
    protected abstract boolean doLogin(C inCredentials)
        throws InterruptedException;
    /**
     * Disconnect from the feed.
     * @throws InterruptedException if the thread was interrupted during execution
     */
    protected abstract void doLogout()
        throws InterruptedException;
    /**
     * Cancel the transaction associated with the given handle.
     *
     * @param inHandle a <code>String</code> value containing a handle
     *   meaningful to the feed
     * @throws InterruptedException if the thread was interrupted during execution
     */
    protected abstract void doCancel(String inHandle)
        throws InterruptedException;
    /**
     * Returns an instance of {@link IEventTranslator} appropriate for this feed.
     *
     * <p>The {@link IEventTranslator} translates data-types appropriate for this feed
     * to subclasses of {@link EventBase}.
     * 
     * @return an <code>E</code> value
     * @throws InterruptedException if the thread was interrupted during execution
     */
    protected abstract E getEventTranslator()
        throws InterruptedException;
    /*
     * the following methods *may* be overridden by implementing subclasses but
     * have default implementations as documented
     */
    /**
     * Performs any initialization steps necessary before {@link #doLogin(IMarketDataFeedCredentials)}.
     *
     * <p>This implementation does nothing.
     * 
     * @param inToken a <code>T</code> value
     * @return a <code>boolean</code> value indicating if the initialization was valid and
     *   processing may continue
     * @throws InterruptedException if the thread was interrupted during execution
     */
    protected boolean doInitialize(T inToken)
        throws InterruptedException
    {
        return true;
    }
    /**
     * Called at the beginning of {@link #doExecute(AbstractMarketDataFeedToken)}. 
     *
     * <p>This implementation returns <code>true</code>.  Subclasses may override this
     * method to abort an execution if necessary.  Return <code>false</code> to abort
     * the execution.
     * 
     * @param inToken a <code>T</code> value
     * @return a <code>boolean</code> value
     * @throws InterruptedException if the thread was interrupted during execution
     */
    protected boolean beforeDoExecute(T inToken)
        throws InterruptedException
    {
        return true;
    }
    /**
     * Called at the end of {@link #doExecute(AbstractMarketDataFeedToken)}. 
     *
     * <p>This implementation does nothing.  Subclasses may override this
     * method to implement behavior required at the end of an execution.
     * This method will always be called, regardless of the success or failure
     * of the execution.
     * 
     * @param inToken a <code>T</code> value
     * @param inException a <code>Throwable</code> value containing the exception thrown
     *   during execution or <code>null</code> if no exception was thrown
     * @throws InterruptedException if the thread is interrupted during execution of this method
     */
    protected void afterDoExecute(T inToken, 
                                  Throwable inException)
        throws InterruptedException
    {
    }
    /**
     * Gets the number of seconds to wait for an execution to be acknowledged.
     *
     * <p>This method returns 60.  Subclasses may override this method to return a different value.
     * The timeout applies to calls to {@link #execute(MarketDataFeedTokenSpec)}.  Note that the
     * feed is not obligated to return data within the time limit, merely to acknowledge log-in and
     * query submission.
     *  
     * @return a <code>long</code> value containing the number of seconds to wait before timing out
     */
    protected long getTimeout()
    {
        return 60;
    }
    /*
     * the following methods may be called by implementing subclasses but may not
     * be overridden
     */
    /**
     * Sets the status of the feed.
     * 
     * @param inFeedStatus a <code>FeedStatus</code> value
     * @throws NullPointerException if <code>inFeedStatus</code> is null
     */
    protected final void setFeedStatus(FeedStatus inFeedStatus)
    {
        if(inFeedStatus == null) {
            throw new NullPointerException();
        }
        synchronized(this) {
            // if the new status is not the same as the old one, act on it, otherwise ignore it to reduce noise
            if(!(mFeedStatus.equals(inFeedStatus))) {
                // if the old status was "off-line" and the new status is "available" then
                //  we need to do something to get the ball back rolling
                try {
                    if(!mFeedStatus.isRunning() &&
                       inFeedStatus.isRunning()) {
                        doReconnectToFeed();
                    }
                } finally {
                    // regardless of whether the above succeeds or fails, make sure
                    //  that the feed status is set appropriately and the subscribers
                    //  are notified
                    mFeedStatus = inFeedStatus;
                    mFeedStatusPublisher.publish(this);
                }
            }
        }
    }
    /**
     * Registers data received from the feed in association with the
     * given handle.
     * 
     * <p>Subclasses should call this method to process data received
     * from the data feed.
     *
     * @param inHandle a <code>MarketDataHandle</code> value
     * @param inData an <code>Object</code> value containing the data
     *   to be transmitted to subscribers
     */
    protected final void dataReceived(String inHandle,
                                      Object inData)
    {
        MarketDataHandle mdHandle = compose(inHandle);
        T token = mHandleHolder.getToken(mdHandle);
        if(token == null) {
            if(LoggerAdapter.isWarnEnabled(this)) {
                LoggerAdapter.warn(MessageKey.WARNING_MARKET_DATA_FEED_DATA_IGNORED.getLocalizedMessage(inData),
                                   this);
            }
        } else {
            try {
                E eventTranslator = getEventTranslator();
                List<EventBase> events = eventTranslator.translate(inData);
                for(EventBase event : events) {
                    publishMarketData(event);
                    token.publish(event);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn(MessageKey.WARNING_MARKET_DATA_FEED_DATA_IGNORED.getLocalizedMessage(inData),
                                       e,
                                       this);
                }
            } catch (Throwable t) {
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn(MessageKey.WARNING_MARKET_DATA_FEED_DATA_IGNORED.getLocalizedMessage(inData),
                                       t,
                                       this);
                }
            }
        }
    }
    /*
     * the following methods can be called by other package classes
     */
    /**
     * Cancels the active request represented by the given token.
     * 
     * <p>Every effort will be made to make sure each query associated with
     * the given token is canceled. 
     *
     * @param inToken a <code>T</code> value
     * @throws NullPointerException if <code>inToken</code> is null
     */
    final void cancel(T inToken)
    {
        if(inToken == null) {
            throw new NullPointerException();
        }
        try {
            // translate token to handle or handles
            List<MarketDataHandle> marketDataHandles = mHandleHolder.removeToken(inToken);
            if(marketDataHandles != null) {
                // pass handles to subclass to execute cancel
                for(MarketDataHandle marketDataHandle : marketDataHandles) {
                    try {
                        doCancel(decompose(marketDataHandle));
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        if(LoggerAdapter.isWarnEnabled(this)) {
                            LoggerAdapter.warn(MessageKey.WARNING_MARKET_DATA_FEED_CANNOT_CANCEL_SUBSCRIPTION.getLocalizedMessage(marketDataHandle),
                                               e,
                                               this);
                        }
                    } catch (Throwable t) {
                        if(LoggerAdapter.isWarnEnabled(this)) {
                            LoggerAdapter.warn(MessageKey.WARNING_MARKET_DATA_FEED_CANNOT_CANCEL_SUBSCRIPTION.getLocalizedMessage(marketDataHandle),
                                               t,
                                               this);
                        }
                    }
                }
            }
        } finally {
            inToken.setStatus(Status.CANCELED);
        }
    }
    /*
     * the following methods are helper methods for this class
     */
    /**
     * Performs the execution of the market data request.
     *
     * @param inToken a <code>T</code> value
     * @return a <code>boolean</code> value
     * @throws InterruptedException if the thread was interrupted during execution of this method
     */
    private boolean doExecute(T inToken)
        throws InterruptedException
    {
        Throwable thrownException = null;        
        try {
            if(!beforeDoExecute(inToken)) {
                return false;
            }
            // translate fix message to specialized type
            X xlator = getMessageTranslator();
            // the request is represented by a FIX message stored on the token
            Message message = inToken.getTokenSpec().getMessage();
            // translate the FIX message to an appropriate proprietary format
            D data = xlator.translate(message);
            if(FIXMessageUtil.isMarketDataRequest(message)) {
                processResponse(doMarketDataRequest(data), 
                                inToken);
                return true;
            }
            if(FIXMessageUtil.isDerivativeSecurityListRequest(message)) {
                processResponse(doDerivativeSecurityListRequest(data), 
                                inToken);
                return true;
            }
            if(FIXMessageUtil.isSecurityListRequest(message)) {
                processResponse(doSecurityListRequest(data), 
                                inToken);
                return true;
            }
            // Unhandled message type
            if(LoggerAdapter.isErrorEnabled(this)) {
                LoggerAdapter.error(MessageKey.ERROR_MARKET_DATA_FEED_UNKNOWN_MESSAGE_TYPE.getLocalizedMessage(),
                                    this);
            }
            return false;
        } catch (InterruptedException e) {
            thrownException = e;
            if(LoggerAdapter.isErrorEnabled(this)) {
                LoggerAdapter.error(MessageKey.ERROR_MARKET_DATA_FEED_EXECUTION_FAILED.getLocalizedMessage(),
                                    e,
                                    this);
            }
            throw e;
        } catch (Throwable t) {
            thrownException = t;
            if(LoggerAdapter.isErrorEnabled(this)) {
                LoggerAdapter.error(MessageKey.ERROR_MARKET_DATA_FEED_EXECUTION_FAILED.getLocalizedMessage(),
                                    t,
                                    this);
            }
            return false;
        } finally {
            afterDoExecute(inToken, 
                           thrownException);
        }
    }
    /**
     * Processes the handles returned from a feed request.
     * 
     * <p>The given handles will be associated with the given token.  Later, when data is returned from the feed via {@link #dataReceived(String, Object)},
     * the handles stored here are used to associate the data with the token.
     *
     * @param inHandles a <code>List&lt;String&gt;</code> value containing the handles returned from the feed to associate with the given token
     * @param inToken a <code>T</code> value to which to associate the handles
     */
    private void processResponse(List<String> inHandles,
                                 T inToken)
    {
        if(inHandles == null ||
           inHandles.size() == 0) {
            // TODO move to message catalog
            if(LoggerAdapter.isWarnEnabled(this)) {
                LoggerAdapter.warn(String.format("The market data feed request did not return a handle so results from the request will be discarded."),
                                   this);
            }
        } else {
            mHandleHolder.addHandles(inToken,
                                     inHandles);
        }
    }
    /**
     * Executes the steps necessary when the connection to the feed has been
     * resumed.
     */
    private void doReconnectToFeed()
    {
        if(LoggerAdapter.isDebugEnabled(this)) {
            LoggerAdapter.debug("Reconnected to feed, resubmitting queries",
                                this);
        }
        // retrieve all the tokens for active queries
        Collection<T> tokens = mHandleHolder.getTokens();
        // these tokens need to be resubmitted to the feed
        // the token must still be valid because the various subscribers
        //  will still be listening.  the query represented by the token
        //  needs to be resubmitted to the feed and the resulting handles
        //  need to be added to the collection.
        for(T token : tokens) {
            // remove old record of this query
            doHandleInvalidation(mHandleHolder.removeToken(token));
            // set status to indicate it is being resubmitted
            token.setStatus(Status.RESUBMITTING);
            // newly submit query, allowing its new handles to be added
            if(LoggerAdapter.isDebugEnabled(this)) {
                LoggerAdapter.debug(String.format("Resubmitting %s",
                                                  token),
                                    this);
            }
            // resubmit the token with the token's credentials
            C credentials = token.getTokenSpec().getCredentials();
            try {
                submitToken(token, 
                            credentials);
            } catch (TimeoutException e) {
                if(LoggerAdapter.isErrorEnabled(this)) {
                    LoggerAdapter.error(String.format("Failed to resubmit %s",
                                                      token),
                                                      e,
                                                      this);
                }
                break;
            } catch (FeedException e) {
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn(String.format("Failed to resubmit %s",
                                                     token),
                                                     e,
                                                     this);
                }
            }
        }
    }
    /**
     * Executes the invalidation of the handles passed.
     * 
     * <p>The feed will be notified that each handle passed is invalid.
     * 
     * @param inHandles a <code>List&lt;MarketDataHandle&gt;</code> value
     */
    private void doHandleInvalidation(List<MarketDataHandle> inHandles)
    {
        for(MarketDataHandle handle : inHandles) {
            try {
                doCancel(handle.decompose());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn(MessageKey.WARNING_MARKET_DATA_FEED_CANNOT_CANCEL_SUBSCRIPTION.getLocalizedMessage(handle),
                                       e,
                                       this);
                }
            } catch (Throwable t) {
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn(MessageKey.WARNING_MARKET_DATA_FEED_CANNOT_CANCEL_SUBSCRIPTION.getLocalizedMessage(handle),
                                       t,
                                       this);
                }
            }
        }
    }
    /**
     * Returns a {@link MarketDataHandle} instance encapsulating the given data feed proto-handle.
     *
     * @param inSeed a <code>String</code> value containing the proto-handle returned from
     *   a data feed
     * @return a <code>MarketDataHandle</code> value
     */
    private MarketDataHandle compose(String inSeed)
    {
        return new MarketDataHandle(inSeed);
    }
    /**
     * Returns the data feed proto-handle from the given {@link MarketDataHandle}.
     *
     * @param inHandle a <code>MarketDataHandle</code> value
     * @return a <code>String</code> value
     */
    private String decompose(MarketDataHandle inHandle)
    {
        return inHandle.decompose();
    } 
    /**
     * Get the latestCredentials value.
     *
     * @return a <code>AbstractMarketDataFeed</code> value
     */
    private C getLatestCredentials()
    {
        return mLatestCredentials;
    }
    /**
     * Sets the latestCredentials value.
     *
     * @param a <code>AbstractMarketDataFeed</code> value
     */
    private void setLatestCredentials(C inLatestCredentials)
    {
        mLatestCredentials = inLatestCredentials;
    }
    /**
     * Publishes market data to all subscribers.
     *
     * <p>Subscribers subscribed to {@link #subscribeToAll(ISubscriber)} will
     * be notified of market data passed to this method.
     * 
     * @param inEvent an <code>EventBase</code> value
     */
    private void publishMarketData(EventBase inEvent)
    {
        synchronized(mAllPublisher) {
            mAllPublisher.publish(inEvent);
        }
    }
    /**
     * Returns the provider name associated with this feed.
     *
     * @return a <code>String</code> value
     */
    private String getProviderName()
    {
        return mProviderName;
    }
    /**
     * Causes the given token to be executed with the given credentials.
     *
     * @param inToken a <code>T</code> value
     * @param inCredentials a <code>C</code> value
     * @return a <code>T</code> value
     * @throws TimeoutException if the execute times out before returning 
     * @throws FeedException if an exception occurs
     */
    private T submitToken(T inToken,
                          C inCredentials) 
        throws FeedException, TimeoutException
    {
        // construct the object that will be invoked by the ThreadPool - this object is used
        //  to execute the query represented by the token
        ExecutorThread thread = new ExecutorThread(inToken,
                                                   inCredentials);        
        try {
            // this command executes the request using the connector.  the connector has all the information it needs
            //  to execute the request because of the token.  this command is asynchronous.
            Future<T> response = sPool.submit(thread);
            // wait for the response to be returned for a max of 1 minute.  this doesn't mean that the results are back yet, just that
            //  the request has been received and acknowledged by the feed service.  if you can dig it, it's an
            //  asynchronous request for an asynchronous response.
            return response.get(getTimeout(),
                                TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            throw e;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new FeedException(MessageKey.ERROR_MARKET_DATA_FEED_EXECUTION_FAILED.getLocalizedMessage(),
                                    e);
        } catch (Throwable t) {
            throw new FeedException(MessageKey.ERROR_MARKET_DATA_FEED_EXECUTION_FAILED.getLocalizedMessage(),
                                    t);
        }
    }
    /*
     * the following are private helper classes
     */
    /**
     * Helper that performs the actual execution in the threadpool. 
     *
     * <p>This class exists for two reasons:
     * <ol>
     *   <li>Implement {@link Callable} which includes a public method for
     *       the benefit of the {@link ExecutorService} (threadpool) but
     *       without requiring {@link AbstactMarketDataFeed}
     *       to implement {@link Callable#call()}, which should not be
     *       called by external classes.</li>
     *   <li>Make sure that a specific pair of {@link T} and {@link C}
     *       corresponds to the {@link Callable#call()} method that uses
     *       them</li>
     * </ol>
     * 
     * <p>Note that this class is intentionally declared <code>non-static</code>
     * because it must have access to the parent's <code>T</code> and <code>C</code>
     * types and must call several non-static methods on the parent.
     *
     * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
     * @version $Id$
     * @since 0.5.0
     */
    @ClassVersion("$Id$")
    private class ExecutorThread
        implements Callable<T>
    {
        /**
         * the token representing the request and its responses
         */
        private final T mToken;
        /**
         * the credentials provided to fulfill the request
         */
        private final C mCredentials;
        /**
         * Create a new ExecutorThread instance.
         *
         * @param inToken a <code>T</code> value
         * @param inCredentials a <code>C</code> value
         */
        private ExecutorThread(T inToken,
                               C inCredentials)
        {
            mToken = inToken;
            mCredentials = inCredentials;
        }       
        /* (non-Javadoc)
         * @see java.util.concurrent.Callable#call()
         */
        public T call()
                throws Exception
        {
            C credentials = mCredentials;
            T token = mToken;

            token.setStatus(IMarketDataFeedToken.Status.RUNNING);
            // check to see if we're currently logged in to match
            //  the current credentials
            boolean succeeded = false;
            try {
                succeeded = isLoggedIn(credentials);
                if(!succeeded) {
                    succeeded = doLogin(credentials);
                }
            } catch (InterruptedException e) {
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn("Unable to log in to feed, execution failed",
                                       e,
                                       this);
                }
                throw e;
            } catch (Throwable t) {
                // any exception thrown during login will be the same as if the
                //  login explicitly failed
                // TODO move to message catalog
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn("Unable to log in to feed, execution failed",
                                       t,
                                       this);
                }
                succeeded = false;
            }
            if(!succeeded) {
                // bail out expressing sadness
                token.setStatus(IMarketDataFeedToken.Status.LOGIN_FAILED);
                return token;
            }
            // feed is logged in
            // do any initialization required
            succeeded = false;
            try {
                succeeded = doInitialize(token);
            } catch (InterruptedException e) {
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn("Unable to initialize feed, execution failed",
                                       e,
                                       this);
                }
                throw e;
            } catch (Throwable t) {
                // TODO move to message catalog
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn("Unable to initialize feed, execution failed",
                                       t,
                                       this);
                }
                succeeded = false;
            }
            if(!succeeded) {
                token.setStatus(IMarketDataFeedToken.Status.INITIALIZATION_FAILED);
                return token;
            }
            // feed should be ready for commands
            // execute command, wait for status response, not responses to the actual command
            succeeded = false;
            try {
                succeeded = doExecute(token);
            } catch (InterruptedException e) {
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn("Unable to execute command on feed, execution failed",
                                       e,
                                       this);
                }
                throw e;
            } catch (Throwable t) {
                // TODO move to message catalog
                if(LoggerAdapter.isWarnEnabled(this)) {
                    LoggerAdapter.warn("Unable to execute command on feed, execution failed",
                                       t,
                                       this);
                }
                succeeded = false;
            }
            if(!succeeded) {
                token.setStatus(IMarketDataFeedToken.Status.EXECUTION_FAILED);
                return token;
            }
            token.setStatus(IMarketDataFeedToken.Status.ACTIVE);
            return token;
        }        
    }
    /**
     * Encapsulates the handles and tokens collections.
     *
     * <p>Note that this class is declared non-static intentionally in order
     * to use the parent class's generic types.
     *
     * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
     * @version $Id$
     * @since 0.5.0
     */    
    @ClassVersion("$Id$")
    private class HandleHolder
    {
        /**
         * stores client response handles by token - note that these two collections must be kept in sync
         */
        private final Map<T,List<MarketDataHandle>> mHandlesByToken = new HashMap<T,List<MarketDataHandle>>();
        /**
         * stores tokens by handle - note that these two collections must be kept in sync
         */
        private final Map<MarketDataHandle,T> mTokensByHandle = new HashMap<MarketDataHandle,T>();
        /**
         * object used for synchronization lock for these two collections
         */
        private final Object mLock = new Object();
        /**
         * Create a new HandleHolder instance.
         */
        private HandleHolder()
        {            
        }
        /**
         * Records the given handles as associated to the given token.
         *
         * @param inToken a <code>T</code> value
         * @param inHandles a <code>List&lt;String&gt;</code> value
         */
        private void addHandles(T inToken,
                                List<String> inHandles)
        {
            // by convention, synchronization for mHandlesByToken and mTokensByHandle
            //  is performed on mLock to avoid deadlock - do not access
            //  mTokensByHandle or mHandlesByToken without synchronizing mLock
            synchronized(mLock) {
                List<MarketDataHandle> marketDataHandles = mHandlesByToken.get(inToken);
                if(marketDataHandles == null){
                    marketDataHandles = new ArrayList<MarketDataHandle>();
                }
                for(String handle : inHandles) {
                    MarketDataHandle mdHandle = compose(handle);
                    marketDataHandles.add(mdHandle);
                    mTokensByHandle.put(mdHandle, 
                                        inToken);
                }
                mHandlesByToken.put(inToken, 
                                    marketDataHandles);
            }
        }
        /**
         * Returns the token associated with the given handle.
         *
         * @param inMarketDataHandle a <code>MarketDataHandle</code> value
         * @return a <code>T</code> value or null if no token is associated
         *   with the given handle
         */
        private T getToken(MarketDataHandle inMarketDataHandle)
        {
            // by convention, synchronization for mHandlesByToken and mTokensByHandle
            //  is performed on mLock to avoid deadlock - do not access
            //  mTokensByHandle or mHandlesByToken without synchronizing mLock
            synchronized(mLock) {
                return mTokensByHandle.get(inMarketDataHandle);
            }
        }
        /**
         * Removes the given token and its handles from the handle list.
         *
         * @param inToken a <code>T</code> value
         * @return a <code>List&lt;MarketDataHandle&gt;</code> value containing the handles
         *   associated with the token
         */
        private List<MarketDataHandle> removeToken(T inToken)
        {
            List<MarketDataHandle> handles;
            // by convention, synchronization for mHandlesByToken and mTokensByHandle
            //  is performed on mLock to avoid deadlock - do not access
            //  mTokensByHandle or mHandlesByToken without synchronizing mLock
            synchronized(mLock) {
                handles = mHandlesByToken.remove(inToken);
                if(handles == null) {
                    return new ArrayList<MarketDataHandle>();
                }
                for(MarketDataHandle handle : handles) {
                    mTokensByHandle.remove(handle);
                }
            }
            return handles;
        }
        /**
         * Gets the handles associated with the given token.
         *
         * @param inToken a <code>T</code> value
         * @return a <code>List&lt;MarketDataHandle&gt;</code> value
         */
        private List<MarketDataHandle> getHandles(T inToken)
        {            
            synchronized(mLock) {
                List<MarketDataHandle> handles = mHandlesByToken.get(inToken);
                if(handles == null) {
                    handles = new ArrayList<MarketDataHandle>();
                }
                return handles;
            }
        }
        /**
         * Returns all the tokens in no particular order.
         * 
         * @return a <code>Collection&lt;T&gt;</code> value
         */
        private List<T> getTokens()
        {
            synchronized(mLock) {
                return new ArrayList<T>(mTokensByHandle.values());
            }
        }
   }
    /**
     * A unique handle to associate data feed requests with responses.
     *
     * <p>The handle created is guaranteed to be unique within the scope of all
     * data feeds in the current JVM run iff:
     * <ol>
     *   <li>all proto-handles returned by {@link AbstractMarketDataFeed#doMarketDataRequest(Object)} 
     *       are unique within the scope of the relevant feed in the current JVM run</li>
     *   <li>the set of values returned by {@link IMarketDataFeedFactory#getProviderName()} from all
     *       data feeds contains no duplicates</li>
     * </ol>
     *       
     * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
     * @version $Id$
     * @since 0.5.0
     */
    @ClassVersion("$Id$")
    private class MarketDataHandle
    {
        /**
         * the handle value
         */
        private final String mHandle;
        /**
         * the handle from the data feed itself
         */
        private final String mProtoHandle;
        /**
         * Create a new MarketDataHandle instance.
         *
         * @param inHandle a <code>String</code> value containing a value
         *   meaningful to the originating data feed which can be used
         *   to refer to a unique data feed request
         * @throws NullPointerException if <code>inHandle</code> is null
         */
        private MarketDataHandle(String inHandle)
        {
            if(inHandle == null) {
                throw new NullPointerException();
            }
            mProtoHandle = inHandle;
            mHandle = String.format("%s-%s",
                                    getProviderName(),
                                    inHandle);
        }
        /**
         * Returns the proto-handle used to originally create this object.
         *
         * @return a <code>String</code> value
         */
        private String decompose()
        {
            return new String(mProtoHandle);
        }
        /* (non-Javadoc)
         * @see java.lang.Object#toString()
         */
        public String toString()
        {
            return new String(mHandle);
        }
        /* (non-Javadoc)
         * @see java.lang.Object#hashCode()
         */
        public int hashCode()
        {
            final int PRIME = 31;
            int result = 1;
            result = PRIME * result + ((mHandle == null) ? 0 : mHandle.hashCode());
            return result;
        }
        /* (non-Javadoc)
         * @see java.lang.Object#equals(java.lang.Object)
         */
        public boolean equals(Object obj)
        {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            final MarketDataHandle other = (MarketDataHandle) obj;
            if (mHandle == null) {
                if (other.mHandle != null)
                    return false;
            } else if (!mHandle.equals(other.mHandle))
                return false;
            return true;
        }
    }
    /**
     * Wraps the {@link FeedComponentListener} for this feed.
     *
     * <p>The wrapper translates {@link ISubscriber} methods to
     * the {@link IFeedComponentListener} objects.
     * 
     * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
     * @version $Id$
     * @since 0.5.0
     */
    @ClassVersion("$Id$")
    private static class FeedComponentListenerWrapper
        implements ISubscriber
    {
        /**
         * the feed component listener to which to transmit feed status updates
         */
        private final IFeedComponentListener mListener;
        /**
         * the feed component (data feed) whose status is changing
         */
        private final IFeedComponent mParent;
        /**
         * Create a new FeedComponentListenerWrapper instance.
         *
         * @param inListener an <code>IFeedComponentListener</code> value
         * @param inParent an <code>IFeedComponent</code> value
         * @throws NullPointerException if either the listener or parent are null
         */
        private FeedComponentListenerWrapper(IFeedComponentListener inListener,
                                             IFeedComponent inParent)
        {
            if(inListener == null ||
               inParent == null) {
                throw new NullPointerException();
            }
            mListener = inListener;
            mParent = inParent;
        }
        /* (non-Javadoc)
         * @see org.marketcetera.core.publisher.ISubscriber#isInteresting(java.lang.Object)
         */
        public boolean isInteresting(Object inData)
        {
            return true;
        }
        /* (non-Javadoc)
         * @see org.marketcetera.core.publisher.ISubscriber#publishTo(java.lang.Object)
         */
        public void publishTo(Object inData)
        {
            mListener.feedComponentChanged(mParent);
        }
        /* (non-Javadoc)
         * @see java.lang.Object#hashCode()
         */
        public int hashCode()
        {
            final int PRIME = 31;
            int result = 1;
            result = PRIME * result + ((mListener == null) ? 0 : mListener.hashCode());
            return result;
        }
        /* (non-Javadoc)
         * @see java.lang.Object#equals(java.lang.Object)
         */
        public boolean equals(Object obj)
        {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            final FeedComponentListenerWrapper other = (FeedComponentListenerWrapper) obj;
            if (mListener == null) {
                if (other.mListener != null)
                    return false;
            } else if (!mListener.equals(other.mListener))
                return false;
            return true;
        }
    }
}
