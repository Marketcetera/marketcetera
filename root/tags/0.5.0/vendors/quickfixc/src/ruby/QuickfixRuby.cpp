/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.35
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */
#include "stdafx.h"

#ifdef HAVE_RUBY
#define SWIGRUBY
#define SWIG_DIRECTORS

#ifdef __cplusplus
template<typename T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic CAPI SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The swig conversion methods, as ConvertPtr, return and integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old swig versions, you usually write code as:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit as:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   that seems to be the same, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   requires also to SWIG_ConvertPtr to return new result values, as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   swig errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()


 */
#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))


/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif




#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/* think of this as a c++ template<> or a scheme macro */
#define SWIG_TypeCheck_Template(comparison, ty)         \
  if (ty) {                                             \
    swig_cast_info *iter = ty->cast;                    \
    while (iter) {                                      \
      if (comparison) {                                 \
        if (iter == ty->cast) return iter;              \
        /* Move iter to the top of the linked list */   \
        iter->prev->next = iter->next;                  \
        if (iter->next)                                 \
          iter->next->prev = iter->prev;                \
        iter->next = ty->cast;                          \
        iter->prev = 0;                                 \
        if (ty->cast) ty->cast->prev = iter;            \
        ty->cast = iter;                                \
        return iter;                                    \
      }                                                 \
      iter = iter->next;                                \
    }                                                   \
  }                                                     \
  return 0

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
}

/* Same as previous function, except strcmp is replaced with a pointer comparison */
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
  SWIG_TypeCheck_Template(iter->type == from, into);
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



#include <ruby.h>

/* Remove global macros defined in Ruby's win32.h */
#ifdef write
# undef write
#endif
#ifdef read
# undef read
#endif
#ifdef send
# undef send
#endif
#ifdef close
# undef close
#endif
#ifdef connect
# undef connect
#endif
#ifdef setsockopt
# undef setsockopt
#endif
#ifdef bind
# undef bind
#endif
#ifdef listen
# undef listen
#endif
#ifdef accept
# undef accept
#endif




/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/* RSTRING_LEN, etc are new in Ruby 1.9, but ->ptr and ->len no longer work */
/* Define these for older versions so we can just write code the new way */
#ifndef RSTRING_LEN
# define RSTRING_LEN(x) RSTRING(x)->len
#endif
#ifndef RSTRING_PTR
# define RSTRING_PTR(x) RSTRING(x)->ptr
#endif
#ifndef RSTRING_END
# define RSTRING_END(x) (RSTRING_PTR(x) + RSTRING_LEN(x))
#endif
#ifndef RARRAY_LEN
# define RARRAY_LEN(x) RARRAY(x)->len
#endif
#ifndef RARRAY_PTR
# define RARRAY_PTR(x) RARRAY(x)->ptr
#endif
#ifndef RFLOAT_VALUE
# define RFLOAT_VALUE(x) RFLOAT(x)->value
#endif
#ifndef DOUBLE2NUM
# define DOUBLE2NUM(x) rb_float_new(x)
#endif
#ifndef RHASH_TBL
# define RHASH_TBL(x) (RHASH(x)->tbl)
#endif
#ifndef RHASH_ITER_LEV
# define RHASH_ITER_LEV(x) (RHASH(x)->iter_lev)
#endif
#ifndef RHASH_IFNONE
# define RHASH_IFNONE(x) (RHASH(x)->ifnone)
#endif
#ifndef RHASH_SIZE
# define RHASH_SIZE(x) (RHASH(x)->tbl->num_entries)
#endif
#ifndef RHASH_EMPTY_P
# define RHASH_EMPTY_P(x) (RHASH_SIZE(x) == 0)
#endif
#ifndef RSTRUCT_LEN
# define RSTRUCT_LEN(x) RSTRUCT(x)->len
#endif
#ifndef RSTRUCT_PTR
# define RSTRUCT_PTR(x) RSTRUCT(x)->ptr
#endif



/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING_PTR(RB_STRING_VALUE(s))
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING_LEN(RB_STRING_VALUE(s))
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif

static VALUE _mSWIG = Qnil;

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */


/* Define some additional error types */
#define SWIG_ObjectPreviouslyDeletedError  -100


/* Define custom exceptions for errors that do not map to existing Ruby
   exceptions.  Note this only works for C++ since a global cannot be
   initialized by a funtion in C.  For C, fallback to rb_eRuntimeError.*/

SWIGINTERN VALUE 
getNullReferenceError(void) {
  static int init = 0;
  static VALUE rb_eNullReferenceError ;
  if (!init) {
    init = 1;
    rb_eNullReferenceError = rb_define_class("NullReferenceError", rb_eRuntimeError);
  }
  return rb_eNullReferenceError;
} 

SWIGINTERN VALUE 
getObjectPreviouslyDeletedError(void) {
  static int init = 0;
  static VALUE rb_eObjectPreviouslyDeleted ;
  if (!init) {
    init = 1;
    rb_eObjectPreviouslyDeleted = rb_define_class("ObjectPreviouslyDeleted", rb_eRuntimeError);
  }
  return rb_eObjectPreviouslyDeleted;
} 


SWIGINTERN VALUE
SWIG_Ruby_ErrorType(int SWIG_code) {
  VALUE type;
  switch (SWIG_code) {
  case SWIG_MemoryError:
    type = rb_eNoMemError;
    break;
  case SWIG_IOError:
    type = rb_eIOError;
    break;
  case SWIG_RuntimeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_IndexError:
    type = rb_eIndexError;
    break;
  case SWIG_TypeError:
    type = rb_eTypeError;
    break;
  case SWIG_DivisionByZero:
    type = rb_eZeroDivError;
    break;
  case SWIG_OverflowError:
    type = rb_eRangeError;
    break;
  case SWIG_SyntaxError:
    type = rb_eSyntaxError;
    break;
  case SWIG_ValueError:
    type = rb_eArgError;
    break;
  case SWIG_SystemError:
    type = rb_eFatal;
    break;
  case SWIG_AttributeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_NullReferenceError:
    type = getNullReferenceError();
    break;
  case SWIG_ObjectPreviouslyDeletedError:
    type = getObjectPreviouslyDeletedError();
    break;
  case SWIG_UnknownError:
    type = rb_eRuntimeError;
    break;
  default:
    type = rb_eRuntimeError;
  }
  return type;
}


/* This function is called when a user inputs a wrong argument to
   a method.
 */
SWIGINTERN 
const char* Ruby_Format_TypeError( const char* msg,
				   const char* type, 
				   const char* name, 
				   const int argn,
				   VALUE input )
{
  char buf[128];
  VALUE str;
  VALUE asStr;
  if ( msg && *msg )
    {
      str = rb_str_new2(msg);
    }
  else
    {
      str = rb_str_new(NULL, 0);
    }

  str = rb_str_cat2( str, "Expected argument " );
  sprintf( buf, "%d of type ", argn-1 );
  str = rb_str_cat2( str, buf );
  str = rb_str_cat2( str, type );
  str = rb_str_cat2( str, ", but got " );
  str = rb_str_cat2( str, rb_obj_classname(input) );
  str = rb_str_cat2( str, " " );
  asStr = rb_inspect(input);
  if ( RSTRING_LEN(asStr) > 30 )
    {
      str = rb_str_cat( str, StringValuePtr(asStr), 30 );
      str = rb_str_cat2( str, "..." );
    }
  else
    {
      str = rb_str_append( str, asStr );
    }

  if ( name )
    {
      str = rb_str_cat2( str, "\n\tin SWIG method '" );
      str = rb_str_cat2( str, name );
      str = rb_str_cat2( str, "'" );
    }

  return StringValuePtr( str );
}

/* This function is called when an overloaded method fails */
SWIGINTERN 
void Ruby_Format_OverloadedError(
				 const int argc,
				 const int maxargs,
				 const char* method, 
				 const char* prototypes 
				 )
{
  const char* msg = "Wrong # of arguments";
  if ( argc <= maxargs ) msg = "Wrong arguments";
  rb_raise(rb_eArgError,"%s for overloaded method '%s'.\n"  
	   "Possible C/C++ prototypes are:\n%s",
	   msg, method, prototypes);
}

/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * rubytracking.swg
 *
 * This file contains support for tracking mappings from 
 * Ruby objects to C++ objects.  This functionality is needed
 * to implement mark functions for Ruby's mark and sweep
 * garbage collector.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* Ruby 1.8 actually assumes the first case. */
#if SIZEOF_VOIDP == SIZEOF_LONG
#  define SWIG2NUM(v) LONG2NUM((unsigned long)v)
#  define NUM2SWIG(x) (unsigned long)NUM2LONG(x)
#elif SIZEOF_VOIDP == SIZEOF_LONG_LONG
#  define SWIG2NUM(v) LL2NUM((unsigned long long)v)
#  define NUM2SWIG(x) (unsigned long long)NUM2LL(x)
#else
#  error sizeof(void*) is not the same as long or long long
#endif


/* Global Ruby hash table to store Trackings from C/C++
   structs to Ruby Objects. 
*/
static VALUE swig_ruby_trackings = Qnil;

/* Global variable that stores a reference to the ruby
   hash table delete function. */
static ID swig_ruby_hash_delete;

/* Setup a Ruby hash table to store Trackings */
SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
  /* Create a ruby hash table to store Trackings from C++ 
     objects to Ruby objects. */

  /* Try to see if some other .so has already created a 
     tracking hash table, which we keep hidden in an instance var
     in the SWIG module.
     This is done to allow multiple DSOs to share the same
     tracking table.
  */
  ID trackings_id = rb_intern( "@__trackings__" );
  VALUE verbose = rb_gv_get("VERBOSE");
  rb_gv_set("VERBOSE", Qfalse);
  swig_ruby_trackings = rb_ivar_get( _mSWIG, trackings_id );
  rb_gv_set("VERBOSE", verbose);

  /* No, it hasn't.  Create one ourselves */ 
  if ( swig_ruby_trackings == Qnil )
    {
      swig_ruby_trackings = rb_hash_new();
      rb_ivar_set( _mSWIG, trackings_id, swig_ruby_trackings );
    }

  /* Now store a reference to the hash table delete function
     so that we only have to look it up once.*/
  swig_ruby_hash_delete = rb_intern("delete");
}

/* Get a Ruby number to reference a pointer */
SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr) {
  /* We cast the pointer to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the pointer to a Ruby number */
  return SWIG2NUM(ptr);
}

/* Get a Ruby number to reference an object */
SWIGRUNTIME VALUE SWIG_RubyObjectToReference(VALUE object) {
  /* We cast the object to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the Object to a Ruby number */
  return SWIG2NUM(object);
}

/* Get a Ruby object from a previously stored reference */
SWIGRUNTIME VALUE SWIG_RubyReferenceToObject(VALUE reference) {
  /* The provided Ruby number object is a reference
     to the Ruby object we want.*/

  /* Convert the Ruby number to a Ruby object */
  return NUM2SWIG(reference);
}

/* Add a Tracking from a C/C++ struct to a Ruby object */
SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object) {
  /* In a Ruby hash table we store the pointer and
     the associated Ruby object.  The trick here is
     that we cannot store the Ruby object directly - if
     we do then it cannot be garbage collected.  So
     instead we typecast it as a unsigned long and
     convert it to a Ruby number object.*/

  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Get a reference to the Ruby object as a Ruby number */
  VALUE value = SWIG_RubyObjectToReference(object);

  /* Store the mapping to the global hash table. */
  rb_hash_aset(swig_ruby_trackings, key, value);
}

/* Get the Ruby object that owns the specified C/C++ struct */
SWIGRUNTIME VALUE SWIG_RubyInstanceFor(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Now lookup the value stored in the global hash table */
  VALUE value = rb_hash_aref(swig_ruby_trackings, key);
	
  if (value == Qnil) {
    /* No object exists - return nil. */
    return Qnil;
  }
  else {
    /* Convert this value to Ruby object */
    return SWIG_RubyReferenceToObject(value);
  }
}

/* Remove a Tracking from a C/C++ struct to a Ruby object.  It
   is very important to remove objects once they are destroyed
   since the same memory address may be reused later to create
   a new object. */
SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Delete the object from the hash table by calling Ruby's
     do this we need to call the Hash.delete method.*/
  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);
}

/* This is a helper method that unlinks a Ruby object from its
   underlying C++ object.  This is needed if the lifetime of the
   Ruby object is longer than the C++ object */
SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr) {
  VALUE object = SWIG_RubyInstanceFor(ptr);

  if (object != Qnil) {
    DATA_PTR(object) = 0;
  }
}


#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * Ruby API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN VALUE
SWIG_Ruby_AppendOutput(VALUE target, VALUE o) {
  if (NIL_P(target)) {
    target = o;
  } else {
    if (TYPE(target) != T_ARRAY) {
      VALUE o2 = target;
      target = rb_ary_new();
      rb_ary_push(target, o2);
    }
    rb_ary_push(target, o);
  }
  return target;
}

/* For ruby1.8.4 and earlier. */
#ifndef RUBY_INIT_STACK
   RUBY_EXTERN void Init_stack(VALUE* addr);
#  define RUBY_INIT_STACK \
   VALUE variable_in_this_stack_frame; \
   Init_stack(&variable_in_this_stack_frame);
#endif


#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * rubyrun.swg
 *
 * This file contains the runtime support for Ruby modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0

/* for raw pointers */
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Ruby_NewPointerObj(ptr, type, flags)
#define SWIG_AcquirePtr(ptr, own)                       SWIG_Ruby_AcquirePtr(ptr, own)
#define swig_owntype                                    ruby_owntype

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Ruby_GetModule()	
#define SWIG_SetModule(clientdata, pointer) 		SWIG_Ruby_SetModule(pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), msg)
#define SWIG_fail                        		goto fail				 


/* Ruby-specific SWIG API */

#define SWIG_InitRuntime()                              SWIG_Ruby_InitRuntime()              
#define SWIG_define_class(ty)                        	SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty)             	SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
#define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  

#include "assert.h"

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
  int trackObjects;
} swig_class;


/* Global pointer used to keep some internal SWIG stuff */
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

/* Global IDs used to keep some internal SWIG stuff */
static ID swig_arity_id = 0;
static ID swig_call_id  = 0;

/*
  If your swig extension is to be run within an embedded ruby and has
  director callbacks, you should set -DRUBY_EMBEDDED during compilation.  
  This will reset ruby's stack frame on each entry point from the main 
  program the first time a virtual director function is invoked (in a 
  non-recursive way).
  If this is not done, you run the risk of Ruby trashing the stack.
*/

#ifdef RUBY_EMBEDDED

#  define SWIG_INIT_STACK                            \
      if ( !swig_virtual_calls ) { RUBY_INIT_STACK } \
      ++swig_virtual_calls;
#  define SWIG_RELEASE_STACK --swig_virtual_calls;
#  define Ruby_DirectorTypeMismatchException(x) \
          rb_raise( rb_eTypeError, x ); return c_result;

      static unsigned int swig_virtual_calls = 0;

#else  /* normal non-embedded extension */

#  define SWIG_INIT_STACK
#  define SWIG_RELEASE_STACK
#  define Ruby_DirectorTypeMismatchException(x) \
          throw Swig::DirectorTypeMismatchException( x );

#endif  /* RUBY_EMBEDDED */


SWIGRUNTIME VALUE 
getExceptionClass(void) {
  static int init = 0;
  static VALUE rubyExceptionClass ;
  if (!init) {
    init = 1;
    rubyExceptionClass = rb_const_get(_mSWIG, rb_intern("Exception"));
  }
  return rubyExceptionClass;
} 

/* This code checks to see if the Ruby object being raised as part
   of an exception inherits from the Ruby class Exception.  If so,
   the object is simply returned.  If not, then a new Ruby exception
   object is created and that will be returned to Ruby.*/
SWIGRUNTIME VALUE
SWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj) {
  VALUE exceptionClass = getExceptionClass();
  if (rb_obj_is_kind_of(obj, exceptionClass)) {
    return obj;
  }  else {
    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));
  }
}

/* Initialize Ruby runtime support */
SWIGRUNTIME void
SWIG_Ruby_InitRuntime(void)
{
  if (_mSWIG == Qnil) {
    _mSWIG = rb_define_module("SWIG");
    swig_call_id  = rb_intern("call");
    swig_arity_id = rb_intern("arity");
  }
}

/* Define Ruby class for C type */
SWIGRUNTIME void
SWIG_Ruby_define_class(swig_type_info *type)
{
  VALUE klass;
  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
  sprintf(klass_name, "TYPE%s", type->name);
  if (NIL_P(_cSWIG_Pointer)) {
    _cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
    rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
  }
  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
  free((void *) klass_name);
}

/* Create a new pointer object */
SWIGRUNTIME VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
{
  int own =  flags & SWIG_POINTER_OWN; 
  int track;
  char *klass_name;
  swig_class *sklass;
  VALUE klass;
  VALUE obj;
  
  if (!ptr)
    return Qnil;
  
  if (type->clientdata) {
    sklass = (swig_class *) type->clientdata;
		
    /* Are we tracking this class and have we already returned this Ruby object? */
    track = sklass->trackObjects;
    if (track) {
      obj = SWIG_RubyInstanceFor(ptr);
      
      /* Check the object's type and make sure it has the correct type.
        It might not in cases where methods do things like 
        downcast methods. */
      if (obj != Qnil) {
        VALUE value = rb_iv_get(obj, "@__swigtype__");
        char* type_name = RSTRING_PTR(value);
				
        if (strcmp(type->name, type_name) == 0) {
          return obj;
        }
      }
    }

    /* Create a new Ruby object */
    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), 
			   ( own ? VOIDFUNC(sklass->destroy) : 
			     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )
			     ), ptr);

    /* If tracking is on for this class then track this object. */
    if (track) {
      SWIG_RubyAddTracking(ptr, obj);
    }
  } else {
    klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
    free((void *) klass_name);
    obj = Data_Wrap_Struct(klass, 0, 0, ptr);
  }
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  
  return obj;
}

/* Create a new class instance (always owned) */
SWIGRUNTIME VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
  VALUE obj;
  swig_class *sklass = (swig_class *) type->clientdata;
  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  return obj;
}

/* Get type mangle from class name */
SWIGRUNTIMEINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "@__swigtype__");
  return StringValuePtr(stype);
}

/* Acquire a pointer value */
typedef void (*ruby_owntype)(void*);

SWIGRUNTIME ruby_owntype
SWIG_Ruby_AcquirePtr(VALUE obj, ruby_owntype own) {
  if (obj) {
    ruby_owntype oldown = RDATA(obj)->dfree;
    RDATA(obj)->dfree = own;
    return oldown;
  } else {
    return 0;
  }
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)
{
  char *c;
  swig_cast_info *tc;
  void *vptr = 0;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return SWIG_OK;
  } else {
    if (TYPE(obj) != T_DATA) {
      return SWIG_ERROR;
    }
    Data_Get_Struct(obj, void, vptr);
  }
  
  if (own) *own = RDATA(obj)->dfree;
    
  /* Check to see if the input object is giving up ownership
     of the underlying C struct or C++ object.  If so then we
     need to reset the destructor since the Ruby object no 
     longer owns the underlying C++ object.*/ 
  if (flags & SWIG_POINTER_DISOWN) {
    /* Is tracking on for this class? */
    int track = 0;
    if (ty && ty->clientdata) {
      swig_class *sklass = (swig_class *) ty->clientdata;
      track = sklass->trackObjects;
    }
		
    if (track) {
      /* We are tracking objects for this class.  Thus we change the destructor
       * to SWIG_RubyRemoveTracking.  This allows us to
       * remove the mapping from the C++ to Ruby object
       * when the Ruby object is garbage collected.  If we don't
       * do this, then it is possible we will return a reference 
       * to a Ruby object that no longer exists thereby crashing Ruby. */
      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;
    } else {    
      RDATA(obj)->dfree = 0;
    }
  }

  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
        if (vptr == 0) {
          /* The object has already been deleted */
          return SWIG_ObjectPreviouslyDeletedError;
        }
        *ptr = vptr;
        return SWIG_OK;
      }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      return SWIG_ERROR;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      return SWIG_ERROR;
    } else {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc, vptr, &newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    }
  } else {
    *ptr = vptr;
  }
  
  return SWIG_OK;
}

/* Check convert */
SWIGRUNTIMEINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c) return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

SWIGRUNTIME VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:
  return SWIG_ERROR;
}

SWIGRUNTIME swig_module_info *
SWIG_Ruby_GetModule(void)
{
  VALUE pointer;
  swig_module_info *ret = 0;
  VALUE verbose = rb_gv_get("VERBOSE");

 /* temporarily disable warnings, since the pointer check causes warnings with 'ruby -w' */
  rb_gv_set("VERBOSE", Qfalse);
  
  /* first check if pointer already created */
  pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  if (pointer != Qnil) {
    Data_Get_Struct(pointer, swig_module_info, ret);
  }

  /* reinstate warnings */
  rb_gv_set("VERBOSE", verbose);
  return ret;
}

SWIGRUNTIME void 
SWIG_Ruby_SetModule(swig_module_info *pointer)
{
  /* register a new class */
  VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
  /* create and store the structure pointer to a global variable */
  swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
  rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

/* This function can be used to check whether a proc or method or similarly
   callable function has been passed.  Usually used in a %typecheck, like:

   %typecheck(c_callback_t, precedence=SWIG_TYPECHECK_POINTER) {
        $result = SWIG_Ruby_isCallable( $input );
   }
 */
SWIGINTERN
int SWIG_Ruby_isCallable( VALUE proc )
{
  if ( rb_respond_to( proc, swig_call_id ) == Qtrue )
    return 1;
  return 0;
}

/* This function can be used to check the arity (number of arguments)
   a proc or method can take.  Usually used in a %typecheck.
   Valid arities will be that equal to minimal or those < 0
   which indicate a variable number of parameters at the end.
 */
SWIGINTERN
int SWIG_Ruby_arity( VALUE proc, int minimal )
{
  if ( rb_respond_to( proc, swig_arity_id ) == Qtrue )
    {
      VALUE num = rb_funcall( proc, swig_arity_id, 0 );
      int arity = NUM2INT(num);
      if ( arity < 0 && (arity+1) < -minimal ) return 1;
      if ( arity == minimal ) return 1;
      return 1;
    }
  return 0;
}


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg);; } while(0) 

/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * director.swg
 *
 * This file contains support for director classes that proxy
 * method calls from C++ to Ruby extensions.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_NOUEH if you prefer to avoid the use of the
  Undefined Exception Handler provided by swift
*/
#ifndef SWIG_DIRECTOR_NOUEH
#ifndef SWIG_DIRECTOR_UEH
#define SWIG_DIRECTOR_UEH
#endif
#endif

#ifdef __cplusplus

#include <string>
#include <iostream>
#include <map>

namespace Swig {
  /* memory handler */
  struct GCItem 
  {
    virtual ~GCItem()
    {
    }

    virtual ruby_owntype get_own() const
    {
      return 0;
    }
  };
  
  struct GCItem_var
  {
    GCItem_var(GCItem *item = 0) : _item(item)
    {
    }

    GCItem_var& operator=(GCItem *item)
    {
      GCItem *tmp = _item;
      _item = item;
      delete tmp;
      return *this;
    }
    
    ~GCItem_var() 
    {
      delete _item;
    }
    
    GCItem * operator->() const
    {
      return _item;
    }
    
  private:
    GCItem *_item;
  };


  template <typename Type>
  struct GCItem_T : GCItem
  {
    GCItem_T(Type *ptr) : _ptr(ptr)
    {
    }
    
    virtual ~GCItem_T() 
    {
      delete _ptr;
    }
    
  private:
    Type *_ptr;
  };

  struct GCItem_Object : GCItem
  {
    GCItem_Object(ruby_owntype own) : _own(own)
    {
    }
    
    virtual ~GCItem_Object() 
    {
    }

    ruby_owntype get_own() const
    {
      return _own;
    }
    
  private:
    ruby_owntype _own;
  };


  template <typename Type>
  struct GCArray_T : GCItem
  {
    GCArray_T(Type *ptr) : _ptr(ptr)
    {
    }
    
    virtual ~GCArray_T() 
    {
      delete[] _ptr;
    }
    
  private:
    Type *_ptr;
  };


  /* body args */
  struct body_args {
    VALUE recv;
    ID id;
    int argc;
    VALUE *argv;
  };
  
  /* Base class for director exceptions */
  class DirectorException {
  protected:
    VALUE swig_error;
    std::string swig_msg;
  protected:
    DirectorException(VALUE error)
      : swig_error(error)
    {
    }
    
    DirectorException(VALUE error, const char* hdr, const char* msg ="") 
      : swig_error(error), swig_msg(hdr) {
      if (strlen(msg)) {
	swig_msg += " ";
	swig_msg += msg;
      }
      if (swig_msg.size()) {
	VALUE str = rb_str_new(swig_msg.data(), swig_msg.size());
	swig_error = rb_exc_new3(error, str);
      } else {
	swig_error = error;
      }
    }
  public:
    VALUE getType() const  { 
      return CLASS_OF(swig_error); 
    }
    VALUE getError() const {
      return swig_error;
    }
    const std::string& getMessage() const 
    {
      return swig_msg;
    }
    
    virtual ~DirectorException() {}
  };
  
  /* unknown exception handler  */

  class UnknownExceptionHandler 
  {
#ifdef SWIG_DIRECTOR_UEH
    static void handler() {
      try {
	throw;
      } catch (DirectorException& e) {
	std::cerr << "Swig Director exception caught:" << std::endl
		  << e.getMessage() << std::endl;
      } catch (std::exception& e) {
	std::cerr << "std::exception caught: "<< e.what() << std::endl;
      } catch (...) {
	std::cerr << "Unknown exception caught." << std::endl;
      }      
      std::cerr << std::endl
		<< "Ruby interpreter traceback:" << std::endl;
      std::cerr << std::endl;      
      std::cerr << "This exception was caught by the SWIG unexpected exception handler." << std::endl
		<< "Try using %feature(\"director:except\") to avoid reaching this point." << std::endl
		<< std::endl
		<< "Exception is being re-thrown, program will like abort/terminate." << std::endl;
      throw;
    }
    
  public:    
    std::unexpected_handler old;
    UnknownExceptionHandler(std::unexpected_handler nh = handler)
    {
      old = std::set_unexpected(nh);
    }

    ~UnknownExceptionHandler()
    {
      std::set_unexpected(old);
    }
#endif
  };


  /* Type mismatch in the return value from a Ruby method call */
  class DirectorTypeMismatchException : public Swig::DirectorException {
  public:
    DirectorTypeMismatchException(VALUE error, const char *msg="")
      : Swig::DirectorException(error, "Swig director type mismatch", msg) 
    {
    }

    DirectorTypeMismatchException(const char *msg="")
      : Swig::DirectorException(rb_eTypeError, "Swig director type mismatch", msg) 
    {
    }

    static void raise(VALUE error, const char *msg) {
      throw DirectorTypeMismatchException(error, msg);
    }

    static void raise(const char *msg) {
      throw DirectorTypeMismatchException(msg);
    }
  };

  /* Any Ruby exception that occurs during a director method call */
  class DirectorMethodException : public Swig::DirectorException {
  public:
    DirectorMethodException(VALUE error) 
      : Swig::DirectorException(error) {
    }

    DirectorMethodException(const char* msg = "") 
      : Swig::DirectorException(rb_eRuntimeError, "Swig director method error.", msg) {
    }
    
    static void raise(VALUE error)
    {
      throw DirectorMethodException(error);
    }    
  };

  /* Attempted to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public Swig::DirectorException
  {
  public:
    DirectorPureVirtualException(const char* msg = "") 
      : DirectorException(rb_eRuntimeError, "Swig director pure virtual method called", msg)
    { 
    }

    static void raise(const char *msg) 
    {
      throw DirectorPureVirtualException(msg);
    }
  };

  /* Simple thread abstraction for pthreads on win32 */
#ifdef __THREAD__
# define __PTHREAD__
# if defined(_WIN32) || defined(__WIN32__)
#  define pthread_mutex_lock EnterCriticalSection
#  define pthread_mutex_unlock LeaveCriticalSection
#  define pthread_mutex_t CRITICAL_SECTION
#  define SWIG_MUTEX_INIT(var) var
# else
#  include <pthread.h>
#  define SWIG_MUTEX_INIT(var) var = PTHREAD_MUTEX_INITIALIZER 
# endif
#endif

#ifdef  __PTHREAD__
  struct Guard
  {
    pthread_mutex_t *_mutex;
    
    Guard(pthread_mutex_t &mutex) : _mutex(&mutex)
    {
      pthread_mutex_lock(_mutex);
    }
    
    ~Guard()
    {
      pthread_mutex_unlock(_mutex);
    }
  };
# define SWIG_GUARD(mutex) Guard _guard(mutex)
#else
# define SWIG_GUARD(mutex) 
#endif

  /* director base class */
  class Director {
  private:
    /* pointer to the wrapped Ruby object */
    VALUE swig_self;
    /* flag indicating whether the object is owned by Ruby or c++ */
    mutable bool swig_disown_flag;

  public:
    /* wrap a Ruby object, optionally taking ownership */
    Director(VALUE self) : swig_self(self), swig_disown_flag(false) {
    }

    /* discard our reference at destruction */
    virtual ~Director() {
    }

    /* return a pointer to the wrapped Ruby object */
    VALUE swig_get_self() const { 
      return swig_self; 
    }

    /* acquire ownership of the wrapped Ruby object (the sense of "disown"
     * is from Ruby) */
    void swig_disown() const { 
      if (!swig_disown_flag) { 
        swig_disown_flag = true;
      } 
    }

  /* ownership management */
  private:
    typedef std::map<void*, GCItem_var> ownership_map;
    mutable ownership_map owner;
#ifdef __PTHREAD__
    static pthread_mutex_t swig_mutex_own;
#endif

  public:
    template <typename Type>
    void swig_acquire_ownership_array(Type *vptr)  const
    {
      if (vptr) {
	SWIG_GUARD(swig_mutex_own);
	owner[vptr] = new GCArray_T<Type>(vptr);
      }
    }
    
    template <typename Type>
    void swig_acquire_ownership(Type *vptr)  const
    {
      if (vptr) {	
	SWIG_GUARD(swig_mutex_own);
	owner[vptr] = new GCItem_T<Type>(vptr);
      }
    }

    void swig_acquire_ownership_obj(void *vptr, ruby_owntype own) const
    {
      if (vptr && own) {
	SWIG_GUARD(swig_mutex_own);
	owner[vptr] = new GCItem_Object(own);
      }
    }
    
    ruby_owntype swig_release_ownership(void *vptr) const
    {
      ruby_owntype own = 0;
      if (vptr) {
	SWIG_GUARD(swig_mutex_own);
	ownership_map::iterator iter = owner.find(vptr);
	if (iter != owner.end()) {
	  own = iter->second->get_own();
	  owner.erase(iter);
	}
      }
      return own;
    }
  };
}

#endif /* __cplusplus */



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Application swig_types[0]
#define SWIGTYPE_p_BeginString swig_types[1]
#define SWIGTYPE_p_DOMDocumentPtr swig_types[2]
#define SWIGTYPE_p_Data swig_types[3]
#define SWIGTYPE_p_DataDictionary swig_types[4]
#define SWIGTYPE_p_Dictionaries swig_types[5]
#define SWIGTYPE_p_DoubleField swig_types[6]
#define SWIGTYPE_p_FIELD__Field swig_types[7]
#define SWIGTYPE_p_FIX_CHAR swig_types[8]
#define SWIGTYPE_p_FIX_DAYOFMONTH swig_types[9]
#define SWIGTYPE_p_FIX_INT swig_types[10]
#define SWIGTYPE_p_FIX_LOCALMKTDATE swig_types[11]
#define SWIGTYPE_p_FIX_PRICEOFFSET swig_types[12]
#define SWIGTYPE_p_FIX_QTY swig_types[13]
#define SWIGTYPE_p_FIX_STRING swig_types[14]
#define SWIGTYPE_p_FIX_UTCDATE swig_types[15]
#define SWIGTYPE_p_FIX_UTCTIMEONLY swig_types[16]
#define SWIGTYPE_p_FIX_UTCTIMESTAMP swig_types[17]
#define SWIGTYPE_p_FIX__Acceptor swig_types[18]
#define SWIGTYPE_p_FIX__AllocShares swig_types[19]
#define SWIGTYPE_p_FIX__Application swig_types[20]
#define SWIGTYPE_p_FIX__AvgPrxPrecision swig_types[21]
#define SWIGTYPE_p_FIX__Benchmark swig_types[22]
#define SWIGTYPE_p_FIX__BoolField swig_types[23]
#define SWIGTYPE_p_FIX__BrokerOfCredit swig_types[24]
#define SWIGTYPE_p_FIX__CardIssNo swig_types[25]
#define SWIGTYPE_p_FIX__CashSettlAgentAcctName swig_types[26]
#define SWIGTYPE_p_FIX__CashSettlAgentAcctNum swig_types[27]
#define SWIGTYPE_p_FIX__CashSettlAgentCode swig_types[28]
#define SWIGTYPE_p_FIX__CashSettlAgentContactName swig_types[29]
#define SWIGTYPE_p_FIX__CashSettlAgentContactPhone swig_types[30]
#define SWIGTYPE_p_FIX__CashSettlAgentName swig_types[31]
#define SWIGTYPE_p_FIX__CharField swig_types[32]
#define SWIGTYPE_p_FIX__CheckSumField swig_types[33]
#define SWIGTYPE_p_FIX__ClearingAccount swig_types[34]
#define SWIGTYPE_p_FIX__ClearingFirm swig_types[35]
#define SWIGTYPE_p_FIX__ClientID swig_types[36]
#define SWIGTYPE_p_FIX__ConfigError swig_types[37]
#define SWIGTYPE_p_FIX__CustomerOrFirm swig_types[38]
#define SWIGTYPE_p_FIX__CxlType swig_types[39]
#define SWIGTYPE_p_FIX__DataDictionary swig_types[40]
#define SWIGTYPE_p_FIX__Dictionary swig_types[41]
#define SWIGTYPE_p_FIX__Dictionary__Data__const_iterator swig_types[42]
#define SWIGTYPE_p_FIX__DiscretionOffset swig_types[43]
#define SWIGTYPE_p_FIX__DlvyInst swig_types[44]
#define SWIGTYPE_p_FIX__DoNotSend swig_types[45]
#define SWIGTYPE_p_FIX__DoubleField swig_types[46]
#define SWIGTYPE_p_FIX__DuplicateFieldNumber swig_types[47]
#define SWIGTYPE_p_FIX__Exception swig_types[48]
#define SWIGTYPE_p_FIX__ExecBroker swig_types[49]
#define SWIGTYPE_p_FIX__ExecTransType swig_types[50]
#define SWIGTYPE_p_FIX__FieldBase swig_types[51]
#define SWIGTYPE_p_FIX__FieldConvertError swig_types[52]
#define SWIGTYPE_p_FIX__FieldMap swig_types[53]
#define SWIGTYPE_p_FIX__FieldMap__Fields__const_iterator swig_types[54]
#define SWIGTYPE_p_FIX__FieldMap__Groups__const_iterator swig_types[55]
#define SWIGTYPE_p_FIX__FieldNotFound swig_types[56]
#define SWIGTYPE_p_FIX__FileLog swig_types[57]
#define SWIGTYPE_p_FIX__FileLogFactory swig_types[58]
#define SWIGTYPE_p_FIX__FileStore swig_types[59]
#define SWIGTYPE_p_FIX__FileStoreFactory swig_types[60]
#define SWIGTYPE_p_FIX__FutSettDate swig_types[61]
#define SWIGTYPE_p_FIX__FutSettDate2 swig_types[62]
#define SWIGTYPE_p_FIX__Group swig_types[63]
#define SWIGTYPE_p_FIX__IDSource swig_types[64]
#define SWIGTYPE_p_FIX__IOException swig_types[65]
#define SWIGTYPE_p_FIX__IOIOthSvc swig_types[66]
#define SWIGTYPE_p_FIX__IOIShares swig_types[67]
#define SWIGTYPE_p_FIX__IncorrectDataFormat swig_types[68]
#define SWIGTYPE_p_FIX__IncorrectMessageStructure swig_types[69]
#define SWIGTYPE_p_FIX__IncorrectTagValue swig_types[70]
#define SWIGTYPE_p_FIX__Initiator swig_types[71]
#define SWIGTYPE_p_FIX__IntField swig_types[72]
#define SWIGTYPE_p_FIX__InvalidMessage swig_types[73]
#define SWIGTYPE_p_FIX__InvalidMessageType swig_types[74]
#define SWIGTYPE_p_FIX__InvalidTagNumber swig_types[75]
#define SWIGTYPE_p_FIX__LastShares swig_types[76]
#define SWIGTYPE_p_FIX__LegFutSettDate swig_types[77]
#define SWIGTYPE_p_FIX__LegSettlmntTyp swig_types[78]
#define SWIGTYPE_p_FIX__Log swig_types[79]
#define SWIGTYPE_p_FIX__LogFactory swig_types[80]
#define SWIGTYPE_p_FIX__MaturityDay swig_types[81]
#define SWIGTYPE_p_FIX__MemoryStore swig_types[82]
#define SWIGTYPE_p_FIX__MemoryStoreFactory swig_types[83]
#define SWIGTYPE_p_FIX__Message swig_types[84]
#define SWIGTYPE_p_FIX__MessageParseError swig_types[85]
#define SWIGTYPE_p_FIX__MessageStore swig_types[86]
#define SWIGTYPE_p_FIX__MessageStoreExceptionWrapper swig_types[87]
#define SWIGTYPE_p_FIX__MessageStoreFactory swig_types[88]
#define SWIGTYPE_p_FIX__MessageStoreFactoryExceptionWrapper swig_types[89]
#define SWIGTYPE_p_FIX__NoTagValue swig_types[90]
#define SWIGTYPE_p_FIX__NullApplication swig_types[91]
#define SWIGTYPE_p_FIX__OnBehalfOfSendingTime swig_types[92]
#define SWIGTYPE_p_FIX__OpenClose swig_types[93]
#define SWIGTYPE_p_FIX__OpenCloseSettleFlag swig_types[94]
#define SWIGTYPE_p_FIX__PegDifference swig_types[95]
#define SWIGTYPE_p_FIX__PutOrCall swig_types[96]
#define SWIGTYPE_p_FIX__QuoteAckStatus swig_types[97]
#define SWIGTYPE_p_FIX__RatioQty swig_types[98]
#define SWIGTYPE_p_FIX__RegistDetls swig_types[99]
#define SWIGTYPE_p_FIX__RejectLogon swig_types[100]
#define SWIGTYPE_p_FIX__RelatdSym swig_types[101]
#define SWIGTYPE_p_FIX__RepeatedTag swig_types[102]
#define SWIGTYPE_p_FIX__RepeatingGroupCountMismatch swig_types[103]
#define SWIGTYPE_p_FIX__RequiredTagMissing swig_types[104]
#define SWIGTYPE_p_FIX__Rule80A swig_types[105]
#define SWIGTYPE_p_FIX__RuntimeError swig_types[106]
#define SWIGTYPE_p_FIX__ScreenLog swig_types[107]
#define SWIGTYPE_p_FIX__ScreenLogFactory swig_types[108]
#define SWIGTYPE_p_FIX__SecuritySettlAgentAcctName swig_types[109]
#define SWIGTYPE_p_FIX__SecuritySettlAgentAcctNum swig_types[110]
#define SWIGTYPE_p_FIX__SecuritySettlAgentCode swig_types[111]
#define SWIGTYPE_p_FIX__SecuritySettlAgentContactName swig_types[112]
#define SWIGTYPE_p_FIX__SecuritySettlAgentContactPhone swig_types[113]
#define SWIGTYPE_p_FIX__SecuritySettlAgentName swig_types[114]
#define SWIGTYPE_p_FIX__Session swig_types[115]
#define SWIGTYPE_p_FIX__SessionID swig_types[116]
#define SWIGTYPE_p_FIX__SessionNotFound swig_types[117]
#define SWIGTYPE_p_FIX__SessionSettings swig_types[118]
#define SWIGTYPE_p_FIX__SettlBrkrCode swig_types[119]
#define SWIGTYPE_p_FIX__SettlDepositoryCode swig_types[120]
#define SWIGTYPE_p_FIX__SettlInstCode swig_types[121]
#define SWIGTYPE_p_FIX__SettlLocation swig_types[122]
#define SWIGTYPE_p_FIX__SettlmntTyp swig_types[123]
#define SWIGTYPE_p_FIX__Shares swig_types[124]
#define SWIGTYPE_p_FIX__SocketAcceptor swig_types[125]
#define SWIGTYPE_p_FIX__SocketCloseFailed swig_types[126]
#define SWIGTYPE_p_FIX__SocketException swig_types[127]
#define SWIGTYPE_p_FIX__SocketInitiator swig_types[128]
#define SWIGTYPE_p_FIX__SocketRecvFailed swig_types[129]
#define SWIGTYPE_p_FIX__SocketSendFailed swig_types[130]
#define SWIGTYPE_p_FIX__SpreadToBenchmark swig_types[131]
#define SWIGTYPE_p_FIX__StringField swig_types[132]
#define SWIGTYPE_p_FIX__SynchronizedApplication swig_types[133]
#define SWIGTYPE_p_FIX__TagNotDefinedForMessage swig_types[134]
#define SWIGTYPE_p_FIX__TagOutOfOrder swig_types[135]
#define SWIGTYPE_p_FIX__TotQuoteEntries swig_types[136]
#define SWIGTYPE_p_FIX__TotalNumSecurities swig_types[137]
#define SWIGTYPE_p_FIX__TotalNumSecurityTypes swig_types[138]
#define SWIGTYPE_p_FIX__TotalVolumeTradedDate swig_types[139]
#define SWIGTYPE_p_FIX__TotalVolumeTradedTime swig_types[140]
#define SWIGTYPE_p_FIX__TradeType swig_types[141]
#define SWIGTYPE_p_FIX__UnderlyingIDSource swig_types[142]
#define SWIGTYPE_p_FIX__UnderlyingMaturityDay swig_types[143]
#define SWIGTYPE_p_FIX__UnderlyingPutOrCall swig_types[144]
#define SWIGTYPE_p_FIX__UnsupportedMessageType swig_types[145]
#define SWIGTYPE_p_FIX__UnsupportedVersion swig_types[146]
#define SWIGTYPE_p_FIX__UtcDateField swig_types[147]
#define SWIGTYPE_p_FIX__UtcTimeOnlyField swig_types[148]
#define SWIGTYPE_p_FIX__UtcTimeStampField swig_types[149]
#define SWIGTYPE_p_Fields swig_types[150]
#define SWIGTYPE_p_Group swig_types[151]
#define SWIGTYPE_p_Groups swig_types[152]
#define SWIGTYPE_p_IntArray swig_types[153]
#define SWIGTYPE_p_IntField swig_types[154]
#define SWIGTYPE_p_Log swig_types[155]
#define SWIGTYPE_p_LogFactory swig_types[156]
#define SWIGTYPE_p_MessageStore swig_types[157]
#define SWIGTYPE_p_MessageStoreFactory swig_types[158]
#define SWIGTYPE_p_MsgType swig_types[159]
#define SWIGTYPE_p_Mutex swig_types[160]
#define SWIGTYPE_p_Responder swig_types[161]
#define SWIGTYPE_p_SenderCompID swig_types[162]
#define SWIGTYPE_p_SessionID swig_types[163]
#define SWIGTYPE_p_SessionTime swig_types[164]
#define SWIGTYPE_p_StringField swig_types[165]
#define SWIGTYPE_p_TYPE__Type swig_types[166]
#define SWIGTYPE_p_TargetCompID swig_types[167]
#define SWIGTYPE_p_UtcDate swig_types[168]
#define SWIGTYPE_p_UtcDateField swig_types[169]
#define SWIGTYPE_p_UtcDateOnly swig_types[170]
#define SWIGTYPE_p_UtcTimeOnly swig_types[171]
#define SWIGTYPE_p_UtcTimeStamp swig_types[172]
#define SWIGTYPE_p_bool swig_types[173]
#define SWIGTYPE_p_char swig_types[174]
#define SWIGTYPE_p_const_iterator swig_types[175]
#define SWIGTYPE_p_double swig_types[176]
#define SWIGTYPE_p_g_const_iterator swig_types[177]
#define SWIGTYPE_p_g_iterator swig_types[178]
#define SWIGTYPE_p_int swig_types[179]
#define SWIGTYPE_p_iterator swig_types[180]
#define SWIGTYPE_p_message_order swig_types[181]
#define SWIGTYPE_p_p_FIX__DataDictionary swig_types[182]
#define SWIGTYPE_p_std__istream swig_types[183]
#define SWIGTYPE_p_std__ostream swig_types[184]
#define SWIGTYPE_p_std__setT_FIX__SessionID_t swig_types[185]
#define SWIGTYPE_p_std__string swig_types[186]
#define SWIGTYPE_p_std__string__size_type swig_types[187]
#define SWIGTYPE_p_std__vectorT_std__string_t swig_types[188]
static swig_type_info *swig_types[190];
static swig_module_info swig_module = {swig_types, 189, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_quickfix
#define SWIG_name    "Quickfix"

static VALUE mQuickfix;

#define SWIG_RUBY_THREAD_BEGIN_BLOCK
#define SWIG_RUBY_THREAD_END_BLOCK


#define SWIGVERSION 0x010335 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


#ifdef __cplusplus
extern "C" {
#endif
#include "rubyio.h"
#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
struct timeval rb_time_timeval(VALUE);
#endif
#ifdef __cplusplus
}
#endif


#include <string>


typedef int IntArray;


SWIGINTERN VALUE
SWIG_ruby_failed(void)
{
  return Qnil;
} 


/*@SWIG:C:\\swig\\Lib\\ruby\\rubyprimtypes.swg,23,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  unsigned long *res = (unsigned long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    unsigned long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERNINLINE int
SWIG_AsVal_size_t (VALUE obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  return res;
}

SWIGINTERN IntArray *new_IntArray(size_t nelements){
    return (new int[nelements]);
  }
SWIGINTERN int IntArray___getitem__(IntArray *self,size_t index){
    return self[index];
  }

#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


  #define SWIG_From_long   LONG2NUM 


SWIGINTERNINLINE VALUE
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


/*@SWIG:C:\\swig\\Lib\\ruby\\rubyprimtypes.swg,23,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  long *res = (long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_long (VALUE obj, long* val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (VALUE obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}

SWIGINTERN void IntArray___setitem__(IntArray *self,size_t index,int value){
    self[index] = value;
  }
SWIGINTERN int *IntArray_cast(IntArray *self){
    return self;
  }
SWIGINTERN IntArray *IntArray_frompointer(int *t){
    return static_cast< IntArray * >(t);
  }

//#include <config.h>
#include "../C++/Exceptions.h"
#include "../C++/Field.h"
#include "../C++/Message.h"
#include "../C++/Group.h"
#include "../C++/DeprecatedFields.h"
#include "../C++/Values.h"
#include "../C++/DeprecatedValues.h"
#include "../C++/SessionID.h"
#include "../C++/Dictionary.h"
#include "../C++/SessionSettings.h"
#include "../C++/Session.h"
#include "../C++/Log.h"
#include "../C++/FileLog.h"
#include "../C++/MessageStore.h"
#include "../C++/FileStore.h"
#include "../C++/Application.h"
#include "../C++/Initiator.h"
#include "../C++/SocketInitiator.h"
#include "../C++/Acceptor.h"
#include "../C++/SocketAcceptor.h"
#include "../C++/DataDictionary.h"
using namespace FIX;


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(VALUE obj, char** cptr, size_t* psize, int *alloc)
{
  if (TYPE(obj) == T_STRING) {
    #if defined(StringValuePtr)
    char *cstr = StringValuePtr(obj); 
    #else
    char *cstr = STR2CSTR(obj);
    #endif
    size_t size = RSTRING_LEN(obj) + 1;
    if (cptr)  {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = reinterpret_cast< char* >(memcpy((new char[size]), cstr, sizeof(char)*(size)));
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      }
    }
    if (psize) *psize = size;
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *)vptr;
	if (psize) *psize = vptr ? (strlen((char*)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }  
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsPtr_std_string (VALUE obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > LONG_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : Qnil;
    } else {
      return rb_str_new(carray, static_cast< long >(size));
    }
  } else {
    return Qnil;
  }
}


SWIGINTERNINLINE VALUE
SWIG_From_std_string  (const std::string& s)
{
  if (s.size()) {
    return SWIG_FromCharPtrAndSize(s.data(), s.size());
  } else {
    return SWIG_FromCharPtrAndSize(s.c_str(), 0);
  }
}

SWIGINTERN std::string FIX_Exception___str__(FIX::Exception *self){
    return self->what();
  }

SWIGINTERNINLINE VALUE
SWIG_From_bool  (bool value)
{
  return value ? Qtrue : Qfalse;
}

SWIGINTERN std::string FIX_FieldBase___str__(FIX::FieldBase *self){
    return self->getValue();
  }




SWIGINTERN int
SWIG_AsCharArray(VALUE obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (VALUE obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


/*@SWIG:C:\\swig\\Lib\\ruby\\rubyprimtypes.swg,23,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2DBL(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  double *res = (double *)(args[1]);
  *res = (type == T_FLOAT ? NUM2DBL(obj) : (type == T_FIXNUM ? (double) FIX2INT(obj) : rb_big2dbl(obj)));
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_double (VALUE obj, double *val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FLOAT) || (type == T_FIXNUM) || (type == T_BIGNUM)) {
    double v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2DBL), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


  #define SWIG_From_double   rb_float_new 


SWIGINTERN int
SWIG_AsVal_bool (VALUE obj, bool *val)
{
  if (obj == Qtrue) {
    if (val) *val = true;
    return SWIG_OK;
  } else if (obj == Qfalse) {
    if (val) *val = false;
    return SWIG_OK;
  } else {
    int res = 0;
    if (SWIG_AsVal_int (obj, &res) == SWIG_OK) {    
      if (val) *val = res ? true : false;
      return SWIG_OK;
    }
  }  
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (VALUE obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}

SWIGINTERN std::string FIX_Message___str__(FIX::Message *self){
    return self->toString();
  }

SWIGINTERNINLINE VALUE 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}

SWIGINTERN std::string FIX_SessionID___str__(FIX::SessionID *self){
    return self->toString();
  }
/* ---------------------------------------------------
 * C++ director class helpers
 * --------------------------------------------------- */

static int Application_onCreate_call_depth = 0;
VALUE Application_onCreate_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_onCreate_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_onCreate_call_depth--;
  return result;
}

VALUE Application_onCreate_rescue(VALUE args, VALUE error) {
  Application_onCreate_call_depth--;
  if (Application_onCreate_call_depth == 0) {
    if( error != 0 ) {
      VALUE message = rb_obj_as_string( error );
      printf( "%s\n", RSTRING(message)->ptr );
      exit(1);
    }
    
    
    
    
    
    
    
    
    
    
  }
  rb_exc_raise(error);
}

static int Application_onLogon_call_depth = 0;
VALUE Application_onLogon_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_onLogon_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_onLogon_call_depth--;
  return result;
}

VALUE Application_onLogon_rescue(VALUE args, VALUE error) {
  Application_onLogon_call_depth--;
  if (Application_onLogon_call_depth == 0) {
    if( error != 0 ) {
      VALUE message = rb_obj_as_string( error );
      printf( "%s\n", RSTRING(message)->ptr );
      exit(1);
    }
    
    
    
    
    
    
    
    
    
    
  }
  rb_exc_raise(error);
}

static int Application_onLogout_call_depth = 0;
VALUE Application_onLogout_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_onLogout_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_onLogout_call_depth--;
  return result;
}

VALUE Application_onLogout_rescue(VALUE args, VALUE error) {
  Application_onLogout_call_depth--;
  if (Application_onLogout_call_depth == 0) {
    if( error != 0 ) {
      VALUE message = rb_obj_as_string( error );
      printf( "%s\n", RSTRING(message)->ptr );
      exit(1);
    }
    
    
    
    
    
    
    
    
    
    
  }
  rb_exc_raise(error);
}

static int Application_toAdmin_call_depth = 0;
VALUE Application_toAdmin_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_toAdmin_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_toAdmin_call_depth--;
  return result;
}

VALUE Application_toAdmin_rescue(VALUE args, VALUE error) {
  Application_toAdmin_call_depth--;
  if (Application_toAdmin_call_depth == 0) {
    if( error != 0 ) {
      VALUE message = rb_obj_as_string( error );
      printf( "%s\n", RSTRING(message)->ptr );
      exit(1);
    }
    
    
    
    
    
    
    
    
    
    
  }
  rb_exc_raise(error);
}

static int Application_toApp_call_depth = 0;
VALUE Application_toApp_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_toApp_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_toApp_call_depth--;
  return result;
}

VALUE Application_toApp_rescue(VALUE args, VALUE error) {
  Application_toApp_call_depth--;
  if (Application_toApp_call_depth == 0) {
    if( error != 0 ) {
      void* result;
      
      Application_toApp_call_depth--;
      
      if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__DoNotSend, 0 ) != -1 ) {
        throw *((DoNotSend*)result);
      } else {
        VALUE message = rb_obj_as_string( error );
        printf( "%s\n", RSTRING(message)->ptr );
        exit(1);
      }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  }
  rb_exc_raise(error);
}

static int Application_fromAdmin_call_depth = 0;
VALUE Application_fromAdmin_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_fromAdmin_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_fromAdmin_call_depth--;
  return result;
}

VALUE Application_fromAdmin_rescue(VALUE args, VALUE error) {
  Application_fromAdmin_call_depth--;
  if (Application_fromAdmin_call_depth == 0) {
    if( error != 0 ) {
      void* result;
      
      Application_fromAdmin_call_depth--;
      
      if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__FieldNotFound, 0 ) != -1 ) {
        throw *((FieldNotFound*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__IncorrectDataFormat, 0 ) != -1 ) {
        throw *((IncorrectDataFormat*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__IncorrectTagValue, 0 ) != -1 ) {
        throw *((IncorrectTagValue*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__RejectLogon, 0 ) != -1 ) {
        throw *((RejectLogon*)result);
      } else {
        VALUE message = rb_obj_as_string( error );
        printf( "%s\n", RSTRING(message)->ptr );
        exit(1);
      }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  }
  rb_exc_raise(error);
}

static int Application_fromApp_call_depth = 0;
VALUE Application_fromApp_body(VALUE data) {
  Swig::body_args * args = reinterpret_cast<Swig::body_args *>(data) ;
  VALUE result = Qnil ;
  
  Application_fromApp_call_depth++;
  result = rb_funcall2(args->recv, args->id, args->argc, args->argv);
  Application_fromApp_call_depth--;
  return result;
}

VALUE Application_fromApp_rescue(VALUE args, VALUE error) {
  Application_fromApp_call_depth--;
  if (Application_fromApp_call_depth == 0) {
    if( error != 0 ) {
      void* result;
      
      Application_fromApp_call_depth--;
      
      if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__FieldNotFound, 0 ) != -1 ) {
        throw *((FieldNotFound*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__IncorrectDataFormat, 0 ) != -1 ) {
        throw *((IncorrectDataFormat*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__IncorrectTagValue, 0 ) != -1 ) {
        throw *((IncorrectTagValue*)result);
      } else if( SWIG_ConvertPtr(error, &result, SWIGTYPE_p_FIX__UnsupportedMessageType, 0 ) != -1 ) {
        throw *((UnsupportedMessageType*)result);
      } else {
        VALUE message = rb_obj_as_string( error );
        printf( "%s\n", RSTRING(message)->ptr );
        exit(1);
      }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  }
  rb_exc_raise(error);
}



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "QuickfixRuby.h"

SwigDirector_Application::SwigDirector_Application(VALUE self): FIX::Application(), Swig::Director(self) {
  
}



SwigDirector_Application::~SwigDirector_Application() {
}

void SwigDirector_Application::onCreate(FIX::SessionID const &arg0) {
  VALUE obj0 = Qnil ;
  VALUE result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("onCreate");
  args.argc = 1;
  args.argv = new VALUE[1];
  args.argv[0] = obj0;
  result = rb_protect(PROTECTFUNC(Application_onCreate_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_onCreate_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::onLogon(FIX::SessionID const &arg0) {
  VALUE obj0 = Qnil ;
  VALUE result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("onLogon");
  args.argc = 1;
  args.argv = new VALUE[1];
  args.argv[0] = obj0;
  result = rb_protect(PROTECTFUNC(Application_onLogon_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_onLogon_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::onLogout(FIX::SessionID const &arg0) {
  VALUE obj0 = Qnil ;
  VALUE result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("onLogout");
  args.argc = 1;
  args.argv = new VALUE[1];
  args.argv[0] = obj0;
  result = rb_protect(PROTECTFUNC(Application_onLogout_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_onLogout_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::toAdmin(FIX::Message &arg0, FIX::SessionID const &arg1) {
  VALUE obj0 = Qnil ;
  VALUE obj1 = Qnil ;
  VALUE result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__Message,  0 );
  obj1 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg1), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("toAdmin");
  args.argc = 2;
  args.argv = new VALUE[2];
  args.argv[0] = obj0;
  args.argv[1] = obj1;
  result = rb_protect(PROTECTFUNC(Application_toAdmin_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_toAdmin_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::toApp(FIX::Message &arg0, FIX::SessionID const &arg1) throw(FIX::DoNotSend) {
  VALUE obj0 = Qnil ;
  VALUE obj1 = Qnil ;
  VALUE result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__Message,  0 );
  obj1 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg1), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("toApp");
  args.argc = 2;
  args.argv = new VALUE[2];
  args.argv[0] = obj0;
  args.argv[1] = obj1;
  result = rb_protect(PROTECTFUNC(Application_toApp_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_toApp_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::fromAdmin(FIX::Message const &arg0, FIX::SessionID const &arg1) throw(FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, FIX::RejectLogon) {
  VALUE obj0 = Qnil ;
  VALUE obj1 = Qnil ;
  VALUE result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__Message,  0 );
  obj1 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg1), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("fromAdmin");
  args.argc = 2;
  args.argv = new VALUE[2];
  args.argv[0] = obj0;
  args.argv[1] = obj1;
  result = rb_protect(PROTECTFUNC(Application_fromAdmin_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_fromAdmin_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


void SwigDirector_Application::fromApp(FIX::Message const &arg0, FIX::SessionID const &arg1) throw(FIX::FieldNotFound, FIX::IncorrectDataFormat, FIX::IncorrectTagValue, FIX::UnsupportedMessageType) {
  VALUE obj0 = Qnil ;
  VALUE obj1 = Qnil ;
  VALUE result;
  Swig::body_args args ;
  int status ;
  
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_FIX__Message,  0 );
  obj1 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg1), SWIGTYPE_p_FIX__SessionID,  0 );
  args.recv = swig_get_self();
  args.id = rb_intern("fromApp");
  args.argc = 2;
  args.argv = new VALUE[2];
  args.argv[0] = obj0;
  args.argv[1] = obj1;
  result = rb_protect(PROTECTFUNC(Application_fromApp_body), reinterpret_cast<VALUE>(&args), &status);
  if (status) {
    VALUE lastErr = rb_gv_get("$!");
    Application_fromApp_rescue(reinterpret_cast<VALUE>(&args), lastErr);
  }
  delete [] args.argv;
}


swig_class cIntArray;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_IntArray_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_IntArray_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_IntArray);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_IntArray(int argc, VALUE *argv, VALUE self) {
  size_t arg1 ;
  IntArray *result = 0 ;
  size_t val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IntArray";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "size_t","IntArray", 1, argv[0] ));
  } 
  arg1 = static_cast< size_t >(val1);
  result = (IntArray *)new_IntArray(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void delete_IntArray(IntArray *self){
    delete[] self;
  }
SWIGINTERN void
free_IntArray(IntArray *arg1) {
    delete_IntArray(arg1);
}


/*
  Document-method: Quickfix::IntArray.[]

  call-seq:
    [](index) -> int

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_IntArray___getitem__(int argc, VALUE *argv, VALUE self) {
  IntArray *arg1 = (IntArray *) 0 ;
  size_t arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IntArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "IntArray *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< IntArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  result = (int)IntArray___getitem__(arg1,arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::IntArray.[]=

  call-seq:
    []=(index, value)

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_IntArray___setitem__(int argc, VALUE *argv, VALUE self) {
  IntArray *arg1 = (IntArray *) 0 ;
  size_t arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IntArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "IntArray *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< IntArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","__setitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","__setitem__", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  IntArray___setitem__(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IntArray_cast(int argc, VALUE *argv, VALUE self) {
  IntArray *arg1 = (IntArray *) 0 ;
  int *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IntArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "IntArray *","cast", 1, self )); 
  }
  arg1 = reinterpret_cast< IntArray * >(argp1);
  result = (int *)IntArray_cast(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IntArray_frompointer(int argc, VALUE *argv, VALUE self) {
  int *arg1 = (int *) 0 ;
  IntArray *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "int *","IntArray_frompointer", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< int * >(argp1);
  result = (IntArray *)IntArray_frompointer(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IntArray, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cException;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Exception_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Exception_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Exception);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Exception(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  FIX::Exception *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::Exception";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Exception", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Exception", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::Exception", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Exception", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::Exception *)new FIX::Exception((std::string const &)*arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN void
free_FIX_Exception(FIX::Exception *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Exception_type_set(int argc, VALUE *argv, VALUE self) {
  FIX::Exception *arg1 = (FIX::Exception *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Exception *","type", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Exception * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","type", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","type", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->type = *arg2;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Exception_type_get(int argc, VALUE *argv, VALUE self) {
  FIX::Exception *arg1 = (FIX::Exception *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Exception *","type", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Exception * >(argp1);
  {
    std::string const &_result_ref =  ((arg1)->type);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Exception_detail_set(int argc, VALUE *argv, VALUE self) {
  FIX::Exception *arg1 = (FIX::Exception *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Exception *","detail", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Exception * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","detail", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","detail", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->detail = *arg2;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Exception_detail_get(int argc, VALUE *argv, VALUE self) {
  FIX::Exception *arg1 = (FIX::Exception *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Exception *","detail", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Exception * >(argp1);
  {
    std::string const &_result_ref =  ((arg1)->detail);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Exception___str__(int argc, VALUE *argv, VALUE self) {
  FIX::Exception *arg1 = (FIX::Exception *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Exception *","__str__", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Exception * >(argp1);
  result = FIX_Exception___str__(arg1);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cFieldNotFound;

SWIGINTERN VALUE
_wrap_new_FieldNotFound__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::FieldNotFound *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FieldNotFound";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::FieldNotFound", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::FieldNotFound", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::FieldNotFound", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::FieldNotFound *)new FIX::FieldNotFound(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FieldNotFound__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::FieldNotFound *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldNotFound";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::FieldNotFound", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::FieldNotFound *)new FIX::FieldNotFound(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FieldNotFound_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FieldNotFound_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FieldNotFound);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FieldNotFound__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::FieldNotFound *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldNotFound";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::FieldNotFound *)new FIX::FieldNotFound();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FieldNotFound(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_FieldNotFound__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_FieldNotFound__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_FieldNotFound__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FieldNotFound.new", 
    "    FieldNotFound.new(int f, std::string const &what)\n"
    "    FieldNotFound.new(int f)\n"
    "    FieldNotFound.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldNotFound_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::FieldNotFound *arg1 = (FIX::FieldNotFound *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldNotFound, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldNotFound *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldNotFound * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldNotFound_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::FieldNotFound *arg1 = (FIX::FieldNotFound *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldNotFound, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldNotFound *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldNotFound * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_FieldNotFound(FIX::FieldNotFound *arg1) {
    delete arg1;
}

swig_class cFieldConvertError;

SWIGINTERN VALUE
_wrap_new_FieldConvertError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::FieldConvertError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FieldConvertError";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::FieldConvertError", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::FieldConvertError", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::FieldConvertError *)new FIX::FieldConvertError((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FieldConvertError_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FieldConvertError_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FieldConvertError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FieldConvertError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldConvertError *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldConvertError";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::FieldConvertError *)new FIX::FieldConvertError();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FieldConvertError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_FieldConvertError__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FieldConvertError__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "FieldConvertError.new", 
    "    FieldConvertError.new(std::string const &what)\n"
    "    FieldConvertError.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_FieldConvertError(FIX::FieldConvertError *arg1) {
    delete arg1;
}

swig_class cMessageParseError;

SWIGINTERN VALUE
_wrap_new_MessageParseError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::MessageParseError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::MessageParseError";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::MessageParseError", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::MessageParseError", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::MessageParseError *)new FIX::MessageParseError((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MessageParseError_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MessageParseError_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MessageParseError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MessageParseError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::MessageParseError *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MessageParseError";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::MessageParseError *)new FIX::MessageParseError();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_MessageParseError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_MessageParseError__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MessageParseError__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "MessageParseError.new", 
    "    MessageParseError.new(std::string const &what)\n"
    "    MessageParseError.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_MessageParseError(FIX::MessageParseError *arg1) {
    delete arg1;
}

swig_class cInvalidMessage;

SWIGINTERN VALUE
_wrap_new_InvalidMessage__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::InvalidMessage *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidMessage";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::InvalidMessage", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::InvalidMessage", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::InvalidMessage *)new FIX::InvalidMessage((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_InvalidMessage_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_InvalidMessage_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__InvalidMessage);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_InvalidMessage__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::InvalidMessage *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidMessage";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::InvalidMessage *)new FIX::InvalidMessage();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_InvalidMessage(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_InvalidMessage__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InvalidMessage__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "InvalidMessage.new", 
    "    InvalidMessage.new(std::string const &what)\n"
    "    InvalidMessage.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_InvalidMessage(FIX::InvalidMessage *arg1) {
    delete arg1;
}

swig_class cConfigError;

SWIGINTERN VALUE
_wrap_new_ConfigError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::ConfigError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::ConfigError";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::ConfigError", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::ConfigError", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::ConfigError *)new FIX::ConfigError((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ConfigError_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ConfigError_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ConfigError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ConfigError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::ConfigError *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ConfigError";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::ConfigError *)new FIX::ConfigError();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ConfigError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ConfigError__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ConfigError__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ConfigError.new", 
    "    ConfigError.new(std::string const &what)\n"
    "    ConfigError.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_ConfigError(FIX::ConfigError *arg1) {
    delete arg1;
}

swig_class cRuntimeError;

SWIGINTERN VALUE
_wrap_new_RuntimeError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::RuntimeError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::RuntimeError";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::RuntimeError", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::RuntimeError", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::RuntimeError *)new FIX::RuntimeError((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RuntimeError_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RuntimeError_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RuntimeError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RuntimeError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::RuntimeError *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RuntimeError";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::RuntimeError *)new FIX::RuntimeError();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RuntimeError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RuntimeError__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RuntimeError__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "RuntimeError.new", 
    "    RuntimeError.new(std::string const &what)\n"
    "    RuntimeError.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_RuntimeError(FIX::RuntimeError *arg1) {
    delete arg1;
}

swig_class cInvalidTagNumber;

SWIGINTERN VALUE
_wrap_new_InvalidTagNumber__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::InvalidTagNumber *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidTagNumber";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::InvalidTagNumber", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::InvalidTagNumber", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::InvalidTagNumber", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::InvalidTagNumber *)new FIX::InvalidTagNumber(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_InvalidTagNumber__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::InvalidTagNumber *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidTagNumber";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::InvalidTagNumber", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::InvalidTagNumber *)new FIX::InvalidTagNumber(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_InvalidTagNumber_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_InvalidTagNumber_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__InvalidTagNumber);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_InvalidTagNumber__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::InvalidTagNumber *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidTagNumber";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::InvalidTagNumber *)new FIX::InvalidTagNumber();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_InvalidTagNumber(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_InvalidTagNumber__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_InvalidTagNumber__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_InvalidTagNumber__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "InvalidTagNumber.new", 
    "    InvalidTagNumber.new(int f, std::string const &what)\n"
    "    InvalidTagNumber.new(int f)\n"
    "    InvalidTagNumber.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InvalidTagNumber_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::InvalidTagNumber *arg1 = (FIX::InvalidTagNumber *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__InvalidTagNumber, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::InvalidTagNumber *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::InvalidTagNumber * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InvalidTagNumber_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::InvalidTagNumber *arg1 = (FIX::InvalidTagNumber *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__InvalidTagNumber, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::InvalidTagNumber *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::InvalidTagNumber * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_InvalidTagNumber(FIX::InvalidTagNumber *arg1) {
    delete arg1;
}

swig_class cRequiredTagMissing;

SWIGINTERN VALUE
_wrap_new_RequiredTagMissing__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::RequiredTagMissing *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::RequiredTagMissing";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::RequiredTagMissing", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::RequiredTagMissing", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::RequiredTagMissing", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::RequiredTagMissing *)new FIX::RequiredTagMissing(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RequiredTagMissing__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::RequiredTagMissing *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RequiredTagMissing";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::RequiredTagMissing", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::RequiredTagMissing *)new FIX::RequiredTagMissing(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RequiredTagMissing_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RequiredTagMissing_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RequiredTagMissing);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RequiredTagMissing__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::RequiredTagMissing *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RequiredTagMissing";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::RequiredTagMissing *)new FIX::RequiredTagMissing();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RequiredTagMissing(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RequiredTagMissing__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_RequiredTagMissing__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RequiredTagMissing__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RequiredTagMissing.new", 
    "    RequiredTagMissing.new(int f, std::string const &what)\n"
    "    RequiredTagMissing.new(int f)\n"
    "    RequiredTagMissing.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RequiredTagMissing_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::RequiredTagMissing *arg1 = (FIX::RequiredTagMissing *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RequiredTagMissing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RequiredTagMissing *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RequiredTagMissing * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RequiredTagMissing_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::RequiredTagMissing *arg1 = (FIX::RequiredTagMissing *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RequiredTagMissing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RequiredTagMissing *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RequiredTagMissing * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_RequiredTagMissing(FIX::RequiredTagMissing *arg1) {
    delete arg1;
}

swig_class cTagNotDefinedForMessage;

SWIGINTERN VALUE
_wrap_new_TagNotDefinedForMessage__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::TagNotDefinedForMessage *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::TagNotDefinedForMessage";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::TagNotDefinedForMessage", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::TagNotDefinedForMessage", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::TagNotDefinedForMessage", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::TagNotDefinedForMessage *)new FIX::TagNotDefinedForMessage(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_TagNotDefinedForMessage__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::TagNotDefinedForMessage *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TagNotDefinedForMessage";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::TagNotDefinedForMessage", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::TagNotDefinedForMessage *)new FIX::TagNotDefinedForMessage(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_TagNotDefinedForMessage_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_TagNotDefinedForMessage_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TagNotDefinedForMessage);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_TagNotDefinedForMessage__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::TagNotDefinedForMessage *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TagNotDefinedForMessage";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::TagNotDefinedForMessage *)new FIX::TagNotDefinedForMessage();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TagNotDefinedForMessage(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TagNotDefinedForMessage__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_TagNotDefinedForMessage__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_TagNotDefinedForMessage__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "TagNotDefinedForMessage.new", 
    "    TagNotDefinedForMessage.new(int f, std::string const &what)\n"
    "    TagNotDefinedForMessage.new(int f)\n"
    "    TagNotDefinedForMessage.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TagNotDefinedForMessage_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::TagNotDefinedForMessage *arg1 = (FIX::TagNotDefinedForMessage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__TagNotDefinedForMessage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::TagNotDefinedForMessage *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::TagNotDefinedForMessage * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TagNotDefinedForMessage_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::TagNotDefinedForMessage *arg1 = (FIX::TagNotDefinedForMessage *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__TagNotDefinedForMessage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::TagNotDefinedForMessage *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::TagNotDefinedForMessage * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_TagNotDefinedForMessage(FIX::TagNotDefinedForMessage *arg1) {
    delete arg1;
}

swig_class cNoTagValue;

SWIGINTERN VALUE
_wrap_new_NoTagValue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::NoTagValue *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::NoTagValue";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::NoTagValue", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::NoTagValue", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::NoTagValue", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::NoTagValue *)new FIX::NoTagValue(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_NoTagValue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::NoTagValue *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::NoTagValue";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::NoTagValue", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::NoTagValue *)new FIX::NoTagValue(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_NoTagValue_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_NoTagValue_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__NoTagValue);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_NoTagValue__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::NoTagValue *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::NoTagValue";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::NoTagValue *)new FIX::NoTagValue();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_NoTagValue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_NoTagValue__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_NoTagValue__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_NoTagValue__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "NoTagValue.new", 
    "    NoTagValue.new(int f, std::string const &what)\n"
    "    NoTagValue.new(int f)\n"
    "    NoTagValue.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_NoTagValue_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::NoTagValue *arg1 = (FIX::NoTagValue *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__NoTagValue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::NoTagValue *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::NoTagValue * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_NoTagValue_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::NoTagValue *arg1 = (FIX::NoTagValue *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__NoTagValue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::NoTagValue *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::NoTagValue * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_NoTagValue(FIX::NoTagValue *arg1) {
    delete arg1;
}

swig_class cIncorrectTagValue;

SWIGINTERN VALUE
_wrap_new_IncorrectTagValue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::IncorrectTagValue *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectTagValue";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::IncorrectTagValue", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::IncorrectTagValue", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::IncorrectTagValue", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::IncorrectTagValue *)new FIX::IncorrectTagValue(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_IncorrectTagValue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::IncorrectTagValue *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectTagValue";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::IncorrectTagValue", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::IncorrectTagValue *)new FIX::IncorrectTagValue(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_IncorrectTagValue_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_IncorrectTagValue_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IncorrectTagValue);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_IncorrectTagValue__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectTagValue *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectTagValue";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::IncorrectTagValue *)new FIX::IncorrectTagValue();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IncorrectTagValue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IncorrectTagValue__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_IncorrectTagValue__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_IncorrectTagValue__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "IncorrectTagValue.new", 
    "    IncorrectTagValue.new(int f, std::string const &what)\n"
    "    IncorrectTagValue.new(int f)\n"
    "    IncorrectTagValue.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IncorrectTagValue_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectTagValue *arg1 = (FIX::IncorrectTagValue *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IncorrectTagValue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IncorrectTagValue *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IncorrectTagValue * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IncorrectTagValue_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectTagValue *arg1 = (FIX::IncorrectTagValue *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IncorrectTagValue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IncorrectTagValue *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IncorrectTagValue * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_IncorrectTagValue(FIX::IncorrectTagValue *arg1) {
    delete arg1;
}

swig_class cIncorrectDataFormat;

SWIGINTERN VALUE
_wrap_new_IncorrectDataFormat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::IncorrectDataFormat *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectDataFormat";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::IncorrectDataFormat", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::IncorrectDataFormat", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::IncorrectDataFormat", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::IncorrectDataFormat *)new FIX::IncorrectDataFormat(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_IncorrectDataFormat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::IncorrectDataFormat *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectDataFormat";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::IncorrectDataFormat", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::IncorrectDataFormat *)new FIX::IncorrectDataFormat(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_IncorrectDataFormat_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_IncorrectDataFormat_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IncorrectDataFormat);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_IncorrectDataFormat__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectDataFormat *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectDataFormat";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::IncorrectDataFormat *)new FIX::IncorrectDataFormat();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IncorrectDataFormat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IncorrectDataFormat__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_IncorrectDataFormat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_IncorrectDataFormat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "IncorrectDataFormat.new", 
    "    IncorrectDataFormat.new(int f, std::string const &what)\n"
    "    IncorrectDataFormat.new(int f)\n"
    "    IncorrectDataFormat.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IncorrectDataFormat_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectDataFormat *arg1 = (FIX::IncorrectDataFormat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IncorrectDataFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IncorrectDataFormat *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IncorrectDataFormat * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IncorrectDataFormat_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectDataFormat *arg1 = (FIX::IncorrectDataFormat *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IncorrectDataFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IncorrectDataFormat *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IncorrectDataFormat * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_IncorrectDataFormat(FIX::IncorrectDataFormat *arg1) {
    delete arg1;
}

swig_class cIncorrectMessageStructure;

SWIGINTERN VALUE
_wrap_new_IncorrectMessageStructure__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::IncorrectMessageStructure *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectMessageStructure";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::IncorrectMessageStructure", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::IncorrectMessageStructure", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::IncorrectMessageStructure *)new FIX::IncorrectMessageStructure((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_IncorrectMessageStructure_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_IncorrectMessageStructure_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IncorrectMessageStructure);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_IncorrectMessageStructure__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::IncorrectMessageStructure *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IncorrectMessageStructure";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::IncorrectMessageStructure *)new FIX::IncorrectMessageStructure();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IncorrectMessageStructure(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IncorrectMessageStructure__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_IncorrectMessageStructure__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "IncorrectMessageStructure.new", 
    "    IncorrectMessageStructure.new(std::string const &what)\n"
    "    IncorrectMessageStructure.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_IncorrectMessageStructure(FIX::IncorrectMessageStructure *arg1) {
    delete arg1;
}

swig_class cDuplicateFieldNumber;

SWIGINTERN VALUE
_wrap_new_DuplicateFieldNumber__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::DuplicateFieldNumber *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::DuplicateFieldNumber";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::DuplicateFieldNumber", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::DuplicateFieldNumber", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::DuplicateFieldNumber *)new FIX::DuplicateFieldNumber((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DuplicateFieldNumber_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DuplicateFieldNumber_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DuplicateFieldNumber);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DuplicateFieldNumber__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DuplicateFieldNumber *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DuplicateFieldNumber";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::DuplicateFieldNumber *)new FIX::DuplicateFieldNumber();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DuplicateFieldNumber(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_DuplicateFieldNumber__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DuplicateFieldNumber__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "DuplicateFieldNumber.new", 
    "    DuplicateFieldNumber.new(std::string const &what)\n"
    "    DuplicateFieldNumber.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_DuplicateFieldNumber(FIX::DuplicateFieldNumber *arg1) {
    delete arg1;
}

swig_class cInvalidMessageType;

SWIGINTERN VALUE
_wrap_new_InvalidMessageType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::InvalidMessageType *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidMessageType";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::InvalidMessageType", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::InvalidMessageType", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::InvalidMessageType *)new FIX::InvalidMessageType((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_InvalidMessageType_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_InvalidMessageType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__InvalidMessageType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_InvalidMessageType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::InvalidMessageType *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::InvalidMessageType";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::InvalidMessageType *)new FIX::InvalidMessageType();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_InvalidMessageType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_InvalidMessageType__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InvalidMessageType__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "InvalidMessageType.new", 
    "    InvalidMessageType.new(std::string const &what)\n"
    "    InvalidMessageType.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_InvalidMessageType(FIX::InvalidMessageType *arg1) {
    delete arg1;
}

swig_class cUnsupportedMessageType;

SWIGINTERN VALUE
_wrap_new_UnsupportedMessageType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::UnsupportedMessageType *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::UnsupportedMessageType";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::UnsupportedMessageType", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::UnsupportedMessageType", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::UnsupportedMessageType *)new FIX::UnsupportedMessageType((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_UnsupportedMessageType_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_UnsupportedMessageType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UnsupportedMessageType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_UnsupportedMessageType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::UnsupportedMessageType *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UnsupportedMessageType";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::UnsupportedMessageType *)new FIX::UnsupportedMessageType();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UnsupportedMessageType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_UnsupportedMessageType__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnsupportedMessageType__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "UnsupportedMessageType.new", 
    "    UnsupportedMessageType.new(std::string const &what)\n"
    "    UnsupportedMessageType.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_UnsupportedMessageType(FIX::UnsupportedMessageType *arg1) {
    delete arg1;
}

swig_class cUnsupportedVersion;

SWIGINTERN VALUE
_wrap_new_UnsupportedVersion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::UnsupportedVersion *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::UnsupportedVersion";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::UnsupportedVersion", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::UnsupportedVersion", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::UnsupportedVersion *)new FIX::UnsupportedVersion((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_UnsupportedVersion_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_UnsupportedVersion_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UnsupportedVersion);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_UnsupportedVersion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::UnsupportedVersion *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UnsupportedVersion";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::UnsupportedVersion *)new FIX::UnsupportedVersion();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UnsupportedVersion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_UnsupportedVersion__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnsupportedVersion__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "UnsupportedVersion.new", 
    "    UnsupportedVersion.new(std::string const &what)\n"
    "    UnsupportedVersion.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_UnsupportedVersion(FIX::UnsupportedVersion *arg1) {
    delete arg1;
}

swig_class cTagOutOfOrder;

SWIGINTERN VALUE
_wrap_new_TagOutOfOrder__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::TagOutOfOrder *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::TagOutOfOrder";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::TagOutOfOrder", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::TagOutOfOrder", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::TagOutOfOrder", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::TagOutOfOrder *)new FIX::TagOutOfOrder(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_TagOutOfOrder__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::TagOutOfOrder *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TagOutOfOrder";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::TagOutOfOrder", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::TagOutOfOrder *)new FIX::TagOutOfOrder(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_TagOutOfOrder_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_TagOutOfOrder_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TagOutOfOrder);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_TagOutOfOrder__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::TagOutOfOrder *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TagOutOfOrder";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::TagOutOfOrder *)new FIX::TagOutOfOrder();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TagOutOfOrder(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TagOutOfOrder__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_TagOutOfOrder__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_TagOutOfOrder__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "TagOutOfOrder.new", 
    "    TagOutOfOrder.new(int f, std::string const &what)\n"
    "    TagOutOfOrder.new(int f)\n"
    "    TagOutOfOrder.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TagOutOfOrder_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::TagOutOfOrder *arg1 = (FIX::TagOutOfOrder *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__TagOutOfOrder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::TagOutOfOrder *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::TagOutOfOrder * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TagOutOfOrder_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::TagOutOfOrder *arg1 = (FIX::TagOutOfOrder *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__TagOutOfOrder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::TagOutOfOrder *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::TagOutOfOrder * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_TagOutOfOrder(FIX::TagOutOfOrder *arg1) {
    delete arg1;
}

swig_class cRepeatedTag;

SWIGINTERN VALUE
_wrap_new_RepeatedTag__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::RepeatedTag *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::RepeatedTag";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::RepeatedTag", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::RepeatedTag", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::RepeatedTag", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::RepeatedTag *)new FIX::RepeatedTag(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RepeatedTag__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::RepeatedTag *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RepeatedTag";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::RepeatedTag", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::RepeatedTag *)new FIX::RepeatedTag(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RepeatedTag_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RepeatedTag_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RepeatedTag);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RepeatedTag__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::RepeatedTag *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RepeatedTag";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::RepeatedTag *)new FIX::RepeatedTag();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RepeatedTag(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RepeatedTag__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_RepeatedTag__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RepeatedTag__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RepeatedTag.new", 
    "    RepeatedTag.new(int f, std::string const &what)\n"
    "    RepeatedTag.new(int f)\n"
    "    RepeatedTag.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RepeatedTag_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::RepeatedTag *arg1 = (FIX::RepeatedTag *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RepeatedTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RepeatedTag *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RepeatedTag * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RepeatedTag_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::RepeatedTag *arg1 = (FIX::RepeatedTag *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RepeatedTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RepeatedTag *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RepeatedTag * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_RepeatedTag(FIX::RepeatedTag *arg1) {
    delete arg1;
}

swig_class cRepeatingGroupCountMismatch;

SWIGINTERN VALUE
_wrap_new_RepeatingGroupCountMismatch__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::RepeatingGroupCountMismatch *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::RepeatingGroupCountMismatch";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::RepeatingGroupCountMismatch", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::RepeatingGroupCountMismatch", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::RepeatingGroupCountMismatch", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::RepeatingGroupCountMismatch *)new FIX::RepeatingGroupCountMismatch(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RepeatingGroupCountMismatch__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::RepeatingGroupCountMismatch *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RepeatingGroupCountMismatch";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::RepeatingGroupCountMismatch", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::RepeatingGroupCountMismatch *)new FIX::RepeatingGroupCountMismatch(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RepeatingGroupCountMismatch_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RepeatingGroupCountMismatch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RepeatingGroupCountMismatch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RepeatingGroupCountMismatch__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::RepeatingGroupCountMismatch *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RepeatingGroupCountMismatch";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::RepeatingGroupCountMismatch *)new FIX::RepeatingGroupCountMismatch();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RepeatingGroupCountMismatch(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RepeatingGroupCountMismatch__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_RepeatingGroupCountMismatch__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RepeatingGroupCountMismatch__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RepeatingGroupCountMismatch.new", 
    "    RepeatingGroupCountMismatch.new(int f, std::string const &what)\n"
    "    RepeatingGroupCountMismatch.new(int f)\n"
    "    RepeatingGroupCountMismatch.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RepeatingGroupCountMismatch_field_set(int argc, VALUE *argv, VALUE self) {
  FIX::RepeatingGroupCountMismatch *arg1 = (FIX::RepeatingGroupCountMismatch *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RepeatingGroupCountMismatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RepeatingGroupCountMismatch *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RepeatingGroupCountMismatch * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","field", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->field = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RepeatingGroupCountMismatch_field_get(int argc, VALUE *argv, VALUE self) {
  FIX::RepeatingGroupCountMismatch *arg1 = (FIX::RepeatingGroupCountMismatch *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__RepeatingGroupCountMismatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::RepeatingGroupCountMismatch *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::RepeatingGroupCountMismatch * >(argp1);
  result = (int) ((arg1)->field);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_RepeatingGroupCountMismatch(FIX::RepeatingGroupCountMismatch *arg1) {
    delete arg1;
}

swig_class cDoNotSend;

SWIGINTERN VALUE
_wrap_new_DoNotSend__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::DoNotSend *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::DoNotSend";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::DoNotSend", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::DoNotSend", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::DoNotSend *)new FIX::DoNotSend((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DoNotSend_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DoNotSend_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DoNotSend);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DoNotSend__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DoNotSend *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DoNotSend";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::DoNotSend *)new FIX::DoNotSend();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DoNotSend(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_DoNotSend__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DoNotSend__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "DoNotSend.new", 
    "    DoNotSend.new(std::string const &what)\n"
    "    DoNotSend.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_DoNotSend(FIX::DoNotSend *arg1) {
    delete arg1;
}

swig_class cRejectLogon;

SWIGINTERN VALUE
_wrap_new_RejectLogon__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::RejectLogon *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::RejectLogon";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::RejectLogon", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::RejectLogon", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::RejectLogon *)new FIX::RejectLogon((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RejectLogon_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RejectLogon_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RejectLogon);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RejectLogon__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::RejectLogon *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RejectLogon";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::RejectLogon *)new FIX::RejectLogon();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RejectLogon(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RejectLogon__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RejectLogon__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "RejectLogon.new", 
    "    RejectLogon.new(std::string const &what)\n"
    "    RejectLogon.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_RejectLogon(FIX::RejectLogon *arg1) {
    delete arg1;
}

swig_class cSessionNotFound;

SWIGINTERN VALUE
_wrap_new_SessionNotFound__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::SessionNotFound *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SessionNotFound";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::SessionNotFound", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SessionNotFound", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::SessionNotFound *)new FIX::SessionNotFound((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SessionNotFound_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SessionNotFound_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SessionNotFound);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SessionNotFound__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::SessionNotFound *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SessionNotFound";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SessionNotFound *)new FIX::SessionNotFound();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SessionNotFound(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SessionNotFound__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SessionNotFound__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SessionNotFound.new", 
    "    SessionNotFound.new(std::string const &what)\n"
    "    SessionNotFound.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SessionNotFound(FIX::SessionNotFound *arg1) {
    delete arg1;
}

swig_class cIOException;

SWIGINTERN VALUE
_wrap_new_IOException__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::IOException *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::IOException";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::IOException", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::IOException", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::IOException *)new FIX::IOException((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_IOException_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_IOException_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IOException);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_IOException__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::IOException *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IOException";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::IOException *)new FIX::IOException();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IOException(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IOException__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_IOException__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "IOException.new", 
    "    IOException.new(std::string const &what)\n"
    "    IOException.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_IOException(FIX::IOException *arg1) {
    delete arg1;
}

swig_class cSocketException;

SWIGINTERN VALUE
_wrap_new_SocketException__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SocketException *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketException";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SocketException *)new FIX::SocketException();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SocketException_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SocketException_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketException);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SocketException__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::SocketException *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SocketException";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::SocketException", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SocketException", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::SocketException *)new FIX::SocketException((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketException(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SocketException__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SocketException__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SocketException.new", 
    "    SocketException.new()\n"
    "    SocketException.new(std::string const &what)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SocketException_errorToWhat(int argc, VALUE *argv, VALUE self) {
  FIX::SocketException *arg1 = (FIX::SocketException *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SocketException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SocketException *","errorToWhat", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SocketException * >(argp1);
  result = (arg1)->errorToWhat();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SocketException_error_set(int argc, VALUE *argv, VALUE self) {
  FIX::SocketException *arg1 = (FIX::SocketException *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SocketException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SocketException *","error", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SocketException * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","error", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->error = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SocketException_error_get(int argc, VALUE *argv, VALUE self) {
  FIX::SocketException *arg1 = (FIX::SocketException *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SocketException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SocketException *","error", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SocketException * >(argp1);
  result = (int) ((arg1)->error);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketException(FIX::SocketException *arg1) {
    delete arg1;
}

swig_class cSocketSendFailed;

SWIGINTERN VALUE
_wrap_new_SocketSendFailed__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SocketSendFailed *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketSendFailed";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SocketSendFailed *)new FIX::SocketSendFailed();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SocketSendFailed_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SocketSendFailed_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketSendFailed);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SocketSendFailed__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::SocketSendFailed *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SocketSendFailed";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::SocketSendFailed", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SocketSendFailed", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::SocketSendFailed *)new FIX::SocketSendFailed((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketSendFailed(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SocketSendFailed__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SocketSendFailed__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SocketSendFailed.new", 
    "    SocketSendFailed.new()\n"
    "    SocketSendFailed.new(std::string const &what)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketSendFailed(FIX::SocketSendFailed *arg1) {
    delete arg1;
}

swig_class cSocketRecvFailed;

SWIGINTERN VALUE
_wrap_new_SocketRecvFailed__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::SocketRecvFailed *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketRecvFailed";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::SocketRecvFailed", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::SocketRecvFailed *)new FIX::SocketRecvFailed(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SocketRecvFailed_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SocketRecvFailed_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketRecvFailed);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SocketRecvFailed__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::SocketRecvFailed *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SocketRecvFailed";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::SocketRecvFailed", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SocketRecvFailed", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::SocketRecvFailed *)new FIX::SocketRecvFailed((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketRecvFailed(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SocketRecvFailed__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SocketRecvFailed__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SocketRecvFailed.new", 
    "    SocketRecvFailed.new(int size)\n"
    "    SocketRecvFailed.new(std::string const &what)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketRecvFailed(FIX::SocketRecvFailed *arg1) {
    delete arg1;
}

swig_class cSocketCloseFailed;

SWIGINTERN VALUE
_wrap_new_SocketCloseFailed__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SocketCloseFailed *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketCloseFailed";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SocketCloseFailed *)new FIX::SocketCloseFailed();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SocketCloseFailed_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SocketCloseFailed_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketCloseFailed);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SocketCloseFailed__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::SocketCloseFailed *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SocketCloseFailed";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::SocketCloseFailed", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SocketCloseFailed", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::SocketCloseFailed *)new FIX::SocketCloseFailed((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketCloseFailed(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SocketCloseFailed__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SocketCloseFailed__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SocketCloseFailed.new", 
    "    SocketCloseFailed.new()\n"
    "    SocketCloseFailed.new(std::string const &what)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketCloseFailed(FIX::SocketCloseFailed *arg1) {
    delete arg1;
}

swig_class cFieldBase;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FieldBase_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FieldBase_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FieldBase);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FieldBase(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::FieldBase *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FieldBase";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::FieldBase", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::FieldBase", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::FieldBase", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::FieldBase *)new FIX::FieldBase(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN void
free_FIX_FieldBase(FIX::FieldBase *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FieldBase_setField(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase *","setField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->setField(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_setString(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->setString((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getField(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  result = (int)((FIX::FieldBase const *)arg1)->getField();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getString(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    std::string const &_result_ref = ((FIX::FieldBase const *)arg1)->getString();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  {
    std::string const &_result_ref = ((FIX::FieldBase const *)arg1)->getValue();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getLength(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  result = (int)((FIX::FieldBase const *)arg1)->getLength();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase_getTotal(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","getTotal", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  result = (int)((FIX::FieldBase const *)arg1)->getTotal();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::FieldBase.<

  call-seq:
    <(field) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_FieldBase___lt__(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  result = (bool)((FIX::FieldBase const *)arg1)->operator <((FIX::FieldBase const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldBase___str__(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = (FIX::FieldBase *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase *","__str__", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  result = FIX_FieldBase___str__(arg1);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.<<

  call-seq:
    <<(stream, field) -> std::ostream
    <<(stream, message) -> std::ostream
    <<(stream, sessionID) -> std::ostream
    <<(?, ?) -> std::ostream

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  FIX::FieldBase *arg2 = 0 ;
  std::ostream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","FIX::operator <<", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","FIX::operator <<", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FIX::operator <<", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FIX::operator <<", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  {
    std::ostream &_result_ref = FIX::operator <<(*arg1,(FIX::FieldBase const &)*arg2);
    result = (std::ostream *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cStringField;

SWIGINTERN VALUE
_wrap_new_StringField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  FIX::StringField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::StringField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::StringField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::StringField", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::StringField", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (FIX::StringField *)new FIX::StringField(arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_StringField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_StringField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__StringField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_StringField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::StringField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::StringField";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::StringField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::StringField *)new FIX::StringField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_StringField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_StringField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_StringField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "StringField.new", 
    "    StringField.new(int field, std::string const &data)\n"
    "    StringField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setValue", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setValue", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->setValue((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string const &_result_ref = ((FIX::StringField const *)arg1)->getValue();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::StringField.<

  call-seq:
    <(rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_StringField___lt__(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)((FIX::StringField const *)arg1)->operator <((FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::StringField.>

  call-seq:
    >(rhs) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap_StringField___gt__(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","operator >", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","operator >", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","operator >", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)((FIX::StringField const *)arg1)->operator >((FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::StringField.==

  call-seq:
    ==(rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_StringField___eq__(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)((FIX::StringField const *)arg1)->operator ==((FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::StringField.<=

  call-seq:
    <=(rhs) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_StringField___le__(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","operator <=", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","operator <=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","operator <=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)((FIX::StringField const *)arg1)->operator <=((FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::StringField.>=

  call-seq:
    >=(rhs) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_StringField___ge__(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = (FIX::StringField *) 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__StringField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const *","operator >=", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","operator >=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","operator >=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)((FIX::StringField const *)arg1)->operator >=((FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_StringField(FIX::StringField *arg1) {
    delete arg1;
}


/*
  Document-method: Quickfix::FIX.<

  call-seq:
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap___lt____SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","FIX::operator <", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)FIX::operator <((FIX::StringField const &)*arg1,(char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___lt____SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","FIX::operator <", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)FIX::operator <((char const *)arg1,(FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.>

  call-seq:
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap___gt____SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","FIX::operator >", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)FIX::operator >((FIX::StringField const &)*arg1,(char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___gt____SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","FIX::operator >", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)FIX::operator >((char const *)arg1,(FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.==

  call-seq:
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap___eq____SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator ==", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator ==", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","FIX::operator ==", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)FIX::operator ==((FIX::StringField const &)*arg1,(char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___eq____SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","FIX::operator ==", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator ==", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator ==", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)FIX::operator ==((char const *)arg1,(FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.<=

  call-seq:
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap___le____SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <=", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <=", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","FIX::operator <=", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)FIX::operator <=((FIX::StringField const &)*arg1,(char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___le____SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","FIX::operator <=", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <=", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <=", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)FIX::operator <=((char const *)arg1,(FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.>=

  call-seq:
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap___ge____SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >=", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >=", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","FIX::operator >=", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)FIX::operator >=((FIX::StringField const &)*arg1,(char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___ge____SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","FIX::operator >=", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >=", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >=", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)FIX::operator >=((char const *)arg1,(FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.<

  call-seq:
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap___lt____SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::operator <", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator <", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (bool)FIX::operator <((FIX::StringField const &)*arg1,(std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___lt____SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::operator <", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator <", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)FIX::operator <((std::string const &)*arg1,(FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.>

  call-seq:
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool
    >(lhs, rhs) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap___gt____SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::operator >", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator >", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (bool)FIX::operator >((FIX::StringField const &)*arg1,(std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___gt____SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::operator >", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator >", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)FIX::operator >((std::string const &)*arg1,(FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap___gt__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___gt____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___gt____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___gt____SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___gt____SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__gt__", 
    "    bool __gt__(FIX::StringField const &lhs, char const *rhs)\n"
    "    bool __gt__(char const *lhs, FIX::StringField const &rhs)\n"
    "    bool __gt__(FIX::StringField const &lhs, std::string const &rhs)\n"
    "    bool __gt__(std::string const &lhs, FIX::StringField const &rhs)\n");
  
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.==

  call-seq:
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap___eq____SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator ==", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator ==", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::operator ==", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator ==", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (bool)FIX::operator ==((FIX::StringField const &)*arg1,(std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___eq____SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::operator ==", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator ==", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator ==", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator ==", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)FIX::operator ==((std::string const &)*arg1,(FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.<=

  call-seq:
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool
    <=(lhs, rhs) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap___le____SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <=", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <=", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::operator <=", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator <=", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (bool)FIX::operator <=((FIX::StringField const &)*arg1,(std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___le____SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::operator <=", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator <=", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator <=", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator <=", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)FIX::operator <=((std::string const &)*arg1,(FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap___le__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___le____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___le____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___le____SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___le____SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__le__", 
    "    bool __le__(FIX::StringField const &lhs, char const *rhs)\n"
    "    bool __le__(char const *lhs, FIX::StringField const &rhs)\n"
    "    bool __le__(FIX::StringField const &lhs, std::string const &rhs)\n"
    "    bool __le__(std::string const &lhs, FIX::StringField const &rhs)\n");
  
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.>=

  call-seq:
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool
    >=(lhs, rhs) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap___ge____SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::StringField *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >=", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >=", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::StringField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::operator >=", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator >=", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  result = (bool)FIX::operator >=((FIX::StringField const &)*arg1,(std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap___ge____SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::StringField *arg2 = 0 ;
  bool result;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::operator >=", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::operator >=", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__StringField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::StringField const &","FIX::operator >=", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::StringField const &","FIX::operator >=", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::StringField * >(argp2);
  result = (bool)FIX::operator >=((std::string const &)*arg1,(FIX::StringField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap___ge__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___ge____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___ge____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___ge____SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___ge____SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__ge__", 
    "    bool __ge__(FIX::StringField const &lhs, char const *rhs)\n"
    "    bool __ge__(char const *lhs, FIX::StringField const &rhs)\n"
    "    bool __ge__(FIX::StringField const &lhs, std::string const &rhs)\n"
    "    bool __ge__(std::string const &lhs, FIX::StringField const &rhs)\n");
  
  return Qnil;
}


swig_class cCharField;

SWIGINTERN VALUE
_wrap_new_CharField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  char arg2 ;
  FIX::CharField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CharField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::CharField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","FIX::CharField", 2, argv[1] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (FIX::CharField *)new FIX::CharField(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CharField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CharField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CharField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CharField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::CharField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CharField";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::CharField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::CharField *)new FIX::CharField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CharField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_CharField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_CharField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "CharField.new", 
    "    CharField.new(int field, char data)\n"
    "    CharField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CharField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::CharField *arg1 = (FIX::CharField *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__CharField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::CharField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::CharField * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->setValue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CharField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::CharField *arg1 = (FIX::CharField *) 0 ;
  char result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__CharField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::CharField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::CharField * >(argp1);
  try {
    result = (char)((FIX::CharField const *)arg1)->getValue();
  }
  catch(FIX::IncorrectDataFormat &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_CharField(FIX::CharField *arg1) {
    delete arg1;
}

swig_class cDoubleField;

SWIGINTERN VALUE
_wrap_new_DoubleField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  double arg2 ;
  int arg3 ;
  FIX::DoubleField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DoubleField";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::DoubleField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","FIX::DoubleField", 2, argv[1] ));
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","FIX::DoubleField", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (FIX::DoubleField *)new FIX::DoubleField(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DoubleField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  double arg2 ;
  FIX::DoubleField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DoubleField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::DoubleField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","FIX::DoubleField", 2, argv[1] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (FIX::DoubleField *)new FIX::DoubleField(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DoubleField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DoubleField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DoubleField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DoubleField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::DoubleField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DoubleField";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::DoubleField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::DoubleField *)new FIX::DoubleField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DoubleField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_DoubleField__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_DoubleField__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_DoubleField__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "DoubleField.new", 
    "    DoubleField.new(int field, double data, int padding)\n"
    "    DoubleField.new(int field, double data)\n"
    "    DoubleField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleField_setValue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DoubleField *arg1 = (FIX::DoubleField *) 0 ;
  double arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DoubleField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DoubleField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DoubleField * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","setValue", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->setValue(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleField_setValue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DoubleField *arg1 = (FIX::DoubleField *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DoubleField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DoubleField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DoubleField * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->setValue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DoubleField_setValue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DoubleField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_DoubleField_setValue__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DoubleField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_DoubleField_setValue__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "DoubleField.setValue", 
    "    void DoubleField.setValue(double value, int padding)\n"
    "    void DoubleField.setValue(double value)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::DoubleField *arg1 = (FIX::DoubleField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DoubleField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DoubleField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DoubleField * >(argp1);
  try {
    result = (double)((FIX::DoubleField const *)arg1)->getValue();
  }
  catch(FIX::IncorrectDataFormat &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_DoubleField(FIX::DoubleField *arg1) {
    delete arg1;
}

swig_class cIntField;

SWIGINTERN VALUE
_wrap_new_IntField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  FIX::IntField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IntField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::IntField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::IntField", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (FIX::IntField *)new FIX::IntField(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_IntField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_IntField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IntField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_IntField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::IntField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IntField";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::IntField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::IntField *)new FIX::IntField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IntField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_IntField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_IntField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "IntField.new", 
    "    IntField.new(int field, int data)\n"
    "    IntField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IntField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::IntField *arg1 = (FIX::IntField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IntField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IntField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IntField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->setValue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_IntField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::IntField *arg1 = (FIX::IntField *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__IntField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::IntField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::IntField * >(argp1);
  try {
    result = (int)((FIX::IntField const *)arg1)->getValue();
  }
  catch(FIX::IncorrectDataFormat &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_IntField(FIX::IntField *arg1) {
    delete arg1;
}

swig_class cBoolField;

SWIGINTERN VALUE
_wrap_new_BoolField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  bool arg2 ;
  FIX::BoolField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::BoolField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::BoolField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","FIX::BoolField", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (FIX::BoolField *)new FIX::BoolField(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_BoolField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_BoolField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__BoolField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_BoolField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::BoolField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::BoolField";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::BoolField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::BoolField *)new FIX::BoolField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_BoolField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_BoolField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_BoolField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "BoolField.new", 
    "    BoolField.new(int field, bool data)\n"
    "    BoolField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BoolField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::BoolField *arg1 = (FIX::BoolField *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__BoolField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::BoolField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::BoolField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setValue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BoolField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::BoolField *arg1 = (FIX::BoolField *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__BoolField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::BoolField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::BoolField * >(argp1);
  try {
    result = (bool)((FIX::BoolField const *)arg1)->getValue();
  }
  catch(FIX::IncorrectDataFormat &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_BoolField(FIX::BoolField *arg1) {
    delete arg1;
}

swig_class cUtcTimeStampField;

SWIGINTERN VALUE
_wrap_new_UtcTimeStampField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  UtcTimeStamp *arg2 = 0 ;
  bool arg3 ;
  FIX::UtcTimeStampField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStampField";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::UtcTimeStampField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UtcTimeStamp const &","FIX::UtcTimeStampField", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "UtcTimeStamp const &","FIX::UtcTimeStampField", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< UtcTimeStamp * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","FIX::UtcTimeStampField", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (FIX::UtcTimeStampField *)new FIX::UtcTimeStampField(arg1,(UtcTimeStamp const &)*arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStampField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  UtcTimeStamp *arg2 = 0 ;
  FIX::UtcTimeStampField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStampField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::UtcTimeStampField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UtcTimeStamp const &","FIX::UtcTimeStampField", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "UtcTimeStamp const &","FIX::UtcTimeStampField", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< UtcTimeStamp * >(argp2);
  result = (FIX::UtcTimeStampField *)new FIX::UtcTimeStampField(arg1,(UtcTimeStamp const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeStampField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  bool arg2 ;
  FIX::UtcTimeStampField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStampField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::UtcTimeStampField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","FIX::UtcTimeStampField", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (FIX::UtcTimeStampField *)new FIX::UtcTimeStampField(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_UtcTimeStampField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_UtcTimeStampField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UtcTimeStampField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_UtcTimeStampField__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::UtcTimeStampField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeStampField";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::UtcTimeStampField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::UtcTimeStampField *)new FIX::UtcTimeStampField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UtcTimeStampField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_UtcTimeStampField__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_UtcTimeStamp, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_UtcTimeStampField__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UtcTimeStampField__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_UtcTimeStamp, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcTimeStampField__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "UtcTimeStampField.new", 
    "    UtcTimeStampField.new(int field, UtcTimeStamp const &data, bool showMilliseconds)\n"
    "    UtcTimeStampField.new(int field, UtcTimeStamp const &data)\n"
    "    UtcTimeStampField.new(int field, bool showMilliseconds)\n"
    "    UtcTimeStampField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcTimeStampField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStampField *arg1 = (FIX::UtcTimeStampField *) 0 ;
  UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeStampField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStampField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UtcTimeStamp &","setValue", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "UtcTimeStamp &","setValue", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< UtcTimeStamp * >(argp2);
  (arg1)->setValue(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcTimeStampField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStampField *arg1 = (FIX::UtcTimeStampField *) 0 ;
  UtcTimeStamp result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeStampField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStampField * >(argp1);
  try {
    result = ((FIX::UtcTimeStampField const *)arg1)->getValue();
  }
  catch(FIX::IncorrectDataFormat &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new UtcTimeStamp(static_cast< const UtcTimeStamp& >(result))), SWIGTYPE_p_UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::UtcTimeStampField.<

  call-seq:
    <(rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcTimeStampField___lt__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStampField *arg1 = (FIX::UtcTimeStampField *) 0 ;
  FIX::UtcTimeStampField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeStampField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStampField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStampField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStampField const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStampField * >(argp2);
  result = (bool)((FIX::UtcTimeStampField const *)arg1)->operator <((FIX::UtcTimeStampField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::UtcTimeStampField.==

  call-seq:
    ==(rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcTimeStampField___eq__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeStampField *arg1 = (FIX::UtcTimeStampField *) 0 ;
  FIX::UtcTimeStampField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeStampField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeStampField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeStampField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeStampField const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeStampField const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeStampField * >(argp2);
  result = (bool)((FIX::UtcTimeStampField const *)arg1)->operator ==((FIX::UtcTimeStampField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_UtcTimeStampField(FIX::UtcTimeStampField *arg1) {
    delete arg1;
}

swig_class cUtcDateField;

SWIGINTERN VALUE
_wrap_new_UtcDateField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  UtcDate *arg2 = 0 ;
  FIX::UtcDateField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcDateField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::UtcDateField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_UtcDate,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UtcDate const &","FIX::UtcDateField", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "UtcDate const &","FIX::UtcDateField", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< UtcDate * >(argp2);
  result = (FIX::UtcDateField *)new FIX::UtcDateField(arg1,(UtcDate const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_UtcDateField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_UtcDateField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UtcDateField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_UtcDateField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::UtcDateField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcDateField";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::UtcDateField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::UtcDateField *)new FIX::UtcDateField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UtcDateField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_UtcDateField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_UtcDate, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_UtcDateField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "UtcDateField.new", 
    "    UtcDateField.new(int field, UtcDate const &data)\n"
    "    UtcDateField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcDateField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcDateField *arg1 = (FIX::UtcDateField *) 0 ;
  UtcDate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcDateField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcDateField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcDateField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_UtcDate,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UtcDate &","setValue", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "UtcDate &","setValue", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< UtcDate * >(argp2);
  (arg1)->setValue(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcDateField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcDateField *arg1 = (FIX::UtcDateField *) 0 ;
  UtcDate result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcDateField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcDateField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcDateField * >(argp1);
  try {
    result = ((FIX::UtcDateField const *)arg1)->getValue();
  }
  catch(FIX::IncorrectDataFormat &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new UtcDate(static_cast< const UtcDate& >(result))), SWIGTYPE_p_UtcDate, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::UtcDateField.<

  call-seq:
    <(rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcDateField___lt__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcDateField *arg1 = (FIX::UtcDateField *) 0 ;
  FIX::UtcDateField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcDateField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcDateField const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcDateField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcDateField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcDateField const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcDateField const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcDateField * >(argp2);
  result = (bool)((FIX::UtcDateField const *)arg1)->operator <((FIX::UtcDateField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::UtcDateField.==

  call-seq:
    ==(rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcDateField___eq__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcDateField *arg1 = (FIX::UtcDateField *) 0 ;
  FIX::UtcDateField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcDateField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcDateField const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcDateField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcDateField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcDateField const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcDateField const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcDateField * >(argp2);
  result = (bool)((FIX::UtcDateField const *)arg1)->operator ==((FIX::UtcDateField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_UtcDateField(FIX::UtcDateField *arg1) {
    delete arg1;
}

swig_class cUtcTimeOnlyField;

SWIGINTERN VALUE
_wrap_new_UtcTimeOnlyField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  UtcTimeOnly *arg2 = 0 ;
  bool arg3 ;
  FIX::UtcTimeOnlyField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnlyField";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::UtcTimeOnlyField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_UtcTimeOnly,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UtcTimeOnly const &","FIX::UtcTimeOnlyField", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "UtcTimeOnly const &","FIX::UtcTimeOnlyField", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< UtcTimeOnly * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","FIX::UtcTimeOnlyField", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (FIX::UtcTimeOnlyField *)new FIX::UtcTimeOnlyField(arg1,(UtcTimeOnly const &)*arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnlyField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  UtcTimeOnly *arg2 = 0 ;
  FIX::UtcTimeOnlyField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnlyField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::UtcTimeOnlyField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_UtcTimeOnly,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UtcTimeOnly const &","FIX::UtcTimeOnlyField", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "UtcTimeOnly const &","FIX::UtcTimeOnlyField", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< UtcTimeOnly * >(argp2);
  result = (FIX::UtcTimeOnlyField *)new FIX::UtcTimeOnlyField(arg1,(UtcTimeOnly const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UtcTimeOnlyField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  bool arg2 ;
  FIX::UtcTimeOnlyField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnlyField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::UtcTimeOnlyField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","FIX::UtcTimeOnlyField", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (FIX::UtcTimeOnlyField *)new FIX::UtcTimeOnlyField(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_UtcTimeOnlyField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_UtcTimeOnlyField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UtcTimeOnlyField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_UtcTimeOnlyField__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::UtcTimeOnlyField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UtcTimeOnlyField";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::UtcTimeOnlyField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::UtcTimeOnlyField *)new FIX::UtcTimeOnlyField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UtcTimeOnlyField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_UtcTimeOnlyField__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_UtcTimeOnly, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_UtcTimeOnlyField__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UtcTimeOnlyField__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_UtcTimeOnly, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_UtcTimeOnlyField__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "UtcTimeOnlyField.new", 
    "    UtcTimeOnlyField.new(int field, UtcTimeOnly const &data, bool showMilliseconds)\n"
    "    UtcTimeOnlyField.new(int field, UtcTimeOnly const &data)\n"
    "    UtcTimeOnlyField.new(int field, bool showMilliseconds)\n"
    "    UtcTimeOnlyField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcTimeOnlyField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeOnlyField *arg1 = (FIX::UtcTimeOnlyField *) 0 ;
  UtcTimeOnly *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeOnlyField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_UtcTimeOnly,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UtcTimeOnly &","setValue", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "UtcTimeOnly &","setValue", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< UtcTimeOnly * >(argp2);
  (arg1)->setValue(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UtcTimeOnlyField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeOnlyField *arg1 = (FIX::UtcTimeOnlyField *) 0 ;
  UtcTimeOnly result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeOnlyField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp1);
  try {
    result = ((FIX::UtcTimeOnlyField const *)arg1)->getValue();
  }
  catch(FIX::IncorrectDataFormat &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new UtcTimeOnly(static_cast< const UtcTimeOnly& >(result))), SWIGTYPE_p_UtcTimeOnly, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::UtcTimeOnlyField.<

  call-seq:
    <(rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcTimeOnlyField___lt__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeOnlyField *arg1 = (FIX::UtcTimeOnlyField *) 0 ;
  FIX::UtcTimeOnlyField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeOnlyField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeOnlyField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeOnlyField const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp2);
  result = (bool)((FIX::UtcTimeOnlyField const *)arg1)->operator <((FIX::UtcTimeOnlyField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::UtcTimeOnlyField.==

  call-seq:
    ==(rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_UtcTimeOnlyField___eq__(int argc, VALUE *argv, VALUE self) {
  FIX::UtcTimeOnlyField *arg1 = (FIX::UtcTimeOnlyField *) 0 ;
  FIX::UtcTimeOnlyField *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__UtcTimeOnlyField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__UtcTimeOnlyField,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::UtcTimeOnlyField const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::UtcTimeOnlyField const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::UtcTimeOnlyField * >(argp2);
  result = (bool)((FIX::UtcTimeOnlyField const *)arg1)->operator ==((FIX::UtcTimeOnlyField const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_UtcTimeOnlyField(FIX::UtcTimeOnlyField *arg1) {
    delete arg1;
}

swig_class cCheckSumField;

SWIGINTERN VALUE
_wrap_new_CheckSumField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  FIX::CheckSumField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CheckSumField";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::CheckSumField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::CheckSumField", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (FIX::CheckSumField *)new FIX::CheckSumField(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CheckSumField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CheckSumField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CheckSumField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CheckSumField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  FIX::CheckSumField *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CheckSumField";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::CheckSumField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (FIX::CheckSumField *)new FIX::CheckSumField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CheckSumField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_CheckSumField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_CheckSumField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "CheckSumField.new", 
    "    CheckSumField.new(int field, int data)\n"
    "    CheckSumField.new(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CheckSumField_setValue(int argc, VALUE *argv, VALUE self) {
  FIX::CheckSumField *arg1 = (FIX::CheckSumField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__CheckSumField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::CheckSumField *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::CheckSumField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->setValue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CheckSumField_getValue(int argc, VALUE *argv, VALUE self) {
  FIX::CheckSumField *arg1 = (FIX::CheckSumField *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__CheckSumField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::CheckSumField const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::CheckSumField * >(argp1);
  try {
    result = (int)((FIX::CheckSumField const *)arg1)->getValue();
  }
  catch(FIX::IncorrectDataFormat &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_CheckSumField(FIX::CheckSumField *arg1) {
    delete arg1;
}

swig_class cFieldMap;

SWIGINTERN VALUE
_wrap_new_FieldMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
  message_order *arg1 = 0 ;
  FIX::FieldMap *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldMap";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "message_order const &","FIX::FieldMap", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","FIX::FieldMap", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< message_order * >(argp1);
  result = (FIX::FieldMap *)new FIX::FieldMap((message_order const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FieldMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldMap";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::FieldMap *)new FIX::FieldMap();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FieldMap__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int *arg1 ;
  FIX::FieldMap *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldMap";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "int const []","FIX::FieldMap", 1, argv[0] )); 
  } 
  arg1 = reinterpret_cast< int * >(argp1);
  result = (FIX::FieldMap *)new FIX::FieldMap((int const (*))arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FieldMap_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FieldMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FieldMap);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FieldMap__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = 0 ;
  FIX::FieldMap *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FieldMap";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const &","FIX::FieldMap", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap const &","FIX::FieldMap", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  result = (FIX::FieldMap *)new FIX::FieldMap((FIX::FieldMap const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FieldMap(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_FieldMap__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_message_order, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FieldMap__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_int, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FieldMap__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FieldMap__SWIG_3(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "FieldMap.new", 
    "    FieldMap.new(message_order const &order)\n"
    "    FieldMap.new()\n"
    "    FieldMap.new(int const order[])\n"
    "    FieldMap.new(FIX::FieldMap const &copy)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_FieldMap(FIX::FieldMap *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FieldMap_setField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","setField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase const &","setField", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","setField", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setField", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  try {
    (arg1)->setField((FIX::FieldBase const &)*arg2,arg3);
  }
  catch(FIX::RepeatedTag &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RepeatedTag, SWIG_NewPointerObj((new FIX::RepeatedTag(static_cast< const FIX::RepeatedTag& >(_e))),SWIGTYPE_p_FIX__RepeatedTag,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_setField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","setField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase const &","setField", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","setField", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  try {
    (arg1)->setField((FIX::FieldBase const &)*arg2);
  }
  catch(FIX::RepeatedTag &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RepeatedTag, SWIG_NewPointerObj((new FIX::RepeatedTag(static_cast< const FIX::RepeatedTag& >(_e))),SWIGTYPE_p_FIX__RepeatedTag,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_setField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","setField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","setField", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setField", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  try {
    (arg1)->setField(arg2,(std::string const &)*arg3);
  }
  catch(FIX::RepeatedTag &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RepeatedTag, SWIG_NewPointerObj((new FIX::RepeatedTag(static_cast< const FIX::RepeatedTag& >(_e))),SWIGTYPE_p_FIX__RepeatedTag,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::NoTagValue &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__NoTagValue, SWIG_NewPointerObj((new FIX::NoTagValue(static_cast< const FIX::NoTagValue& >(_e))),SWIGTYPE_p_FIX__NoTagValue,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_setField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__FieldBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FieldMap_setField__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__FieldBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FieldMap_setField__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_FieldMap_setField__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "FieldMap.setField", 
    "    void FieldMap.setField(FIX::FieldBase const &field, bool overwrite)\n"
    "    void FieldMap.setField(FIX::FieldBase const &field)\n"
    "    void FieldMap.setField(int field, std::string const &value)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  FIX::FieldBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase &","getField", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase &","getField", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  try {
    {
      FIX::FieldBase &_result_ref = ((FIX::FieldMap const *)arg1)->getField(*arg2);
      result = (FIX::FieldBase *) &_result_ref;
    }
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      std::string const &_result_ref = ((FIX::FieldMap const *)arg1)->getField(arg2);
      result = (std::string *) &_result_ref;
    }
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_getField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__FieldBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FieldMap_getField__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_getField__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "FieldMap.getField", 
    "    std::string const & FieldMap.getField(FIX::FieldBase &field)\n"
    "    std::string const & FieldMap.getField(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getFieldRef(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  FIX::FieldBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getFieldRef", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getFieldRef", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      FIX::FieldBase const &_result_ref = ((FIX::FieldMap const *)arg1)->getFieldRef(arg2);
      result = (FIX::FieldBase *) &_result_ref;
    }
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getFieldPtr(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  FIX::FieldBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getFieldPtr", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getFieldPtr", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    result = (FIX::FieldBase *)((FIX::FieldMap const *)arg1)->getFieldPtr(arg2);
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_isSetField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldBase *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","isSetField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::FieldBase const &","isSetField", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","isSetField", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::FieldBase * >(argp2);
  result = (bool)((FIX::FieldMap const *)arg1)->isSetField((FIX::FieldBase const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_isSetField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","isSetField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isSetField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((FIX::FieldMap const *)arg1)->isSetField(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_isSetField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__FieldBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FieldMap_isSetField__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_isSetField__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "FieldMap.isSetField", 
    "    bool FieldMap.isSetField(FIX::FieldBase const &field)\n"
    "    bool FieldMap.isSetField(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_removeField(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","removeField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","removeField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->removeField(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_addGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  FIX::FieldMap *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::FieldMap const &","addGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap const &","addGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::FieldMap * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","addGroup", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->addGroup(arg2,(FIX::FieldMap const &)*arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_addGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  FIX::FieldMap *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::FieldMap const &","addGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap const &","addGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::FieldMap * >(argp3);
  (arg1)->addGroup(arg2,(FIX::FieldMap const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_addGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_FieldMap_addGroup__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FieldMap_addGroup__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "FieldMap.addGroup", 
    "    void FieldMap.addGroup(int field, FIX::FieldMap const &group, bool setCount)\n"
    "    void FieldMap.addGroup(int field, FIX::FieldMap const &group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_replaceGroup(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  FIX::FieldMap *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","replaceGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","replaceGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","replaceGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::FieldMap &","replaceGroup", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap &","replaceGroup", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< FIX::FieldMap * >(argp4);
  (arg1)->replaceGroup(arg2,arg3,*arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_getGroup(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  FIX::FieldMap *arg4 = 0 ;
  FIX::FieldMap *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","getGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","getGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::FieldMap &","getGroup", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap &","getGroup", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< FIX::FieldMap * >(argp4);
  try {
    {
      FIX::FieldMap &_result_ref = ((FIX::FieldMap const *)arg1)->getGroup(arg2,arg3,*arg4);
      result = (FIX::FieldMap *) &_result_ref;
    }
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_removeGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","removeGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","removeGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->removeGroup(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_removeGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","removeGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->removeGroup(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_removeGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_removeGroup__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FieldMap_removeGroup__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "FieldMap.removeGroup", 
    "    void FieldMap.removeGroup(int num, int field)\n"
    "    void FieldMap.removeGroup(int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_hasGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","hasGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((FIX::FieldMap const *)arg1)->hasGroup(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_hasGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","hasGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","hasGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (bool)((FIX::FieldMap const *)arg1)->hasGroup(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_hasGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_hasGroup__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FieldMap_hasGroup__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "FieldMap.hasGroup", 
    "    bool FieldMap.hasGroup(int field)\n"
    "    bool FieldMap.hasGroup(int num, int field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_groupCount(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","groupCount", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","groupCount", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)((FIX::FieldMap const *)arg1)->groupCount(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_clear(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_isEmpty(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap *","isEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  result = (bool)(arg1)->isEmpty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_totalFields(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","totalFields", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  result = (int)((FIX::FieldMap const *)arg1)->totalFields();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    temp2 = std::string((char*)STR2CSTR(argv[0]));
    arg2 = &temp2;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","calculateString", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    std::string &_result_ref = ((FIX::FieldMap const *)arg1)->calculateString(*arg2,arg3);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  std::string *arg2 = 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  {
    temp2 = std::string((char*)STR2CSTR(argv[0]));
    arg2 = &temp2;
  }
  {
    std::string &_result_ref = ((FIX::FieldMap const *)arg1)->calculateString(*arg2);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_calculateString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FieldMap_calculateString__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FieldMap_calculateString__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "FieldMap.calculateString", 
    "    std::string & FieldMap.calculateString(std::string &, bool clear)\n"
    "    std::string & FieldMap.calculateString(std::string &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateLength__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","calculateLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","calculateLength", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","calculateLength", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (int)((FIX::FieldMap const *)arg1)->calculateLength(arg2,arg3,arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateLength__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int arg3 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","calculateLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","calculateLength", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (int)((FIX::FieldMap const *)arg1)->calculateLength(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateLength__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","calculateLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)((FIX::FieldMap const *)arg1)->calculateLength(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateLength__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  result = (int)((FIX::FieldMap const *)arg1)->calculateLength();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_calculateLength(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_calculateLength__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_calculateLength__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FieldMap_calculateLength__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FieldMap_calculateLength__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "FieldMap.calculateLength", 
    "    int FieldMap.calculateLength(int beginStringField, int bodyLengthField, int checkSumField)\n"
    "    int FieldMap.calculateLength(int beginStringField, int bodyLengthField)\n"
    "    int FieldMap.calculateLength(int beginStringField)\n"
    "    int FieldMap.calculateLength()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateTotal__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateTotal", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","calculateTotal", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)((FIX::FieldMap const *)arg1)->calculateTotal(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_calculateTotal__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","calculateTotal", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  result = (int)((FIX::FieldMap const *)arg1)->calculateTotal();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FieldMap_calculateTotal(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FieldMap_calculateTotal__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldMap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FieldMap_calculateTotal__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "FieldMap.calculateTotal", 
    "    int FieldMap.calculateTotal(int checkSumField)\n"
    "    int FieldMap.calculateTotal()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_begin(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldMap::iterator result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  result = ((FIX::FieldMap const *)arg1)->begin();
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::iterator(static_cast< const FIX::FieldMap::iterator& >(result))), SWIGTYPE_p_FIX__FieldMap__Fields__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_end(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldMap::iterator result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  result = ((FIX::FieldMap const *)arg1)->end();
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::iterator(static_cast< const FIX::FieldMap::iterator& >(result))), SWIGTYPE_p_FIX__FieldMap__Fields__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_g_begin(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldMap::g_iterator result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","g_begin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  result = ((FIX::FieldMap const *)arg1)->g_begin();
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::g_iterator(static_cast< const FIX::FieldMap::g_iterator& >(result))), SWIGTYPE_p_FIX__FieldMap__Groups__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FieldMap_g_end(int argc, VALUE *argv, VALUE self) {
  FIX::FieldMap *arg1 = (FIX::FieldMap *) 0 ;
  FIX::FieldMap::g_iterator result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldMap const *","g_end", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FieldMap * >(argp1);
  result = ((FIX::FieldMap const *)arg1)->g_end();
  vresult = SWIG_NewPointerObj((new FIX::FieldMap::g_iterator(static_cast< const FIX::FieldMap::g_iterator& >(result))), SWIGTYPE_p_FIX__FieldMap__Groups__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_headerOrder_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(FIX::headerOrder), SWIGTYPE_p_FIELD__Field,  0 );
  return _val;
}


swig_class cMessage;

SWIGINTERN VALUE
_wrap_new_Message__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::Message *)new FIX::Message();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  bool arg2 ;
  FIX::Message *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Message", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Message", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","FIX::Message", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  try {
    result = (FIX::Message *)new FIX::Message((std::string const &)*arg1,arg2);DATA_PTR(self) = result;
  }
  catch(FIX::InvalidMessage &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__InvalidMessage, SWIG_NewPointerObj((new FIX::InvalidMessage(static_cast< const FIX::InvalidMessage& >(_e))),SWIGTYPE_p_FIX__InvalidMessage,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::Message *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Message", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Message", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  try {
    result = (FIX::Message *)new FIX::Message((std::string const &)*arg1);DATA_PTR(self) = result;
  }
  catch(FIX::InvalidMessage &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__InvalidMessage, SWIG_NewPointerObj((new FIX::InvalidMessage(static_cast< const FIX::InvalidMessage& >(_e))),SWIGTYPE_p_FIX__InvalidMessage,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::DataDictionary *arg2 = 0 ;
  bool arg3 ;
  FIX::Message *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Message", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Message", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","FIX::Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","FIX::Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DataDictionary * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","FIX::Message", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  try {
    result = (FIX::Message *)new FIX::Message((std::string const &)*arg1,(FIX::DataDictionary const &)*arg2,arg3);DATA_PTR(self) = result;
  }
  catch(FIX::InvalidMessage &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__InvalidMessage, SWIG_NewPointerObj((new FIX::InvalidMessage(static_cast< const FIX::InvalidMessage& >(_e))),SWIGTYPE_p_FIX__InvalidMessage,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Message__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::DataDictionary *arg2 = 0 ;
  FIX::Message *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Message", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Message", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","FIX::Message", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","FIX::Message", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::DataDictionary * >(argp2);
  try {
    result = (FIX::Message *)new FIX::Message((std::string const &)*arg1,(FIX::DataDictionary const &)*arg2);DATA_PTR(self) = result;
  }
  catch(FIX::InvalidMessage &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__InvalidMessage, SWIG_NewPointerObj((new FIX::InvalidMessage(static_cast< const FIX::InvalidMessage& >(_e))),SWIGTYPE_p_FIX__InvalidMessage,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Message_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Message_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Message);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Message__SWIG_5(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  FIX::Message *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Message";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const &","FIX::Message", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","FIX::Message", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  result = (FIX::Message *)new FIX::Message((FIX::Message const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Message(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Message__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Message__SWIG_5(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Message__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_Message__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Message__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Message__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Message.new", 
    "    Message.new()\n"
    "    Message.new(std::string const &string, bool validate)\n"
    "    Message.new(std::string const &string)\n"
    "    Message.new(std::string const &string, FIX::DataDictionary const &dataDictionary, bool validate)\n"
    "    Message.new(std::string const &string, FIX::DataDictionary const &dataDictionary)\n"
    "    Message.new(FIX::Message const &copy)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_InitializeXML(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  bool result;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Message::InitializeXML", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Message::InitializeXML", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (bool)FIX::Message::InitializeXML((std::string const &)*arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_addGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group &","addGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","addGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  (arg1)->addGroup(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_replaceGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","replaceGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","replaceGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","replaceGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","replaceGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  (arg1)->replaceGroup(arg2,*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  Group *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","getGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","getGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","getGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  try {
    {
      Group &_result_ref = ((FIX::Message const *)arg1)->getGroup(arg2,*arg3);
      result = (Group *) &_result_ref;
    }
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Group, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_removeGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","removeGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","removeGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  (arg1)->removeGroup(arg2,*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_removeGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group &","removeGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","removeGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  (arg1)->removeGroup(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_removeGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_removeGroup__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Message_removeGroup__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Message.removeGroup", 
    "    void Message.removeGroup(unsigned int num, FIX::Group &group)\n"
    "    void Message.removeGroup(FIX::Group &group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_hasGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Group *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","hasGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","hasGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  result = (bool)(arg1)->hasGroup((FIX::Group const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_hasGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","hasGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","hasGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","hasGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  result = (bool)(arg1)->hasGroup(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_hasGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_hasGroup__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Message_hasGroup__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Message.hasGroup", 
    "    bool Message.hasGroup(FIX::Group const &group)\n"
    "    bool Message.hasGroup(unsigned int num, FIX::Group &group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","toString", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","toString", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","toString", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  result = ((FIX::Message const *)arg1)->toString(arg2,arg3,arg4);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  int arg3 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","toString", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","toString", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = ((FIX::Message const *)arg1)->toString(arg2,arg3);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","toString", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((FIX::Message const *)arg1)->toString(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  result = ((FIX::Message const *)arg1)->toString();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_4(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = std::string((char*)STR2CSTR(argv[0]));
    arg2 = &temp2;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","toString", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","toString", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","toString", 5, argv[3] ));
  } 
  arg5 = static_cast< int >(val5);
  {
    std::string &_result_ref = ((FIX::Message const *)arg1)->toString(*arg2,arg3,arg4,arg5);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_5(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = std::string((char*)STR2CSTR(argv[0]));
    arg2 = &temp2;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","toString", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","toString", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  {
    std::string &_result_ref = ((FIX::Message const *)arg1)->toString(*arg2,arg3,arg4);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_6(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = std::string((char*)STR2CSTR(argv[0]));
    arg2 = &temp2;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","toString", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    std::string &_result_ref = ((FIX::Message const *)arg1)->toString(*arg2,arg3);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toString__SWIG_7(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = std::string((char*)STR2CSTR(argv[0]));
    arg2 = &temp2;
  }
  {
    std::string &_result_ref = ((FIX::Message const *)arg1)->toString(*arg2);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_toString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_toString__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_toString__SWIG_7(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Message_toString__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Message_toString__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Message_toString__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_Message_toString__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_Message_toString__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_Message_toString__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "Message.toString", 
    "    std::string & Message.toString(int beginStringField, int bodyLengthField, int checkSumField)\n"
    "    std::string & Message.toString(int beginStringField, int bodyLengthField)\n"
    "    std::string & Message.toString(int beginStringField)\n"
    "    std::string & Message.toString()\n"
    "    std::string & Message.toString(std::string &, int beginStringField, int bodyLengthField, int checkSumField)\n"
    "    std::string & Message.toString(std::string &, int beginStringField, int bodyLengthField)\n"
    "    std::string & Message.toString(std::string &, int beginStringField)\n"
    "    std::string & Message.toString(std::string &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toXML__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toXML", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  result = ((FIX::Message const *)arg1)->toXML();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_toXML__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","toXML", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = std::string((char*)STR2CSTR(argv[0]));
    arg2 = &temp2;
  }
  {
    std::string &_result_ref = ((FIX::Message const *)arg1)->toXML(*arg2);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_toXML(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_toXML__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_toXML__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Message.toXML", 
    "    std::string & Message.toXML()\n"
    "    std::string & Message.toXML(std::string &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_reverseRoute(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Header *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","reverseRoute", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Header const &","reverseRoute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Header const &","reverseRoute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Header * >(argp2);
  (arg1)->reverseRoute((FIX::Header const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  FIX::DataDictionary *arg4 = (FIX::DataDictionary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setString", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","setString", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< FIX::DataDictionary * >(argp4);
  try {
    (arg1)->setString((std::string const &)*arg2,arg3,(FIX::DataDictionary const *)arg4);
  }
  catch(FIX::InvalidMessage &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__InvalidMessage, SWIG_NewPointerObj((new FIX::InvalidMessage(static_cast< const FIX::InvalidMessage& >(_e))),SWIGTYPE_p_FIX__InvalidMessage,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setString", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  try {
    (arg1)->setString((std::string const &)*arg2,arg3);
  }
  catch(FIX::InvalidMessage &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__InvalidMessage, SWIG_NewPointerObj((new FIX::InvalidMessage(static_cast< const FIX::InvalidMessage& >(_e))),SWIGTYPE_p_FIX__InvalidMessage,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setString__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  try {
    (arg1)->setString((std::string const &)*arg2);
  }
  catch(FIX::InvalidMessage &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__InvalidMessage, SWIG_NewPointerObj((new FIX::InvalidMessage(static_cast< const FIX::InvalidMessage& >(_e))),SWIGTYPE_p_FIX__InvalidMessage,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_setString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_setString__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Message_setString__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_Message_setString__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "Message.setString", 
    "    void Message.setString(std::string const &string, bool validate, FIX::DataDictionary const *pDataDictionary)\n"
    "    void Message.setString(std::string const &string, bool validate)\n"
    "    void Message.setString(std::string const &string)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  FIX::FieldBase *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string::size_type *arg5 = 0 ;
  FIX::FieldMap *arg6 = 0 ;
  DataDictionary *arg7 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 ;
  int res7 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setGroup", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setGroup", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::FieldBase const &","setGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","setGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::FieldBase * >(argp3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","setGroup", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setGroup", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_std__string__size_type,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string::size_type &","setGroup", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string::size_type &","setGroup", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< std::string::size_type * >(argp5);
  res6 = SWIG_ConvertPtr(argv[4], &argp6, SWIGTYPE_p_FIX__FieldMap,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "FIX::FieldMap &","setGroup", 6, argv[4] )); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldMap &","setGroup", 6, argv[4])); 
  }
  arg6 = reinterpret_cast< FIX::FieldMap * >(argp6);
  res7 = SWIG_ConvertPtr(argv[5], &argp7, SWIGTYPE_p_DataDictionary,  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), Ruby_Format_TypeError( "", "DataDictionary const &","setGroup", 7, argv[5] )); 
  }
  if (!argp7) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "DataDictionary const &","setGroup", 7, argv[5])); 
  }
  arg7 = reinterpret_cast< DataDictionary * >(argp7);
  (arg1)->setGroup((std::string const &)*arg2,(FIX::FieldBase const &)*arg3,(std::string const &)*arg4,*arg5,*arg6,(DataDictionary const &)*arg7);
  vresult = rb_ary_new();
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setStringHeader(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setStringHeader", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setStringHeader", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setStringHeader", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->setStringHeader((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getHeader__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Header *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","getHeader", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    FIX::Header const &_result_ref = ((FIX::Message const *)arg1)->getHeader();
    result = (FIX::Header *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getHeader__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Header *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","getHeader", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    FIX::Header &_result_ref = (arg1)->getHeader();
    result = (FIX::Header *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_getHeader(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_getHeader__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_getHeader__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Message.getHeader", 
    "    FIX::Header & Message.getHeader()\n"
    "    FIX::Header & Message.getHeader()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getTrailer__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Header *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","getTrailer", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    FIX::Header const &_result_ref = ((FIX::Message const *)arg1)->getTrailer();
    result = (FIX::Header *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getTrailer__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  FIX::Trailer *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","getTrailer", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    FIX::Trailer &_result_ref = (arg1)->getTrailer();
    result = (FIX::Trailer *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__FieldMap, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_getTrailer(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_getTrailer__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_getTrailer__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Message.getTrailer", 
    "    FIX::Trailer & Message.getTrailer()\n"
    "    FIX::Trailer & Message.getTrailer()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_hasValidStructure(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","hasValidStructure", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    temp2 = NUM2INT(argv[0]);
    arg2 = &temp2;
  }
  result = (bool)((FIX::Message const *)arg1)->hasValidStructure(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("int &") == "int &" )
    {
      vresult = result ? SWIG_From_int(static_cast< int >(*arg2)) : Qnil;
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_bodyLength__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","bodyLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","bodyLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","bodyLength", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","bodyLength", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (int)((FIX::Message const *)arg1)->bodyLength(arg2,arg3,arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_bodyLength__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  int arg3 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","bodyLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","bodyLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","bodyLength", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (int)((FIX::Message const *)arg1)->bodyLength(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_bodyLength__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","bodyLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","bodyLength", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)((FIX::Message const *)arg1)->bodyLength(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_bodyLength__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","bodyLength", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  result = (int)((FIX::Message const *)arg1)->bodyLength();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_bodyLength(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_bodyLength__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Message_bodyLength__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Message_bodyLength__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_Message_bodyLength__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "Message.bodyLength", 
    "    int Message.bodyLength(int beginStringField, int bodyLengthField, int checkSumField)\n"
    "    int Message.bodyLength(int beginStringField, int bodyLengthField)\n"
    "    int Message.bodyLength(int beginStringField)\n"
    "    int Message.bodyLength()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_checkSum__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","checkSum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","checkSum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)((FIX::Message const *)arg1)->checkSum(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_checkSum__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","checkSum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  result = (int)((FIX::Message const *)arg1)->checkSum();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_checkSum(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_checkSum__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Message_checkSum__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Message.checkSum", 
    "    int Message.checkSum(int checkSumField)\n"
    "    int Message.checkSum()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isAdmin(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","isAdmin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  result = (bool)((FIX::Message const *)arg1)->isAdmin();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isApp(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message const *","isApp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  result = (bool)((FIX::Message const *)arg1)->isApp();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isEmpty(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","isEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  result = (bool)(arg1)->isEmpty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_clear(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isAdminMsgType(int argc, VALUE *argv, VALUE self) {
  MsgType *arg1 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_MsgType,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MsgType const &","FIX::Message::isAdminMsgType", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "MsgType const &","FIX::Message::isAdminMsgType", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< MsgType * >(argp1);
  result = (bool)FIX::Message::isAdminMsgType((MsgType const &)*arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isHeaderField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  bool result;
  int val1 ;
  int ecode1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::Message::isHeaderField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (bool)FIX::Message::isHeaderField(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isHeaderField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = 0 ;
  DataDictionary *arg2 = (DataDictionary *) 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FIX::Message::isHeaderField", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FIX::Message::isHeaderField", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "DataDictionary const *","FIX::Message::isHeaderField", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< DataDictionary * >(argp2);
  result = (bool)FIX::Message::isHeaderField((FIX::FieldBase const &)*arg1,(DataDictionary const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isHeaderField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FIX::Message::isHeaderField", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FIX::Message::isHeaderField", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  result = (bool)FIX::Message::isHeaderField((FIX::FieldBase const &)*arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_isHeaderField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_isHeaderField__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_Message_isHeaderField__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_DataDictionary, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_isHeaderField__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Message.isHeaderField", 
    "    bool Message.isHeaderField(int field)\n"
    "    bool Message.isHeaderField(FIX::FieldBase const &field, DataDictionary const *pD)\n"
    "    bool Message.isHeaderField(FIX::FieldBase const &field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isTrailerField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  bool result;
  int val1 ;
  int ecode1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::Message::isTrailerField", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (bool)FIX::Message::isTrailerField(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isTrailerField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = 0 ;
  DataDictionary *arg2 = (DataDictionary *) 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FIX::Message::isTrailerField", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FIX::Message::isTrailerField", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "DataDictionary const *","FIX::Message::isTrailerField", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< DataDictionary * >(argp2);
  result = (bool)FIX::Message::isTrailerField((FIX::FieldBase const &)*arg1,(DataDictionary const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_isTrailerField__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::FieldBase *arg1 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__FieldBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FieldBase const &","FIX::Message::isTrailerField", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::FieldBase const &","FIX::Message::isTrailerField", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::FieldBase * >(argp1);
  result = (bool)FIX::Message::isTrailerField((FIX::FieldBase const &)*arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_isTrailerField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_isTrailerField__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_Message_isTrailerField__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FieldBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_DataDictionary, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_isTrailerField__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Message.isTrailerField", 
    "    bool Message.isTrailerField(int field)\n"
    "    bool Message.isTrailerField(FIX::FieldBase const &field, DataDictionary const *pD)\n"
    "    bool Message.isTrailerField(FIX::FieldBase const &field)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getSessionID__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string *arg2 = 0 ;
  SessionID result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","getSessionID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSessionID", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSessionID", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  try {
    result = (arg1)->getSessionID((std::string const &)*arg2);
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new SessionID(static_cast< const SessionID& >(result))), SWIGTYPE_p_SessionID, SWIG_POINTER_OWN |  0 );
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_getSessionID__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  SessionID result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","getSessionID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  try {
    result = (arg1)->getSessionID();
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new SessionID(static_cast< const SessionID& >(result))), SWIGTYPE_p_SessionID, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Message_getSessionID(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Message_getSessionID__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Message_getSessionID__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Message.getSessionID", 
    "    SessionID Message.getSessionID(std::string const &qualifier)\n"
    "    SessionID Message.getSessionID()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message_setSessionID(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","setSessionID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SessionID const &","setSessionID", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SessionID const &","setSessionID", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< SessionID * >(argp2);
  (arg1)->setSessionID((SessionID const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Message___str__(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = (FIX::Message *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Message, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message *","__str__", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  result = FIX_Message___str__(arg1);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_Message(FIX::Message *arg1) {
    delete arg1;
}


/*
  Document-method: Quickfix::FIX.<<

  call-seq:
    <<(stream, field) -> std::ostream
    <<(stream, message) -> std::ostream
    <<(stream, sessionID) -> std::ostream
    <<(?, ?) -> std::ostream

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  FIX::Message *arg2 = 0 ;
  std::ostream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","FIX::operator <<", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","FIX::operator <<", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","FIX::operator <<", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","FIX::operator <<", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  {
    std::ostream &_result_ref = FIX::operator <<(*arg1,(FIX::Message const &)*arg2);
    result = (std::ostream *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_identifyType(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  MsgType result;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::identifyType", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::identifyType", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  try {
    result = FIX::identifyType((std::string const &)*arg1);
  }
  catch(FIX::MessageParseError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__MessageParseError, SWIG_NewPointerObj((new FIX::MessageParseError(static_cast< const FIX::MessageParseError& >(_e))),SWIGTYPE_p_FIX__MessageParseError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new MsgType(static_cast< const MsgType& >(result))), SWIGTYPE_p_MsgType, SWIG_POINTER_OWN |  0 );
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


swig_class cGroup;

SWIGINTERN VALUE
_wrap_new_Group__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  FIX::Group *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Group";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::Group", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::Group", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (FIX::Group *)new FIX::Group(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Group__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int *arg3 ;
  FIX::Group *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Group";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::Group", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::Group", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "int const []","FIX::Group", 3, argv[2] )); 
  } 
  arg3 = reinterpret_cast< int * >(argp3);
  result = (FIX::Group *)new FIX::Group(arg1,arg2,(int const (*))arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Group__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  message_order *arg3 = 0 ;
  FIX::Group *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Group";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","FIX::Group", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","FIX::Group", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_message_order,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "message_order const &","FIX::Group", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "message_order const &","FIX::Group", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< message_order * >(argp3);
  result = (FIX::Group *)new FIX::Group(arg1,arg2,(message_order const &)*arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Group_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Group_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Group);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Group__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = 0 ;
  FIX::Group *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Group";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group const &","FIX::Group", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","FIX::Group", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  result = (FIX::Group *)new FIX::Group((FIX::Group const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Group(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Group, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Group__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Group__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_message_order, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_Group__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_int, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_Group__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Group.new", 
    "    Group.new(int field, int delim)\n"
    "    Group.new(int field, int delim, int const order[])\n"
    "    Group.new(int field, int delim, message_order const &order)\n"
    "    Group.new(FIX::Group const &copy)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_field(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group const *","field", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  result = (int)((FIX::Group const *)arg1)->field();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_delim(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group const *","delim", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  result = (int)((FIX::Group const *)arg1)->delim();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_addGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group &","addGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","addGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  (arg1)->addGroup(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_replaceGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","replaceGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","replaceGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","replaceGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","replaceGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  (arg1)->replaceGroup(arg2,*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_getGroup(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  FIX::Group *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group const *","getGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","getGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","getGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  try {
    {
      FIX::Group &_result_ref = ((FIX::Group const *)arg1)->getGroup(arg2,*arg3);
      result = (FIX::Group *) &_result_ref;
    }
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Group, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_removeGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","removeGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","removeGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  (arg1)->removeGroup(arg2,*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_removeGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  FIX::Group *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","removeGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group &","removeGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","removeGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  (arg1)->removeGroup(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Group_removeGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Group, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Group_removeGroup__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Group, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Group_removeGroup__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Group.removeGroup", 
    "    void Group.removeGroup(unsigned int num, FIX::Group &group)\n"
    "    void Group.removeGroup(FIX::Group &group)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_hasGroup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  FIX::Group *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Group const &","hasGroup", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group const &","hasGroup", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Group * >(argp2);
  result = (bool)(arg1)->hasGroup((FIX::Group const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Group_hasGroup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Group *arg1 = (FIX::Group *) 0 ;
  unsigned int arg2 ;
  FIX::Group *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Group, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Group *","hasGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Group * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","hasGroup", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Group,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Group &","hasGroup", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Group &","hasGroup", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::Group * >(argp3);
  result = (bool)(arg1)->hasGroup(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Group_hasGroup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Group, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Group, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Group_hasGroup__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Group, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Group, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Group_hasGroup__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Group.hasGroup", 
    "    bool Group.hasGroup(FIX::Group const &group)\n"
    "    bool Group.hasGroup(unsigned int num, FIX::Group &group)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_Group(FIX::Group *arg1) {
    delete arg1;
}

swig_class cExecTransType;

SWIGINTERN VALUE
_wrap_new_ExecTransType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::ExecTransType *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ExecTransType";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::ExecTransType *)new FIX::ExecTransType();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ExecTransType_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ExecTransType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ExecTransType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ExecTransType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_CHAR *arg1 = 0 ;
  FIX::ExecTransType *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ExecTransType";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_CHAR,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_CHAR const &","FIX::ExecTransType", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_CHAR const &","FIX::ExecTransType", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_CHAR * >(argp1);
  result = (FIX::ExecTransType *)new FIX::ExecTransType((FIX_CHAR const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ExecTransType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ExecTransType__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_CHAR, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ExecTransType__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ExecTransType.new", 
    "    ExecTransType.new()\n"
    "    ExecTransType.new(FIX_CHAR const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_ExecTransType(FIX::ExecTransType *arg1) {
    delete arg1;
}

swig_class cIDSource;

SWIGINTERN VALUE
_wrap_new_IDSource__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::IDSource *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IDSource";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::IDSource *)new FIX::IDSource();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_IDSource_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_IDSource_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IDSource);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_IDSource__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::IDSource *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IDSource";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::IDSource", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::IDSource", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::IDSource *)new FIX::IDSource((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IDSource(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IDSource__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_IDSource__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "IDSource.new", 
    "    IDSource.new()\n"
    "    IDSource.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_IDSource(FIX::IDSource *arg1) {
    delete arg1;
}

swig_class cIOIOthSvc;

SWIGINTERN VALUE
_wrap_new_IOIOthSvc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::IOIOthSvc *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IOIOthSvc";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::IOIOthSvc *)new FIX::IOIOthSvc();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_IOIOthSvc_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_IOIOthSvc_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IOIOthSvc);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_IOIOthSvc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_CHAR *arg1 = 0 ;
  FIX::IOIOthSvc *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IOIOthSvc";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_CHAR,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_CHAR const &","FIX::IOIOthSvc", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_CHAR const &","FIX::IOIOthSvc", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_CHAR * >(argp1);
  result = (FIX::IOIOthSvc *)new FIX::IOIOthSvc((FIX_CHAR const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IOIOthSvc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IOIOthSvc__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_CHAR, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_IOIOthSvc__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "IOIOthSvc.new", 
    "    IOIOthSvc.new()\n"
    "    IOIOthSvc.new(FIX_CHAR const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_IOIOthSvc(FIX::IOIOthSvc *arg1) {
    delete arg1;
}

swig_class cIOIShares;

SWIGINTERN VALUE
_wrap_new_IOIShares__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::IOIShares *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IOIShares";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::IOIShares *)new FIX::IOIShares();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_IOIShares_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_IOIShares_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__IOIShares);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_IOIShares__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::IOIShares *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::IOIShares";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::IOIShares", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::IOIShares", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::IOIShares *)new FIX::IOIShares((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_IOIShares(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_IOIShares__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_IOIShares__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "IOIShares.new", 
    "    IOIShares.new()\n"
    "    IOIShares.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_IOIShares(FIX::IOIShares *arg1) {
    delete arg1;
}

swig_class cLastShares;

SWIGINTERN VALUE
_wrap_new_LastShares__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::LastShares *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LastShares";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::LastShares *)new FIX::LastShares();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_LastShares_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_LastShares_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__LastShares);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_LastShares__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_QTY *arg1 = 0 ;
  FIX::LastShares *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LastShares";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_QTY,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_QTY const &","FIX::LastShares", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_QTY const &","FIX::LastShares", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_QTY * >(argp1);
  result = (FIX::LastShares *)new FIX::LastShares((FIX_QTY const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_LastShares(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_LastShares__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_QTY, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LastShares__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "LastShares.new", 
    "    LastShares.new()\n"
    "    LastShares.new(FIX_QTY const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_LastShares(FIX::LastShares *arg1) {
    delete arg1;
}

swig_class cRelatdSym;

SWIGINTERN VALUE
_wrap_new_RelatdSym__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::RelatdSym *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RelatdSym";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::RelatdSym *)new FIX::RelatdSym();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RelatdSym_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RelatdSym_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RelatdSym);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RelatdSym__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::RelatdSym *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RelatdSym";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::RelatdSym", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::RelatdSym", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::RelatdSym *)new FIX::RelatdSym((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RelatdSym(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RelatdSym__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RelatdSym__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "RelatdSym.new", 
    "    RelatdSym.new()\n"
    "    RelatdSym.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_RelatdSym(FIX::RelatdSym *arg1) {
    delete arg1;
}

swig_class cRule80A;

SWIGINTERN VALUE
_wrap_new_Rule80A__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Rule80A *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Rule80A";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::Rule80A *)new FIX::Rule80A();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Rule80A_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Rule80A_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Rule80A);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Rule80A__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_CHAR *arg1 = 0 ;
  FIX::Rule80A *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Rule80A";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_CHAR,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_CHAR const &","FIX::Rule80A", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_CHAR const &","FIX::Rule80A", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_CHAR * >(argp1);
  result = (FIX::Rule80A *)new FIX::Rule80A((FIX_CHAR const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Rule80A(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Rule80A__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_CHAR, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Rule80A__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "Rule80A.new", 
    "    Rule80A.new()\n"
    "    Rule80A.new(FIX_CHAR const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_Rule80A(FIX::Rule80A *arg1) {
    delete arg1;
}

swig_class cShares;

SWIGINTERN VALUE
_wrap_new_Shares__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Shares *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Shares";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::Shares *)new FIX::Shares();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Shares_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Shares_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Shares);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Shares__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_QTY *arg1 = 0 ;
  FIX::Shares *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Shares";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_QTY,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_QTY const &","FIX::Shares", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_QTY const &","FIX::Shares", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_QTY * >(argp1);
  result = (FIX::Shares *)new FIX::Shares((FIX_QTY const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Shares(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Shares__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_QTY, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Shares__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "Shares.new", 
    "    Shares.new()\n"
    "    Shares.new(FIX_QTY const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_Shares(FIX::Shares *arg1) {
    delete arg1;
}

swig_class cSettlmntTyp;

SWIGINTERN VALUE
_wrap_new_SettlmntTyp__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SettlmntTyp *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SettlmntTyp";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SettlmntTyp *)new FIX::SettlmntTyp();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SettlmntTyp_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SettlmntTyp_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SettlmntTyp);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SettlmntTyp__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_CHAR *arg1 = 0 ;
  FIX::SettlmntTyp *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SettlmntTyp";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_CHAR,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_CHAR const &","FIX::SettlmntTyp", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_CHAR const &","FIX::SettlmntTyp", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_CHAR * >(argp1);
  result = (FIX::SettlmntTyp *)new FIX::SettlmntTyp((FIX_CHAR const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SettlmntTyp(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SettlmntTyp__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_CHAR, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SettlmntTyp__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SettlmntTyp.new", 
    "    SettlmntTyp.new()\n"
    "    SettlmntTyp.new(FIX_CHAR const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SettlmntTyp(FIX::SettlmntTyp *arg1) {
    delete arg1;
}

swig_class cFutSettDate;

SWIGINTERN VALUE
_wrap_new_FutSettDate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FutSettDate *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FutSettDate";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::FutSettDate *)new FIX::FutSettDate();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FutSettDate_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FutSettDate_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FutSettDate);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FutSettDate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_LOCALMKTDATE *arg1 = 0 ;
  FIX::FutSettDate *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FutSettDate";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_LOCALMKTDATE,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_LOCALMKTDATE const &","FIX::FutSettDate", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_LOCALMKTDATE const &","FIX::FutSettDate", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_LOCALMKTDATE * >(argp1);
  result = (FIX::FutSettDate *)new FIX::FutSettDate((FIX_LOCALMKTDATE const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FutSettDate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_FutSettDate__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_LOCALMKTDATE, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FutSettDate__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "FutSettDate.new", 
    "    FutSettDate.new()\n"
    "    FutSettDate.new(FIX_LOCALMKTDATE const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_FutSettDate(FIX::FutSettDate *arg1) {
    delete arg1;
}

swig_class cAvgPrxPrecision;

SWIGINTERN VALUE
_wrap_new_AvgPrxPrecision__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::AvgPrxPrecision *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::AvgPrxPrecision";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::AvgPrxPrecision *)new FIX::AvgPrxPrecision();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_AvgPrxPrecision_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_AvgPrxPrecision_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__AvgPrxPrecision);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_AvgPrxPrecision__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_INT *arg1 = 0 ;
  FIX::AvgPrxPrecision *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::AvgPrxPrecision";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_INT,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_INT const &","FIX::AvgPrxPrecision", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_INT const &","FIX::AvgPrxPrecision", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_INT * >(argp1);
  result = (FIX::AvgPrxPrecision *)new FIX::AvgPrxPrecision((FIX_INT const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_AvgPrxPrecision(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_AvgPrxPrecision__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_INT, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AvgPrxPrecision__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "AvgPrxPrecision.new", 
    "    AvgPrxPrecision.new()\n"
    "    AvgPrxPrecision.new(FIX_INT const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_AvgPrxPrecision(FIX::AvgPrxPrecision *arg1) {
    delete arg1;
}

swig_class cExecBroker;

SWIGINTERN VALUE
_wrap_new_ExecBroker__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::ExecBroker *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ExecBroker";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::ExecBroker *)new FIX::ExecBroker();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ExecBroker_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ExecBroker_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ExecBroker);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ExecBroker__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::ExecBroker *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ExecBroker";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::ExecBroker", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::ExecBroker", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::ExecBroker *)new FIX::ExecBroker((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ExecBroker(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ExecBroker__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ExecBroker__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ExecBroker.new", 
    "    ExecBroker.new()\n"
    "    ExecBroker.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_ExecBroker(FIX::ExecBroker *arg1) {
    delete arg1;
}

swig_class cOpenClose;

SWIGINTERN VALUE
_wrap_new_OpenClose__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::OpenClose *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::OpenClose";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::OpenClose *)new FIX::OpenClose();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OpenClose_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OpenClose_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__OpenClose);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OpenClose__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_CHAR *arg1 = 0 ;
  FIX::OpenClose *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::OpenClose";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_CHAR,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_CHAR const &","FIX::OpenClose", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_CHAR const &","FIX::OpenClose", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_CHAR * >(argp1);
  result = (FIX::OpenClose *)new FIX::OpenClose((FIX_CHAR const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OpenClose(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OpenClose__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_CHAR, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OpenClose__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "OpenClose.new", 
    "    OpenClose.new()\n"
    "    OpenClose.new(FIX_CHAR const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_OpenClose(FIX::OpenClose *arg1) {
    delete arg1;
}

swig_class cAllocShares;

SWIGINTERN VALUE
_wrap_new_AllocShares__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::AllocShares *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::AllocShares";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::AllocShares *)new FIX::AllocShares();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_AllocShares_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_AllocShares_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__AllocShares);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_AllocShares__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_INT *arg1 = 0 ;
  FIX::AllocShares *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::AllocShares";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_INT,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_INT const &","FIX::AllocShares", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_INT const &","FIX::AllocShares", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_INT * >(argp1);
  result = (FIX::AllocShares *)new FIX::AllocShares((FIX_INT const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_AllocShares(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_AllocShares__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_INT, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AllocShares__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "AllocShares.new", 
    "    AllocShares.new()\n"
    "    AllocShares.new(FIX_INT const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_AllocShares(FIX::AllocShares *arg1) {
    delete arg1;
}

swig_class cDlvyInst;

SWIGINTERN VALUE
_wrap_new_DlvyInst__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DlvyInst *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DlvyInst";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::DlvyInst *)new FIX::DlvyInst();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DlvyInst_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DlvyInst_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DlvyInst);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DlvyInst__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_CHAR *arg1 = 0 ;
  FIX::DlvyInst *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DlvyInst";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_CHAR,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_CHAR const &","FIX::DlvyInst", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_CHAR const &","FIX::DlvyInst", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_CHAR * >(argp1);
  result = (FIX::DlvyInst *)new FIX::DlvyInst((FIX_CHAR const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DlvyInst(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_DlvyInst__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_CHAR, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DlvyInst__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "DlvyInst.new", 
    "    DlvyInst.new()\n"
    "    DlvyInst.new(FIX_CHAR const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_DlvyInst(FIX::DlvyInst *arg1) {
    delete arg1;
}

swig_class cBrokerOfCredit;

SWIGINTERN VALUE
_wrap_new_BrokerOfCredit__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::BrokerOfCredit *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::BrokerOfCredit";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::BrokerOfCredit *)new FIX::BrokerOfCredit();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_BrokerOfCredit_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_BrokerOfCredit_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__BrokerOfCredit);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_BrokerOfCredit__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::BrokerOfCredit *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::BrokerOfCredit";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::BrokerOfCredit", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::BrokerOfCredit", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::BrokerOfCredit *)new FIX::BrokerOfCredit((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_BrokerOfCredit(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_BrokerOfCredit__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_BrokerOfCredit__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "BrokerOfCredit.new", 
    "    BrokerOfCredit.new()\n"
    "    BrokerOfCredit.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_BrokerOfCredit(FIX::BrokerOfCredit *arg1) {
    delete arg1;
}

swig_class cClientID;

SWIGINTERN VALUE
_wrap_new_ClientID__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::ClientID *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ClientID";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::ClientID *)new FIX::ClientID();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ClientID_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ClientID_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ClientID);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ClientID__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::ClientID *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ClientID";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::ClientID", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::ClientID", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::ClientID *)new FIX::ClientID((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ClientID(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ClientID__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ClientID__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ClientID.new", 
    "    ClientID.new()\n"
    "    ClientID.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_ClientID(FIX::ClientID *arg1) {
    delete arg1;
}

swig_class cCxlType;

SWIGINTERN VALUE
_wrap_new_CxlType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::CxlType *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CxlType";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::CxlType *)new FIX::CxlType();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CxlType_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CxlType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CxlType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CxlType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_CHAR *arg1 = 0 ;
  FIX::CxlType *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CxlType";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_CHAR,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_CHAR const &","FIX::CxlType", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_CHAR const &","FIX::CxlType", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_CHAR * >(argp1);
  result = (FIX::CxlType *)new FIX::CxlType((FIX_CHAR const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CxlType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_CxlType__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_CHAR, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CxlType__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "CxlType.new", 
    "    CxlType.new()\n"
    "    CxlType.new(FIX_CHAR const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_CxlType(FIX::CxlType *arg1) {
    delete arg1;
}

swig_class cSettlLocation;

SWIGINTERN VALUE
_wrap_new_SettlLocation__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SettlLocation *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SettlLocation";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SettlLocation *)new FIX::SettlLocation();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SettlLocation_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SettlLocation_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SettlLocation);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SettlLocation__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::SettlLocation *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SettlLocation";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::SettlLocation", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::SettlLocation", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::SettlLocation *)new FIX::SettlLocation((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SettlLocation(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SettlLocation__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SettlLocation__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SettlLocation.new", 
    "    SettlLocation.new()\n"
    "    SettlLocation.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SettlLocation(FIX::SettlLocation *arg1) {
    delete arg1;
}

swig_class cSettlDepositoryCode;

SWIGINTERN VALUE
_wrap_new_SettlDepositoryCode__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SettlDepositoryCode *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SettlDepositoryCode";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SettlDepositoryCode *)new FIX::SettlDepositoryCode();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SettlDepositoryCode_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SettlDepositoryCode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SettlDepositoryCode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SettlDepositoryCode__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::SettlDepositoryCode *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SettlDepositoryCode";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::SettlDepositoryCode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::SettlDepositoryCode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::SettlDepositoryCode *)new FIX::SettlDepositoryCode((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SettlDepositoryCode(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SettlDepositoryCode__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SettlDepositoryCode__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SettlDepositoryCode.new", 
    "    SettlDepositoryCode.new()\n"
    "    SettlDepositoryCode.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SettlDepositoryCode(FIX::SettlDepositoryCode *arg1) {
    delete arg1;
}

swig_class cSettlBrkrCode;

SWIGINTERN VALUE
_wrap_new_SettlBrkrCode__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SettlBrkrCode *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SettlBrkrCode";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SettlBrkrCode *)new FIX::SettlBrkrCode();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SettlBrkrCode_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SettlBrkrCode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SettlBrkrCode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SettlBrkrCode__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::SettlBrkrCode *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SettlBrkrCode";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::SettlBrkrCode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::SettlBrkrCode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::SettlBrkrCode *)new FIX::SettlBrkrCode((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SettlBrkrCode(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SettlBrkrCode__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SettlBrkrCode__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SettlBrkrCode.new", 
    "    SettlBrkrCode.new()\n"
    "    SettlBrkrCode.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SettlBrkrCode(FIX::SettlBrkrCode *arg1) {
    delete arg1;
}

swig_class cSettlInstCode;

SWIGINTERN VALUE
_wrap_new_SettlInstCode__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SettlInstCode *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SettlInstCode";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SettlInstCode *)new FIX::SettlInstCode();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SettlInstCode_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SettlInstCode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SettlInstCode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SettlInstCode__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::SettlInstCode *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SettlInstCode";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::SettlInstCode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::SettlInstCode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::SettlInstCode *)new FIX::SettlInstCode((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SettlInstCode(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SettlInstCode__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SettlInstCode__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SettlInstCode.new", 
    "    SettlInstCode.new()\n"
    "    SettlInstCode.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SettlInstCode(FIX::SettlInstCode *arg1) {
    delete arg1;
}

swig_class cSecuritySettlAgentName;

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentName__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SecuritySettlAgentName *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentName";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SecuritySettlAgentName *)new FIX::SecuritySettlAgentName();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SecuritySettlAgentName_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SecuritySettlAgentName_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SecuritySettlAgentName);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentName__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::SecuritySettlAgentName *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentName";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::SecuritySettlAgentName", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::SecuritySettlAgentName", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::SecuritySettlAgentName *)new FIX::SecuritySettlAgentName((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SecuritySettlAgentName(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SecuritySettlAgentName__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SecuritySettlAgentName__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SecuritySettlAgentName.new", 
    "    SecuritySettlAgentName.new()\n"
    "    SecuritySettlAgentName.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SecuritySettlAgentName(FIX::SecuritySettlAgentName *arg1) {
    delete arg1;
}

swig_class cSecuritySettlAgentCode;

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentCode__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SecuritySettlAgentCode *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentCode";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SecuritySettlAgentCode *)new FIX::SecuritySettlAgentCode();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SecuritySettlAgentCode_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SecuritySettlAgentCode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SecuritySettlAgentCode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentCode__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::SecuritySettlAgentCode *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentCode";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::SecuritySettlAgentCode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::SecuritySettlAgentCode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::SecuritySettlAgentCode *)new FIX::SecuritySettlAgentCode((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SecuritySettlAgentCode(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SecuritySettlAgentCode__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SecuritySettlAgentCode__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SecuritySettlAgentCode.new", 
    "    SecuritySettlAgentCode.new()\n"
    "    SecuritySettlAgentCode.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SecuritySettlAgentCode(FIX::SecuritySettlAgentCode *arg1) {
    delete arg1;
}

swig_class cSecuritySettlAgentAcctNum;

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentAcctNum__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SecuritySettlAgentAcctNum *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentAcctNum";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SecuritySettlAgentAcctNum *)new FIX::SecuritySettlAgentAcctNum();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SecuritySettlAgentAcctNum_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SecuritySettlAgentAcctNum_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SecuritySettlAgentAcctNum);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentAcctNum__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::SecuritySettlAgentAcctNum *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentAcctNum";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::SecuritySettlAgentAcctNum", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::SecuritySettlAgentAcctNum", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::SecuritySettlAgentAcctNum *)new FIX::SecuritySettlAgentAcctNum((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SecuritySettlAgentAcctNum(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SecuritySettlAgentAcctNum__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SecuritySettlAgentAcctNum__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SecuritySettlAgentAcctNum.new", 
    "    SecuritySettlAgentAcctNum.new()\n"
    "    SecuritySettlAgentAcctNum.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SecuritySettlAgentAcctNum(FIX::SecuritySettlAgentAcctNum *arg1) {
    delete arg1;
}

swig_class cSecuritySettlAgentAcctName;

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentAcctName__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SecuritySettlAgentAcctName *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentAcctName";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SecuritySettlAgentAcctName *)new FIX::SecuritySettlAgentAcctName();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SecuritySettlAgentAcctName_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SecuritySettlAgentAcctName_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SecuritySettlAgentAcctName);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentAcctName__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::SecuritySettlAgentAcctName *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentAcctName";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::SecuritySettlAgentAcctName", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::SecuritySettlAgentAcctName", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::SecuritySettlAgentAcctName *)new FIX::SecuritySettlAgentAcctName((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SecuritySettlAgentAcctName(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SecuritySettlAgentAcctName__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SecuritySettlAgentAcctName__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SecuritySettlAgentAcctName.new", 
    "    SecuritySettlAgentAcctName.new()\n"
    "    SecuritySettlAgentAcctName.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SecuritySettlAgentAcctName(FIX::SecuritySettlAgentAcctName *arg1) {
    delete arg1;
}

swig_class cSecuritySettlAgentContactName;

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentContactName__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SecuritySettlAgentContactName *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentContactName";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SecuritySettlAgentContactName *)new FIX::SecuritySettlAgentContactName();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SecuritySettlAgentContactName_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SecuritySettlAgentContactName_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SecuritySettlAgentContactName);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentContactName__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::SecuritySettlAgentContactName *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentContactName";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::SecuritySettlAgentContactName", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::SecuritySettlAgentContactName", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::SecuritySettlAgentContactName *)new FIX::SecuritySettlAgentContactName((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SecuritySettlAgentContactName(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SecuritySettlAgentContactName__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SecuritySettlAgentContactName__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SecuritySettlAgentContactName.new", 
    "    SecuritySettlAgentContactName.new()\n"
    "    SecuritySettlAgentContactName.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SecuritySettlAgentContactName(FIX::SecuritySettlAgentContactName *arg1) {
    delete arg1;
}

swig_class cSecuritySettlAgentContactPhone;

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentContactPhone__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SecuritySettlAgentContactPhone *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentContactPhone";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SecuritySettlAgentContactPhone *)new FIX::SecuritySettlAgentContactPhone();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SecuritySettlAgentContactPhone_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SecuritySettlAgentContactPhone_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SecuritySettlAgentContactPhone);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SecuritySettlAgentContactPhone__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::SecuritySettlAgentContactPhone *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SecuritySettlAgentContactPhone";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::SecuritySettlAgentContactPhone", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::SecuritySettlAgentContactPhone", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::SecuritySettlAgentContactPhone *)new FIX::SecuritySettlAgentContactPhone((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SecuritySettlAgentContactPhone(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SecuritySettlAgentContactPhone__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SecuritySettlAgentContactPhone__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SecuritySettlAgentContactPhone.new", 
    "    SecuritySettlAgentContactPhone.new()\n"
    "    SecuritySettlAgentContactPhone.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SecuritySettlAgentContactPhone(FIX::SecuritySettlAgentContactPhone *arg1) {
    delete arg1;
}

swig_class cCashSettlAgentName;

SWIGINTERN VALUE
_wrap_new_CashSettlAgentName__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::CashSettlAgentName *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentName";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::CashSettlAgentName *)new FIX::CashSettlAgentName();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CashSettlAgentName_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CashSettlAgentName_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CashSettlAgentName);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CashSettlAgentName__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::CashSettlAgentName *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentName";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::CashSettlAgentName", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::CashSettlAgentName", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::CashSettlAgentName *)new FIX::CashSettlAgentName((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CashSettlAgentName(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_CashSettlAgentName__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CashSettlAgentName__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "CashSettlAgentName.new", 
    "    CashSettlAgentName.new()\n"
    "    CashSettlAgentName.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_CashSettlAgentName(FIX::CashSettlAgentName *arg1) {
    delete arg1;
}

swig_class cCashSettlAgentCode;

SWIGINTERN VALUE
_wrap_new_CashSettlAgentCode__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::CashSettlAgentCode *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentCode";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::CashSettlAgentCode *)new FIX::CashSettlAgentCode();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CashSettlAgentCode_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CashSettlAgentCode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CashSettlAgentCode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CashSettlAgentCode__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::CashSettlAgentCode *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentCode";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::CashSettlAgentCode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::CashSettlAgentCode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::CashSettlAgentCode *)new FIX::CashSettlAgentCode((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CashSettlAgentCode(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_CashSettlAgentCode__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CashSettlAgentCode__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "CashSettlAgentCode.new", 
    "    CashSettlAgentCode.new()\n"
    "    CashSettlAgentCode.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_CashSettlAgentCode(FIX::CashSettlAgentCode *arg1) {
    delete arg1;
}

swig_class cCashSettlAgentAcctNum;

SWIGINTERN VALUE
_wrap_new_CashSettlAgentAcctNum__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::CashSettlAgentAcctNum *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentAcctNum";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::CashSettlAgentAcctNum *)new FIX::CashSettlAgentAcctNum();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CashSettlAgentAcctNum_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CashSettlAgentAcctNum_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CashSettlAgentAcctNum);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CashSettlAgentAcctNum__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::CashSettlAgentAcctNum *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentAcctNum";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::CashSettlAgentAcctNum", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::CashSettlAgentAcctNum", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::CashSettlAgentAcctNum *)new FIX::CashSettlAgentAcctNum((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CashSettlAgentAcctNum(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_CashSettlAgentAcctNum__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CashSettlAgentAcctNum__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "CashSettlAgentAcctNum.new", 
    "    CashSettlAgentAcctNum.new()\n"
    "    CashSettlAgentAcctNum.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_CashSettlAgentAcctNum(FIX::CashSettlAgentAcctNum *arg1) {
    delete arg1;
}

swig_class cCashSettlAgentAcctName;

SWIGINTERN VALUE
_wrap_new_CashSettlAgentAcctName__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::CashSettlAgentAcctName *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentAcctName";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::CashSettlAgentAcctName *)new FIX::CashSettlAgentAcctName();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CashSettlAgentAcctName_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CashSettlAgentAcctName_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CashSettlAgentAcctName);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CashSettlAgentAcctName__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::CashSettlAgentAcctName *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentAcctName";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::CashSettlAgentAcctName", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::CashSettlAgentAcctName", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::CashSettlAgentAcctName *)new FIX::CashSettlAgentAcctName((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CashSettlAgentAcctName(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_CashSettlAgentAcctName__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CashSettlAgentAcctName__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "CashSettlAgentAcctName.new", 
    "    CashSettlAgentAcctName.new()\n"
    "    CashSettlAgentAcctName.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_CashSettlAgentAcctName(FIX::CashSettlAgentAcctName *arg1) {
    delete arg1;
}

swig_class cCashSettlAgentContactName;

SWIGINTERN VALUE
_wrap_new_CashSettlAgentContactName__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::CashSettlAgentContactName *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentContactName";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::CashSettlAgentContactName *)new FIX::CashSettlAgentContactName();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CashSettlAgentContactName_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CashSettlAgentContactName_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CashSettlAgentContactName);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CashSettlAgentContactName__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::CashSettlAgentContactName *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentContactName";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::CashSettlAgentContactName", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::CashSettlAgentContactName", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::CashSettlAgentContactName *)new FIX::CashSettlAgentContactName((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CashSettlAgentContactName(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_CashSettlAgentContactName__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CashSettlAgentContactName__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "CashSettlAgentContactName.new", 
    "    CashSettlAgentContactName.new()\n"
    "    CashSettlAgentContactName.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_CashSettlAgentContactName(FIX::CashSettlAgentContactName *arg1) {
    delete arg1;
}

swig_class cCashSettlAgentContactPhone;

SWIGINTERN VALUE
_wrap_new_CashSettlAgentContactPhone__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::CashSettlAgentContactPhone *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentContactPhone";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::CashSettlAgentContactPhone *)new FIX::CashSettlAgentContactPhone();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CashSettlAgentContactPhone_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CashSettlAgentContactPhone_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CashSettlAgentContactPhone);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CashSettlAgentContactPhone__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::CashSettlAgentContactPhone *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CashSettlAgentContactPhone";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::CashSettlAgentContactPhone", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::CashSettlAgentContactPhone", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::CashSettlAgentContactPhone *)new FIX::CashSettlAgentContactPhone((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CashSettlAgentContactPhone(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_CashSettlAgentContactPhone__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CashSettlAgentContactPhone__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "CashSettlAgentContactPhone.new", 
    "    CashSettlAgentContactPhone.new()\n"
    "    CashSettlAgentContactPhone.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_CashSettlAgentContactPhone(FIX::CashSettlAgentContactPhone *arg1) {
    delete arg1;
}

swig_class cFutSettDate2;

SWIGINTERN VALUE
_wrap_new_FutSettDate2__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FutSettDate2 *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FutSettDate2";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::FutSettDate2 *)new FIX::FutSettDate2();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FutSettDate2_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FutSettDate2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FutSettDate2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FutSettDate2__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_LOCALMKTDATE *arg1 = 0 ;
  FIX::FutSettDate2 *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FutSettDate2";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_LOCALMKTDATE,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_LOCALMKTDATE const &","FIX::FutSettDate2", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_LOCALMKTDATE const &","FIX::FutSettDate2", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_LOCALMKTDATE * >(argp1);
  result = (FIX::FutSettDate2 *)new FIX::FutSettDate2((FIX_LOCALMKTDATE const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FutSettDate2(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_FutSettDate2__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_LOCALMKTDATE, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FutSettDate2__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "FutSettDate2.new", 
    "    FutSettDate2.new()\n"
    "    FutSettDate2.new(FIX_LOCALMKTDATE const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_FutSettDate2(FIX::FutSettDate2 *arg1) {
    delete arg1;
}

swig_class cPutOrCall;

SWIGINTERN VALUE
_wrap_new_PutOrCall__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::PutOrCall *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PutOrCall";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::PutOrCall *)new FIX::PutOrCall();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_PutOrCall_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_PutOrCall_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__PutOrCall);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_PutOrCall__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_INT *arg1 = 0 ;
  FIX::PutOrCall *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PutOrCall";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_INT,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_INT const &","FIX::PutOrCall", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_INT const &","FIX::PutOrCall", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_INT * >(argp1);
  result = (FIX::PutOrCall *)new FIX::PutOrCall((FIX_INT const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_PutOrCall(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_PutOrCall__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_INT, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_PutOrCall__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "PutOrCall.new", 
    "    PutOrCall.new()\n"
    "    PutOrCall.new(FIX_INT const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_PutOrCall(FIX::PutOrCall *arg1) {
    delete arg1;
}

swig_class cCustomerOrFirm;

SWIGINTERN VALUE
_wrap_new_CustomerOrFirm__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::CustomerOrFirm *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CustomerOrFirm";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::CustomerOrFirm *)new FIX::CustomerOrFirm();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CustomerOrFirm_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CustomerOrFirm_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CustomerOrFirm);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CustomerOrFirm__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_INT *arg1 = 0 ;
  FIX::CustomerOrFirm *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CustomerOrFirm";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_INT,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_INT const &","FIX::CustomerOrFirm", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_INT const &","FIX::CustomerOrFirm", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_INT * >(argp1);
  result = (FIX::CustomerOrFirm *)new FIX::CustomerOrFirm((FIX_INT const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CustomerOrFirm(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_CustomerOrFirm__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_INT, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CustomerOrFirm__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "CustomerOrFirm.new", 
    "    CustomerOrFirm.new()\n"
    "    CustomerOrFirm.new(FIX_INT const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_CustomerOrFirm(FIX::CustomerOrFirm *arg1) {
    delete arg1;
}

swig_class cMaturityDay;

SWIGINTERN VALUE
_wrap_new_MaturityDay__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::MaturityDay *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MaturityDay";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::MaturityDay *)new FIX::MaturityDay();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MaturityDay_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MaturityDay_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MaturityDay);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MaturityDay__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_DAYOFMONTH *arg1 = 0 ;
  FIX::MaturityDay *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MaturityDay";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_DAYOFMONTH,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_DAYOFMONTH const &","FIX::MaturityDay", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_DAYOFMONTH const &","FIX::MaturityDay", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_DAYOFMONTH * >(argp1);
  result = (FIX::MaturityDay *)new FIX::MaturityDay((FIX_DAYOFMONTH const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_MaturityDay(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_MaturityDay__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_DAYOFMONTH, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MaturityDay__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "MaturityDay.new", 
    "    MaturityDay.new()\n"
    "    MaturityDay.new(FIX_DAYOFMONTH const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_MaturityDay(FIX::MaturityDay *arg1) {
    delete arg1;
}

swig_class cPegDifference;

SWIGINTERN VALUE
_wrap_new_PegDifference__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::PegDifference *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PegDifference";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::PegDifference *)new FIX::PegDifference();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_PegDifference_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_PegDifference_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__PegDifference);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_PegDifference__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_PRICEOFFSET *arg1 = 0 ;
  FIX::PegDifference *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::PegDifference";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_PRICEOFFSET,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_PRICEOFFSET const &","FIX::PegDifference", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_PRICEOFFSET const &","FIX::PegDifference", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_PRICEOFFSET * >(argp1);
  result = (FIX::PegDifference *)new FIX::PegDifference((FIX_PRICEOFFSET const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_PegDifference(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_PegDifference__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_PRICEOFFSET, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_PegDifference__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "PegDifference.new", 
    "    PegDifference.new()\n"
    "    PegDifference.new(FIX_PRICEOFFSET const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_PegDifference(FIX::PegDifference *arg1) {
    delete arg1;
}

swig_class cSpreadToBenchmark;

SWIGINTERN VALUE
_wrap_new_SpreadToBenchmark__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SpreadToBenchmark *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SpreadToBenchmark";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SpreadToBenchmark *)new FIX::SpreadToBenchmark();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SpreadToBenchmark_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SpreadToBenchmark_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SpreadToBenchmark);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SpreadToBenchmark__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_PRICEOFFSET *arg1 = 0 ;
  FIX::SpreadToBenchmark *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SpreadToBenchmark";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_PRICEOFFSET,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_PRICEOFFSET const &","FIX::SpreadToBenchmark", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_PRICEOFFSET const &","FIX::SpreadToBenchmark", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_PRICEOFFSET * >(argp1);
  result = (FIX::SpreadToBenchmark *)new FIX::SpreadToBenchmark((FIX_PRICEOFFSET const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SpreadToBenchmark(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SpreadToBenchmark__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_PRICEOFFSET, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpreadToBenchmark__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SpreadToBenchmark.new", 
    "    SpreadToBenchmark.new()\n"
    "    SpreadToBenchmark.new(FIX_PRICEOFFSET const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SpreadToBenchmark(FIX::SpreadToBenchmark *arg1) {
    delete arg1;
}

swig_class cBenchmark;

SWIGINTERN VALUE
_wrap_new_Benchmark__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Benchmark *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Benchmark";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::Benchmark *)new FIX::Benchmark();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Benchmark_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Benchmark_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Benchmark);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Benchmark__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_CHAR *arg1 = 0 ;
  FIX::Benchmark *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Benchmark";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_CHAR,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_CHAR const &","FIX::Benchmark", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_CHAR const &","FIX::Benchmark", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_CHAR * >(argp1);
  result = (FIX::Benchmark *)new FIX::Benchmark((FIX_CHAR const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Benchmark(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Benchmark__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_CHAR, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Benchmark__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "Benchmark.new", 
    "    Benchmark.new()\n"
    "    Benchmark.new(FIX_CHAR const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_Benchmark(FIX::Benchmark *arg1) {
    delete arg1;
}

swig_class cOpenCloseSettleFlag;

SWIGINTERN VALUE
_wrap_new_OpenCloseSettleFlag__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::OpenCloseSettleFlag *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::OpenCloseSettleFlag";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::OpenCloseSettleFlag *)new FIX::OpenCloseSettleFlag();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OpenCloseSettleFlag_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__OpenCloseSettleFlag);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OpenCloseSettleFlag__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::OpenCloseSettleFlag *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::OpenCloseSettleFlag";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::OpenCloseSettleFlag", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::OpenCloseSettleFlag", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::OpenCloseSettleFlag *)new FIX::OpenCloseSettleFlag((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OpenCloseSettleFlag(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OpenCloseSettleFlag__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OpenCloseSettleFlag__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "OpenCloseSettleFlag.new", 
    "    OpenCloseSettleFlag.new()\n"
    "    OpenCloseSettleFlag.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_OpenCloseSettleFlag(FIX::OpenCloseSettleFlag *arg1) {
    delete arg1;
}

swig_class cUnderlyingIDSource;

SWIGINTERN VALUE
_wrap_new_UnderlyingIDSource__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::UnderlyingIDSource *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UnderlyingIDSource";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::UnderlyingIDSource *)new FIX::UnderlyingIDSource();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_UnderlyingIDSource_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_UnderlyingIDSource_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UnderlyingIDSource);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_UnderlyingIDSource__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::UnderlyingIDSource *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UnderlyingIDSource";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::UnderlyingIDSource", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::UnderlyingIDSource", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::UnderlyingIDSource *)new FIX::UnderlyingIDSource((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UnderlyingIDSource(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_UnderlyingIDSource__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnderlyingIDSource__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "UnderlyingIDSource.new", 
    "    UnderlyingIDSource.new()\n"
    "    UnderlyingIDSource.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_UnderlyingIDSource(FIX::UnderlyingIDSource *arg1) {
    delete arg1;
}

swig_class cQuoteAckStatus;

SWIGINTERN VALUE
_wrap_new_QuoteAckStatus__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::QuoteAckStatus *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::QuoteAckStatus";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::QuoteAckStatus *)new FIX::QuoteAckStatus();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_QuoteAckStatus_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_QuoteAckStatus_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__QuoteAckStatus);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_QuoteAckStatus__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_INT *arg1 = 0 ;
  FIX::QuoteAckStatus *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::QuoteAckStatus";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_INT,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_INT const &","FIX::QuoteAckStatus", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_INT const &","FIX::QuoteAckStatus", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_INT * >(argp1);
  result = (FIX::QuoteAckStatus *)new FIX::QuoteAckStatus((FIX_INT const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_QuoteAckStatus(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_QuoteAckStatus__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_INT, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_QuoteAckStatus__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "QuoteAckStatus.new", 
    "    QuoteAckStatus.new()\n"
    "    QuoteAckStatus.new(FIX_INT const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_QuoteAckStatus(FIX::QuoteAckStatus *arg1) {
    delete arg1;
}

swig_class cTotQuoteEntries;

SWIGINTERN VALUE
_wrap_new_TotQuoteEntries__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::TotQuoteEntries *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TotQuoteEntries";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::TotQuoteEntries *)new FIX::TotQuoteEntries();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_TotQuoteEntries_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_TotQuoteEntries_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TotQuoteEntries);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_TotQuoteEntries__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_INT *arg1 = 0 ;
  FIX::TotQuoteEntries *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TotQuoteEntries";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_INT,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_INT const &","FIX::TotQuoteEntries", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_INT const &","FIX::TotQuoteEntries", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_INT * >(argp1);
  result = (FIX::TotQuoteEntries *)new FIX::TotQuoteEntries((FIX_INT const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TotQuoteEntries(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TotQuoteEntries__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_INT, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_TotQuoteEntries__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "TotQuoteEntries.new", 
    "    TotQuoteEntries.new()\n"
    "    TotQuoteEntries.new(FIX_INT const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_TotQuoteEntries(FIX::TotQuoteEntries *arg1) {
    delete arg1;
}

swig_class cUnderlyingMaturityDay;

SWIGINTERN VALUE
_wrap_new_UnderlyingMaturityDay__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::UnderlyingMaturityDay *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UnderlyingMaturityDay";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::UnderlyingMaturityDay *)new FIX::UnderlyingMaturityDay();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_UnderlyingMaturityDay_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_UnderlyingMaturityDay_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UnderlyingMaturityDay);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_UnderlyingMaturityDay__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_DAYOFMONTH *arg1 = 0 ;
  FIX::UnderlyingMaturityDay *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UnderlyingMaturityDay";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_DAYOFMONTH,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_DAYOFMONTH const &","FIX::UnderlyingMaturityDay", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_DAYOFMONTH const &","FIX::UnderlyingMaturityDay", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_DAYOFMONTH * >(argp1);
  result = (FIX::UnderlyingMaturityDay *)new FIX::UnderlyingMaturityDay((FIX_DAYOFMONTH const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UnderlyingMaturityDay(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_UnderlyingMaturityDay__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_DAYOFMONTH, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnderlyingMaturityDay__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "UnderlyingMaturityDay.new", 
    "    UnderlyingMaturityDay.new()\n"
    "    UnderlyingMaturityDay.new(FIX_DAYOFMONTH const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_UnderlyingMaturityDay(FIX::UnderlyingMaturityDay *arg1) {
    delete arg1;
}

swig_class cUnderlyingPutOrCall;

SWIGINTERN VALUE
_wrap_new_UnderlyingPutOrCall__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::UnderlyingPutOrCall *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UnderlyingPutOrCall";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::UnderlyingPutOrCall *)new FIX::UnderlyingPutOrCall();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_UnderlyingPutOrCall_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_UnderlyingPutOrCall_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__UnderlyingPutOrCall);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_UnderlyingPutOrCall__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_INT *arg1 = 0 ;
  FIX::UnderlyingPutOrCall *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::UnderlyingPutOrCall";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_INT,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_INT const &","FIX::UnderlyingPutOrCall", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_INT const &","FIX::UnderlyingPutOrCall", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_INT * >(argp1);
  result = (FIX::UnderlyingPutOrCall *)new FIX::UnderlyingPutOrCall((FIX_INT const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UnderlyingPutOrCall(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_UnderlyingPutOrCall__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_INT, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnderlyingPutOrCall__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "UnderlyingPutOrCall.new", 
    "    UnderlyingPutOrCall.new()\n"
    "    UnderlyingPutOrCall.new(FIX_INT const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_UnderlyingPutOrCall(FIX::UnderlyingPutOrCall *arg1) {
    delete arg1;
}

swig_class cRatioQty;

SWIGINTERN VALUE
_wrap_new_RatioQty__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::RatioQty *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RatioQty";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::RatioQty *)new FIX::RatioQty();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RatioQty_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RatioQty_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RatioQty);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RatioQty__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_QTY *arg1 = 0 ;
  FIX::RatioQty *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RatioQty";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_QTY,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_QTY const &","FIX::RatioQty", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_QTY const &","FIX::RatioQty", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_QTY * >(argp1);
  result = (FIX::RatioQty *)new FIX::RatioQty((FIX_QTY const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RatioQty(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RatioQty__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_QTY, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RatioQty__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "RatioQty.new", 
    "    RatioQty.new()\n"
    "    RatioQty.new(FIX_QTY const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_RatioQty(FIX::RatioQty *arg1) {
    delete arg1;
}

swig_class cOnBehalfOfSendingTime;

SWIGINTERN VALUE
_wrap_new_OnBehalfOfSendingTime__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::OnBehalfOfSendingTime *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::OnBehalfOfSendingTime";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::OnBehalfOfSendingTime *)new FIX::OnBehalfOfSendingTime();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OnBehalfOfSendingTime__SWIG_1(int argc, VALUE *argv, VALUE self) {
  bool arg1 ;
  FIX::OnBehalfOfSendingTime *result = 0 ;
  bool val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::OnBehalfOfSendingTime";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_bool(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "bool","FIX::OnBehalfOfSendingTime", 1, argv[0] ));
  } 
  arg1 = static_cast< bool >(val1);
  result = (FIX::OnBehalfOfSendingTime *)new FIX::OnBehalfOfSendingTime(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OnBehalfOfSendingTime__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX_UTCTIMESTAMP *arg1 = 0 ;
  FIX::OnBehalfOfSendingTime *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::OnBehalfOfSendingTime";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_UTCTIMESTAMP,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_UTCTIMESTAMP const &","FIX::OnBehalfOfSendingTime", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_UTCTIMESTAMP const &","FIX::OnBehalfOfSendingTime", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_UTCTIMESTAMP * >(argp1);
  result = (FIX::OnBehalfOfSendingTime *)new FIX::OnBehalfOfSendingTime((FIX_UTCTIMESTAMP const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OnBehalfOfSendingTime_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OnBehalfOfSendingTime_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__OnBehalfOfSendingTime);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OnBehalfOfSendingTime__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX_UTCTIMESTAMP *arg1 = 0 ;
  bool arg2 ;
  FIX::OnBehalfOfSendingTime *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::OnBehalfOfSendingTime";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_UTCTIMESTAMP,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_UTCTIMESTAMP const &","FIX::OnBehalfOfSendingTime", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_UTCTIMESTAMP const &","FIX::OnBehalfOfSendingTime", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_UTCTIMESTAMP * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","FIX::OnBehalfOfSendingTime", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (FIX::OnBehalfOfSendingTime *)new FIX::OnBehalfOfSendingTime((FIX_UTCTIMESTAMP const &)*arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OnBehalfOfSendingTime(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OnBehalfOfSendingTime__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_UTCTIMESTAMP, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OnBehalfOfSendingTime__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_bool(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_OnBehalfOfSendingTime__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_UTCTIMESTAMP, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OnBehalfOfSendingTime__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "OnBehalfOfSendingTime.new", 
    "    OnBehalfOfSendingTime.new()\n"
    "    OnBehalfOfSendingTime.new(bool showMilliseconds)\n"
    "    OnBehalfOfSendingTime.new(FIX_UTCTIMESTAMP const &value)\n"
    "    OnBehalfOfSendingTime.new(FIX_UTCTIMESTAMP const &value, bool showMilliseconds)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_OnBehalfOfSendingTime(FIX::OnBehalfOfSendingTime *arg1) {
    delete arg1;
}

swig_class cDiscretionOffset;

SWIGINTERN VALUE
_wrap_new_DiscretionOffset__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DiscretionOffset *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DiscretionOffset";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::DiscretionOffset *)new FIX::DiscretionOffset();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DiscretionOffset_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DiscretionOffset_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DiscretionOffset);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DiscretionOffset__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_PRICEOFFSET *arg1 = 0 ;
  FIX::DiscretionOffset *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DiscretionOffset";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_PRICEOFFSET,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_PRICEOFFSET const &","FIX::DiscretionOffset", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_PRICEOFFSET const &","FIX::DiscretionOffset", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_PRICEOFFSET * >(argp1);
  result = (FIX::DiscretionOffset *)new FIX::DiscretionOffset((FIX_PRICEOFFSET const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DiscretionOffset(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_DiscretionOffset__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_PRICEOFFSET, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DiscretionOffset__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "DiscretionOffset.new", 
    "    DiscretionOffset.new()\n"
    "    DiscretionOffset.new(FIX_PRICEOFFSET const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_DiscretionOffset(FIX::DiscretionOffset *arg1) {
    delete arg1;
}

swig_class cTotalNumSecurities;

SWIGINTERN VALUE
_wrap_new_TotalNumSecurities__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::TotalNumSecurities *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TotalNumSecurities";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::TotalNumSecurities *)new FIX::TotalNumSecurities();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_TotalNumSecurities_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_TotalNumSecurities_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TotalNumSecurities);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_TotalNumSecurities__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_INT *arg1 = 0 ;
  FIX::TotalNumSecurities *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TotalNumSecurities";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_INT,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_INT const &","FIX::TotalNumSecurities", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_INT const &","FIX::TotalNumSecurities", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_INT * >(argp1);
  result = (FIX::TotalNumSecurities *)new FIX::TotalNumSecurities((FIX_INT const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TotalNumSecurities(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TotalNumSecurities__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_INT, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_TotalNumSecurities__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "TotalNumSecurities.new", 
    "    TotalNumSecurities.new()\n"
    "    TotalNumSecurities.new(FIX_INT const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_TotalNumSecurities(FIX::TotalNumSecurities *arg1) {
    delete arg1;
}

swig_class cTradeType;

SWIGINTERN VALUE
_wrap_new_TradeType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::TradeType *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TradeType";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::TradeType *)new FIX::TradeType();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_TradeType_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_TradeType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TradeType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_TradeType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_CHAR *arg1 = 0 ;
  FIX::TradeType *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TradeType";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_CHAR,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_CHAR const &","FIX::TradeType", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_CHAR const &","FIX::TradeType", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_CHAR * >(argp1);
  result = (FIX::TradeType *)new FIX::TradeType((FIX_CHAR const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TradeType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TradeType__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_CHAR, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_TradeType__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "TradeType.new", 
    "    TradeType.new()\n"
    "    TradeType.new(FIX_CHAR const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_TradeType(FIX::TradeType *arg1) {
    delete arg1;
}

swig_class cClearingFirm;

SWIGINTERN VALUE
_wrap_new_ClearingFirm__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::ClearingFirm *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ClearingFirm";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::ClearingFirm *)new FIX::ClearingFirm();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ClearingFirm_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ClearingFirm_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ClearingFirm);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ClearingFirm__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::ClearingFirm *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ClearingFirm";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::ClearingFirm", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::ClearingFirm", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::ClearingFirm *)new FIX::ClearingFirm((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ClearingFirm(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ClearingFirm__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ClearingFirm__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ClearingFirm.new", 
    "    ClearingFirm.new()\n"
    "    ClearingFirm.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_ClearingFirm(FIX::ClearingFirm *arg1) {
    delete arg1;
}

swig_class cClearingAccount;

SWIGINTERN VALUE
_wrap_new_ClearingAccount__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::ClearingAccount *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ClearingAccount";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::ClearingAccount *)new FIX::ClearingAccount();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ClearingAccount_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ClearingAccount_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ClearingAccount);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ClearingAccount__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::ClearingAccount *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ClearingAccount";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::ClearingAccount", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::ClearingAccount", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::ClearingAccount *)new FIX::ClearingAccount((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ClearingAccount(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ClearingAccount__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ClearingAccount__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ClearingAccount.new", 
    "    ClearingAccount.new()\n"
    "    ClearingAccount.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_ClearingAccount(FIX::ClearingAccount *arg1) {
    delete arg1;
}

swig_class cTotalVolumeTradedDate;

SWIGINTERN VALUE
_wrap_new_TotalVolumeTradedDate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::TotalVolumeTradedDate *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TotalVolumeTradedDate";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::TotalVolumeTradedDate *)new FIX::TotalVolumeTradedDate();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_TotalVolumeTradedDate_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_TotalVolumeTradedDate_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TotalVolumeTradedDate);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_TotalVolumeTradedDate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_UTCDATE *arg1 = 0 ;
  FIX::TotalVolumeTradedDate *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TotalVolumeTradedDate";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_UTCDATE,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_UTCDATE const &","FIX::TotalVolumeTradedDate", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_UTCDATE const &","FIX::TotalVolumeTradedDate", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_UTCDATE * >(argp1);
  result = (FIX::TotalVolumeTradedDate *)new FIX::TotalVolumeTradedDate((FIX_UTCDATE const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TotalVolumeTradedDate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TotalVolumeTradedDate__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_UTCDATE, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_TotalVolumeTradedDate__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "TotalVolumeTradedDate.new", 
    "    TotalVolumeTradedDate.new()\n"
    "    TotalVolumeTradedDate.new(FIX_UTCDATE const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_TotalVolumeTradedDate(FIX::TotalVolumeTradedDate *arg1) {
    delete arg1;
}

swig_class cTotalVolumeTradedTime;

SWIGINTERN VALUE
_wrap_new_TotalVolumeTradedTime__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::TotalVolumeTradedTime *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TotalVolumeTradedTime";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::TotalVolumeTradedTime *)new FIX::TotalVolumeTradedTime();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_TotalVolumeTradedTime_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_TotalVolumeTradedTime_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TotalVolumeTradedTime);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_TotalVolumeTradedTime__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_UTCTIMEONLY *arg1 = 0 ;
  FIX::TotalVolumeTradedTime *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TotalVolumeTradedTime";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_UTCTIMEONLY,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_UTCTIMEONLY const &","FIX::TotalVolumeTradedTime", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_UTCTIMEONLY const &","FIX::TotalVolumeTradedTime", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_UTCTIMEONLY * >(argp1);
  result = (FIX::TotalVolumeTradedTime *)new FIX::TotalVolumeTradedTime((FIX_UTCTIMEONLY const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TotalVolumeTradedTime(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TotalVolumeTradedTime__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_UTCTIMEONLY, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_TotalVolumeTradedTime__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "TotalVolumeTradedTime.new", 
    "    TotalVolumeTradedTime.new()\n"
    "    TotalVolumeTradedTime.new(FIX_UTCTIMEONLY const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_TotalVolumeTradedTime(FIX::TotalVolumeTradedTime *arg1) {
    delete arg1;
}

swig_class cCardIssNo;

SWIGINTERN VALUE
_wrap_new_CardIssNo__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::CardIssNo *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CardIssNo";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::CardIssNo *)new FIX::CardIssNo();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CardIssNo_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CardIssNo_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__CardIssNo);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CardIssNo__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::CardIssNo *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::CardIssNo";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::CardIssNo", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::CardIssNo", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::CardIssNo *)new FIX::CardIssNo((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CardIssNo(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_CardIssNo__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CardIssNo__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "CardIssNo.new", 
    "    CardIssNo.new()\n"
    "    CardIssNo.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_CardIssNo(FIX::CardIssNo *arg1) {
    delete arg1;
}

swig_class cRegistDetls;

SWIGINTERN VALUE
_wrap_new_RegistDetls__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::RegistDetls *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RegistDetls";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::RegistDetls *)new FIX::RegistDetls();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RegistDetls_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RegistDetls_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__RegistDetls);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RegistDetls__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::RegistDetls *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::RegistDetls";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::RegistDetls", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::RegistDetls", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::RegistDetls *)new FIX::RegistDetls((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RegistDetls(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_RegistDetls__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RegistDetls__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "RegistDetls.new", 
    "    RegistDetls.new()\n"
    "    RegistDetls.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_RegistDetls(FIX::RegistDetls *arg1) {
    delete arg1;
}

swig_class cTotalNumSecurityTypes;

SWIGINTERN VALUE
_wrap_new_TotalNumSecurityTypes__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::TotalNumSecurityTypes *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TotalNumSecurityTypes";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::TotalNumSecurityTypes *)new FIX::TotalNumSecurityTypes();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_TotalNumSecurityTypes_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_TotalNumSecurityTypes_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__TotalNumSecurityTypes);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_TotalNumSecurityTypes__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_INT *arg1 = 0 ;
  FIX::TotalNumSecurityTypes *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::TotalNumSecurityTypes";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_INT,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_INT const &","FIX::TotalNumSecurityTypes", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_INT const &","FIX::TotalNumSecurityTypes", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_INT * >(argp1);
  result = (FIX::TotalNumSecurityTypes *)new FIX::TotalNumSecurityTypes((FIX_INT const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TotalNumSecurityTypes(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_TotalNumSecurityTypes__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_INT, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_TotalNumSecurityTypes__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "TotalNumSecurityTypes.new", 
    "    TotalNumSecurityTypes.new()\n"
    "    TotalNumSecurityTypes.new(FIX_INT const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_TotalNumSecurityTypes(FIX::TotalNumSecurityTypes *arg1) {
    delete arg1;
}

swig_class cLegSettlmntTyp;

SWIGINTERN VALUE
_wrap_new_LegSettlmntTyp__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::LegSettlmntTyp *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LegSettlmntTyp";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::LegSettlmntTyp *)new FIX::LegSettlmntTyp();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_LegSettlmntTyp_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_LegSettlmntTyp_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__LegSettlmntTyp);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_LegSettlmntTyp__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_CHAR *arg1 = 0 ;
  FIX::LegSettlmntTyp *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LegSettlmntTyp";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_CHAR,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_CHAR const &","FIX::LegSettlmntTyp", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_CHAR const &","FIX::LegSettlmntTyp", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_CHAR * >(argp1);
  result = (FIX::LegSettlmntTyp *)new FIX::LegSettlmntTyp((FIX_CHAR const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_LegSettlmntTyp(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_LegSettlmntTyp__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_CHAR, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LegSettlmntTyp__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "LegSettlmntTyp.new", 
    "    LegSettlmntTyp.new()\n"
    "    LegSettlmntTyp.new(FIX_CHAR const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_LegSettlmntTyp(FIX::LegSettlmntTyp *arg1) {
    delete arg1;
}

swig_class cLegFutSettDate;

SWIGINTERN VALUE
_wrap_new_LegFutSettDate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::LegFutSettDate *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LegFutSettDate";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::LegFutSettDate *)new FIX::LegFutSettDate();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_LegFutSettDate_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_LegFutSettDate_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__LegFutSettDate);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_LegFutSettDate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX_STRING *arg1 = 0 ;
  FIX::LegFutSettDate *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::LegFutSettDate";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX_STRING,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX_STRING const &","FIX::LegFutSettDate", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX_STRING const &","FIX::LegFutSettDate", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX_STRING * >(argp1);
  result = (FIX::LegFutSettDate *)new FIX::LegFutSettDate((FIX_STRING const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_LegFutSettDate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_LegFutSettDate__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX_STRING, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LegFutSettDate__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "LegFutSettDate.new", 
    "    LegFutSettDate.new()\n"
    "    LegFutSettDate.new(FIX_STRING const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_LegFutSettDate(FIX::LegFutSettDate *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_BeginString_FIX44_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX44);
  return _val;
}


SWIGINTERN VALUE
_wrap_BeginString_FIX43_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX43);
  return _val;
}


SWIGINTERN VALUE
_wrap_BeginString_FIX42_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX42);
  return _val;
}


SWIGINTERN VALUE
_wrap_BeginString_FIX41_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX41);
  return _val;
}


SWIGINTERN VALUE
_wrap_BeginString_FIX40_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BeginString_FIX40);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Heartbeat_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Heartbeat);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Logon_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Logon);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TestRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TestRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ResendRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ResendRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Reject_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Reject);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SequenceReset_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SequenceReset);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Logout_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Logout);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_BusinessMessageReject_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_BusinessMessageReject);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_UserRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_UserRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_UserResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_UserResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Advertisement_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Advertisement);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_IndicationOfInterest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_IndicationOfInterest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_News_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_News);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Email_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Email);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteRequestReject_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteRequestReject);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RFQRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RFQRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Quote_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Quote);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteCancel_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteCancel);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QuoteStatusReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QuoteStatusReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MassQuote_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MassQuote);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MassQuoteAcknowledgement_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MassQuoteAcknowledgement);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataSnapshotFullRefresh_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataSnapshotFullRefresh);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataIncrementalRefresh_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataIncrementalRefresh);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MarketDataRequestReject_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MarketDataRequestReject);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityDefinitionRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityDefinitionRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityDefinition_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityDefinition);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityTypeRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityTypeRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityTypes_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityTypes);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityListRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityListRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityList_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityList);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_DerivativeSecurityListRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_DerivativeSecurityListRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_DerivativeSecurityList_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_DerivativeSecurityList);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SecurityStatus_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SecurityStatus);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradingSessionStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradingSessionStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradingSessionStatus_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradingSessionStatus);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NewOrderSingle_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NewOrderSingle);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ExecutionReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ExecutionReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_DontKnowTrade_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_DontKnowTrade);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderCancelReplaceRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderCancelReplaceRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderCancelRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderCancelRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderCancelReject_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderCancelReject);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderMassCancelRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderMassCancelRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderMassCancelReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderMassCancelReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_OrderMassStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_OrderMassStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NewOrderCross_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NewOrderCross);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CrossOrderCancelReplaceRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CrossOrderCancelReplaceRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CrossOrderCancelRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CrossOrderCancelRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NewOrderMultileg_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NewOrderMultileg);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MultilegOrderCancelReplaceRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MultilegOrderCancelReplaceRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_BidRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_BidRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_BidResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_BidResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NewOrderList_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NewOrderList);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ListStrikePrice_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ListStrikePrice);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ListStatus_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ListStatus);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ListExecute_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ListExecute);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ListCancelRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ListCancelRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ListStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ListStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationInstruction_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationInstruction);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationInstructionAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationInstructionAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AllocationReportAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AllocationReportAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_Confirmation_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_Confirmation);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ConfirmationAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ConfirmationAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ConfirmationRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ConfirmationRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SettlementInstructions_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SettlementInstructions);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SettlementInstructionRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SettlementInstructionRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeCaptureReportRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeCaptureReportRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeCaptureReportRequestAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeCaptureReportRequestAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeCaptureReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeCaptureReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TradeCaptureReportAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TradeCaptureReportAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RegistrationInstructions_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RegistrationInstructions);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RegistrationInstructionsResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RegistrationInstructionsResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PositionMaintenanceRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PositionMaintenanceRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PositionMaintenanceReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PositionMaintenanceReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RequestForPositions_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RequestForPositions);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RequestForPositionsAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RequestForPositionsAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_PositionReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_PositionReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_AssignmentReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_AssignmentReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralAssignment_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralAssignment);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralReport_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralReport);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralInquiry_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralInquiry);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NetworkStatusRequest_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NetworkStatusRequest);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NetworkStatusResponse_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NetworkStatusResponse);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CollateralInquiryAck_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CollateralInquiryAck);
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvSide_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AdvSide_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvSide_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AdvSide_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvSide_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AdvSide_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvSide_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AdvSide_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::AdvTransType_NEW);
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::AdvTransType_CANCEL);
  return _val;
}


SWIGINTERN VALUE
_wrap_AdvTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::AdvTransType_REPLACE);
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_PER_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_PER_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_ABSOLUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_ABSOLUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_PERCENTAGE_WAIVED_CASH_DISCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_PERCENTAGE_WAIVED_CASH_DISCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_PERCENTAGE_WAIVED_ENHANCED_UNITS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_PERCENTAGE_WAIVED_ENHANCED_UNITS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CommType_POINTS_PER_BOND_OR_OR_CONTRACT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CommType_POINTS_PER_BOND_OR_OR_CONTRACT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_NOT_HELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_NOT_HELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_WORK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_WORK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_GO_ALONG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_GO_ALONG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_OVER_THE_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_OVER_THE_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_HELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_HELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_PARTICIPATE_DONT_INITIATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_PARTICIPATE_DONT_INITIATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_STRICT_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_STRICT_SCALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_TRY_TO_SCALE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_TRY_TO_SCALE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_STAY_ON_BIDSIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_STAY_ON_BIDSIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_STAY_ON_OFFERSIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_STAY_ON_OFFERSIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_NO_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_NO_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_OK_TO_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_OK_TO_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CALL_FIRST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CALL_FIRST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_PERCENT_OF_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_PERCENT_OF_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_DO_NOT_INCREASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_DO_NOT_INCREASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_DO_NOT_REDUCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_DO_NOT_REDUCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_ALL_OR_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_ALL_OR_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_REINSTATE_ON_SYSTEM_FAILURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_REINSTATE_ON_SYSTEM_FAILURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_INSTITUTIONS_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_INSTITUTIONS_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_REINSTATE_ON_TRADING_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_REINSTATE_ON_TRADING_HALT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CANCEL_ON_TRADING_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CANCEL_ON_TRADING_HALT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_LAST_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_LAST_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_MID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_MID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_NON_NEGOTIABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_NON_NEGOTIABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_OPENING_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_OPENING_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_MARKET_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_MARKET_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CANCEL_ON_SYSTEM_FAILURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CANCEL_ON_SYSTEM_FAILURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_PRIMARY_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_PRIMARY_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_SUSPEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_SUSPEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CUSTOMER_DISPLAY_INSTRUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CUSTOMER_DISPLAY_INSTRUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_PEG_TO_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_PEG_TO_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_TRADE_ALONG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_TRADE_ALONG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_TRY_TO_STOP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_TRY_TO_STOP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_CANCEL_IF_NOT_BEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_CANCEL_IF_NOT_BEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_TRAILING_STOP_PEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_TRAILING_STOP_PEG));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_STRICT_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_STRICT_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_IGNORE_PRICE_VALIDITY_CHECKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_IGNORE_PRICE_VALIDITY_CHECKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_PEG_TO_LIMIT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_PEG_TO_LIMIT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecInst_WORK_TO_TARGET_STRATEGY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecInst_WORK_TO_TARGET_STRATEGY));
  return _val;
}


SWIGINTERN VALUE
_wrap_HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_HandlInst_AUTOMATED_EXECUTION_ORDER_PUBLIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HandlInst_AUTOMATED_EXECUTION_ORDER_PUBLIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_HandlInst_MANUAL_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HandlInst_MANUAL_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_CUSIP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_CUSIP);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_SEDOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_SEDOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_QUIK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_QUIK);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_ISIN_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_ISIN_NUMBER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_RIC_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_RIC_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_ISO_CURRENCY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_ISO_CURRENCY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_ISO_COUNTRY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_ISO_COUNTRY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_EXCHANGE_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_EXCHANGE_SYMBOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_CONSOLIDATED_TAPE_ASSOCIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_CONSOLIDATED_TAPE_ASSOCIATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_BLOOMBERG_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_BLOOMBERG_SYMBOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_WERTPAPIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_WERTPAPIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_DUTCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_DUTCH);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_VALOREN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_VALOREN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_SICOVAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_SICOVAM);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_BELGIAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_BELGIAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_COMMON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_COMMON);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_CLEARING_HOUSE_CLEARING_ORGANIZATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_CLEARING_HOUSE_CLEARING_ORGANIZATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_ISDA_FPML_PRODUCT_SPECIFICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_ISDA_FPML_PRODUCT_SPECIFICATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityIDSource_OPTIONS_PRICE_REPORTING_AUTHORITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityIDSource_OPTIONS_PRICE_REPORTING_AUTHORITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQltyInd_LOW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQltyInd_LOW));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQltyInd_MEDIUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQltyInd_MEDIUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQltyInd_HIGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQltyInd_HIGH));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOITransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOITransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOITransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOITransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOITransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOITransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastCapacity_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastCapacity_AGENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastCapacity_CROSS_AS_AGENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastCapacity_CROSS_AS_AGENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastCapacity_CROSS_AS_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastCapacity_CROSS_AS_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastCapacity_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::LastCapacity_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_HEARTBEAT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_HEARTBEAT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TEST_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TEST_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RESEND_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RESEND_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_REJECT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SEQUENCE_RESET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SEQUENCE_RESET);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_LOGOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_LOGOUT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_INDICATION_OF_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_INDICATION_OF_INTEREST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ADVERTISEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ADVERTISEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_EXECUTION_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_EXECUTION_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ORDER_CANCEL_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ORDER_CANCEL_REJECT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_LOGON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_LOGON);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NEWS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NEWS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_EMAIL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_EMAIL);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ORDER_SINGLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ORDER_SINGLE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ORDER_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ORDER_LIST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ORDER_CANCEL_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ORDER_CANCEL_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ORDER_CANCEL_REPLACE_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ORDER_CANCEL_REPLACE_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ORDER_STATUS_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ORDER_STATUS_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ALLOCATION_INSTRUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ALLOCATION_INSTRUCTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_LIST_CANCEL_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_LIST_CANCEL_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_LIST_EXECUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_LIST_EXECUTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_LIST_STATUS_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_LIST_STATUS_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_LIST_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_LIST_STATUS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ALLOCATION_INSTRUCTION_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ALLOCATION_INSTRUCTION_ACK);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_DONT_KNOW_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_DONT_KNOW_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QUOTE_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QUOTE_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QUOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SETTLEMENT_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SETTLEMENT_INSTRUCTIONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MARKET_DATA_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MARKET_DATA_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MARKET_DATA_SNAPSHOT_FULL_REFRESH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MARKET_DATA_SNAPSHOT_FULL_REFRESH);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MARKET_DATA_INCREMENTAL_REFRESH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MARKET_DATA_INCREMENTAL_REFRESH);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MARKET_DATA_REQUEST_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MARKET_DATA_REQUEST_REJECT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QUOTE_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QUOTE_CANCEL);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QUOTE_STATUS_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QUOTE_STATUS_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MASS_QUOTE_ACKNOWLEDGEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MASS_QUOTE_ACKNOWLEDGEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SECURITY_DEFINITION_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SECURITY_DEFINITION_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SECURITY_DEFINITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SECURITY_DEFINITION);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SECURITY_STATUS_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SECURITY_STATUS_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SECURITY_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SECURITY_STATUS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TRADING_SESSION_STATUS_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TRADING_SESSION_STATUS_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TRADING_SESSION_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TRADING_SESSION_STATUS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MASS_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MASS_QUOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_BUSINESS_MESSAGE_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_BUSINESS_MESSAGE_REJECT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_BID_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_BID_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_BID_RESPONSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_BID_RESPONSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_LIST_STRIKE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_LIST_STRIKE_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_XML_MESSAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_XML_MESSAGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_REGISTRATION_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_REGISTRATION_INSTRUCTIONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_REGISTRATION_INSTRUCTIONS_RESPONSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_REGISTRATION_INSTRUCTIONS_RESPONSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ORDER_MASS_CANCEL_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ORDER_MASS_CANCEL_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ORDER_MASS_CANCEL_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ORDER_MASS_CANCEL_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NEW_ORDER_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NEW_ORDER_CROSS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CROSS_ORDER_CANCEL_REPLACE_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CROSS_ORDER_CANCEL_REPLACE_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CROSS_ORDER_CANCEL_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CROSS_ORDER_CANCEL_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SECURITY_TYPE_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SECURITY_TYPE_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SECURITY_TYPES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SECURITY_TYPES);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SECURITY_LIST_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SECURITY_LIST_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SECURITY_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SECURITY_LIST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_DERIVATIVE_SECURITY_LIST_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_DERIVATIVE_SECURITY_LIST_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_DERIVATIVE_SECURITY_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_DERIVATIVE_SECURITY_LIST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NEW_ORDER_MULTILEG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NEW_ORDER_MULTILEG);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_MULTILEG_ORDER_CANCEL_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_MULTILEG_ORDER_CANCEL_REPLACE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TRADE_CAPTURE_REPORT_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TRADE_CAPTURE_REPORT_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TRADE_CAPTURE_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TRADE_CAPTURE_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ORDER_MASS_STATUS_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ORDER_MASS_STATUS_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QUOTE_REQUEST_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QUOTE_REQUEST_REJECT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_RFQ_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_RFQ_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QUOTE_STATUS_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QUOTE_STATUS_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_QUOTE_RESPONSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_QUOTE_RESPONSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CONFIRMATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_POSITION_MAINTENANCE_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_POSITION_MAINTENANCE_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_POSITION_MAINTENANCE_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_POSITION_MAINTENANCE_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_REQUEST_FOR_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_REQUEST_FOR_POSITIONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_REQUEST_FOR_POSITIONS_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_REQUEST_FOR_POSITIONS_ACK);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_POSITION_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_POSITION_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TRADE_CAPTURE_REPORT_REQUEST_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TRADE_CAPTURE_REPORT_REQUEST_ACK);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_TRADE_CAPTURE_REPORT_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_TRADE_CAPTURE_REPORT_ACK);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ALLOCATION_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ALLOCATION_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ALLOCATION_REPORT_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ALLOCATION_REPORT_ACK);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CONFIRMATION_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CONFIRMATION_ACK);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_SETTLEMENT_INSTRUCTION_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_SETTLEMENT_INSTRUCTION_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_ASSIGNMENT_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_ASSIGNMENT_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_COLLATERAL_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_COLLATERAL_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_COLLATERAL_ASSIGNMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_COLLATERAL_ASSIGNMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_COLLATERAL_RESPONSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_COLLATERAL_RESPONSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_COLLATERAL_REPORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_COLLATERAL_REPORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_COLLATERAL_INQUIRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_COLLATERAL_INQUIRY);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NETWORK_STATUS_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NETWORK_STATUS_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_NETWORK_STATUS_RESPONSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_NETWORK_STATUS_RESPONSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_USER_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_USER_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_USER_RESPONSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_USER_RESPONSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_COLLATERAL_INQUIRY_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_COLLATERAL_INQUIRY_ACK);
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgType_CONFIRMATION_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MsgType_CONFIRMATION_REQUEST);
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_PARTIALLY_FILLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_PARTIALLY_FILLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_FILLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_FILLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_DONE_FOR_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_DONE_FOR_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_CANCELED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_CANCELED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_REPLACED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_REPLACED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_PENDING_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_PENDING_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_STOPPED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_STOPPED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_SUSPENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_SUSPENDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_PENDING_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_PENDING_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_CALCULATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_CALCULATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_ACCEPTED_FOR_BIDDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_ACCEPTED_FOR_BIDDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdStatus_PENDING_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdStatus_PENDING_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_STOP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_STOP));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_STOP_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_STOP_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_MARKET_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_MARKET_ON_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_WITH_OR_WITHOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_WITH_OR_WITHOUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_LIMIT_OR_BETTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_LIMIT_OR_BETTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_LIMIT_WITH_OR_WITHOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_LIMIT_WITH_OR_WITHOUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_ON_BASIS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_ON_BASIS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_ON_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_LIMIT_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_LIMIT_ON_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_FOREX_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_FOREX_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_PREVIOUSLY_QUOTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_PREVIOUSLY_QUOTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_PREVIOUSLY_INDICATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_PREVIOUSLY_INDICATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_FOREX_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_FOREX_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_FOREX_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_FOREX_SWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_FOREX_PREVIOUSLY_QUOTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_FOREX_PREVIOUSLY_QUOTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_FUNARI_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_FUNARI));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_MARKET_IF_TOUCHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_MARKET_IF_TOUCHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_MARKET_WITH_LEFTOVER_AS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_MARKET_WITH_LEFTOVER_AS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_PREVIOUS_FUND_VALUATION_POINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_PREVIOUS_FUND_VALUATION_POINT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_NEXT_FUND_VALUATION_POINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_NEXT_FUND_VALUATION_POINT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdType_PEGGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrdType_PEGGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_BUY_MINUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_BUY_MINUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SELL_PLUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SELL_PLUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SELL_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SELL_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SELL_SHORT_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SELL_SHORT_EXEMPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_UNDISCLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_UNDISCLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_CROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_CROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_CROSS_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_CROSS_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_CROSS_SHORT_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_CROSS_SHORT_EXEMPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_AS_DEFINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_AS_DEFINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_OPPOSITE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_OPPOSITE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_SUBSCRIBE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_SUBSCRIBE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_REDEEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_REDEEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_LEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_LEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_Side_BORROW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Side_BORROW));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_GOOD_TILL_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_GOOD_TILL_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_AT_THE_OPENING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_AT_THE_OPENING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_IMMEDIATE_OR_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_IMMEDIATE_OR_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_FILL_OR_KILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_FILL_OR_KILL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_GOOD_TILL_CROSSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_GOOD_TILL_CROSSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_GOOD_TILL_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_GOOD_TILL_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TimeInForce_AT_THE_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TimeInForce_AT_THE_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Urgency_NORMAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Urgency_NORMAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Urgency_FLASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Urgency_FLASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_Urgency_BACKGROUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Urgency_BACKGROUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_REGULAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlType_REGULAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlType_CASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_NEXT_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlType_NEXT_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_T_PLUS_2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlType_T_PLUS_2));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_T_PLUS_3_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlType_T_PLUS_3));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_T_PLUS_4_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlType_T_PLUS_4));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_FUTURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlType_FUTURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_WHEN_AND_IF_ISSUED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlType_WHEN_AND_IF_ISSUED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_SELLERS_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlType_SELLERS_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlType_T_PLUS_5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlType_T_PLUS_5));
  return _val;
}


SWIGINTERN VALUE
_wrap_SymbolSfx_WHEN_ISSUED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SymbolSfx_WHEN_ISSUED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SymbolSfx_A_EUCP_WITH_LUMP_SUM_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SymbolSfx_A_EUCP_WITH_LUMP_SUM_INTEREST);
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AllocTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionEffect_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PositionEffect_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionEffect_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PositionEffect_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionEffect_ROLLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PositionEffect_ROLLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PositionEffect_FIFO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PositionEffect_FIFO));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_REGULAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_REGULAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_SOFT_DOLLAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_SOFT_DOLLAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_STEP_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_STEP_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_STEP_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_STEP_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_SOFT_DOLLAR_STEP_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_SOFT_DOLLAR_STEP_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_SOFT_DOLLAR_STEP_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_SOFT_DOLLAR_STEP_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProcessCode_PLAN_SPONSOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ProcessCode_PLAN_SPONSOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_BLOCK_LEVEL_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_BLOCK_LEVEL_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_ACCOUNT_LEVEL_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_ACCOUNT_LEVEL_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_INCOMPLETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_INCOMPLETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocStatus_REJECTED_BY_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocStatus_REJECTED_BY_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_AVERAGE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_AVERAGE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_EXECUTING_BROKER_MNEMONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_EXECUTING_BROKER_MNEMONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_COMMISSION_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_COMMISSION_DIFFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_ORDERID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_ORDERID));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_UNKNOWN_LISTID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_UNKNOWN_LISTID));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_INCORRECT_ALLOCATED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_INCORRECT_ALLOCATED_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocRejCode_CALCULATION_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocRejCode_CALCULATION_DIFFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_EmailType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::EmailType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_EmailType_REPLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::EmailType_REPLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EmailType_ADMIN_REPLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::EmailType_ADMIN_REPLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_NONE_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_NONE_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PKCS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PKCS));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_DES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_DES));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PKCS_DES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PKCS_DES));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PGP_DES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PGP_DES));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PGP_DES_MD5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PGP_DES_MD5));
  return _val;
}


SWIGINTERN VALUE
_wrap_EncryptMethod_PEM_DES_MD5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EncryptMethod_PEM_DES_MD5));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_TOO_LATE_TO_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_TOO_LATE_TO_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_UNKNOWN_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_UNKNOWN_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_BROKER_EXCHANGE_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_BROKER_EXCHANGE_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_ORIGORDMODTIME_DID_NOT_MATCH_LAST_TRANSACTTIME_OF_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_ORIGORDMODTIME_DID_NOT_MATCH_LAST_TRANSACTTIME_OF_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_DUPLICATE_CLORDID_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_DUPLICATE_CLORDID_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CxlRejReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_BROKER_EXCHANGE_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_BROKER_EXCHANGE_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_EXCHANGE_CLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_EXCHANGE_CLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_ORDER_EXCEEDS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_ORDER_EXCEEDS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_TOO_LATE_TO_ENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_TOO_LATE_TO_ENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_UNKNOWN_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_UNKNOWN_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_DUPLICATE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_DUPLICATE_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_STALE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_STALE_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_TRADE_ALONG_REQUIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_TRADE_ALONG_REQUIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_INVALID_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_INVALID_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_UNSUPPORTED_ORDER_CHARACTERISTIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_UNSUPPORTED_ORDER_CHARACTERISTIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_SURVEILLENCE_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_SURVEILLENCE_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_INCORRECT_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_INCORRECT_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_INCORRECT_ALLOCATED_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_INCORRECT_ALLOCATED_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_UNKNOWN_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_UNKNOWN_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrdRejReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OrdRejReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_ALL_OR_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_ALL_OR_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_MARKET_ON_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_MARKET_ON_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AT_THE_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AT_THE_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_IN_TOUCH_WITH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_IN_TOUCH_WITH));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_MORE_BEHIND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_MORE_BEHIND));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AT_THE_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AT_THE_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_TAKING_A_POSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_TAKING_A_POSITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AT_THE_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AT_THE_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_READY_TO_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_READY_TO_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_PORTFOLIO_SHOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_PORTFOLIO_SHOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_THROUGH_THE_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_THROUGH_THE_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_VERSUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_VERSUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_INDICATION_WORKING_AWAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_INDICATION_WORKING_AWAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_CROSSING_OPPORTUNITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_CROSSING_OPPORTUNITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_AT_THE_MIDPOINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_AT_THE_MIDPOINT));
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIQualifier_PRE_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::IOIQualifier_PRE_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_WRONG_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_WRONG_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_QUANTITY_EXCEEDS_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_QUANTITY_EXCEEDS_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_NO_MATCHING_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_NO_MATCHING_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_PRICE_EXCEEDS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_PRICE_EXCEEDS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_CALCULATION_DIFFERENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_CALCULATION_DIFFERENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DKReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DKReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_REGULATORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MiscFeeType_REGULATORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MiscFeeType_TAX));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_LOCAL_COMMISSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MiscFeeType_LOCAL_COMMISSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_EXCHANGE_FEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MiscFeeType_EXCHANGE_FEES));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_STAMP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MiscFeeType_STAMP));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_LEVY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MiscFeeType_LEVY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MiscFeeType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_MARKUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MiscFeeType_MARKUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeType_CONSUMPTION_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MiscFeeType_CONSUMPTION_TAX));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_PARTIAL_FILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_PARTIAL_FILL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_FILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_FILL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_DONE_FOR_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_DONE_FOR_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_CANCELED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_CANCELED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_PENDING_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_PENDING_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_STOPPED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_STOPPED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_SUSPENDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_SUSPENDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_PENDING_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_PENDING_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_CALCULATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_CALCULATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_RESTATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_RESTATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_PENDING_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_PENDING_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_TRADE_CORRECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_TRADE_CORRECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_TRADE_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_TRADE_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecType_ORDER_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecType_ORDER_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlCurrFxRateCalc_MULTIPLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlCurrFxRateCalc_MULTIPLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlCurrFxRateCalc_DIVIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlCurrFxRateCalc_DIVIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstMode_DEFAULT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstMode_DEFAULT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstMode_STANDING_INSTRUCTIONS_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstMode_STANDING_INSTRUCTIONS_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstMode_SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstMode_SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstMode_REQUEST_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstMode_REQUEST_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstTransType_RESTATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstTransType_RESTATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstSource_BROKERS_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstSource_BROKERS_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstSource_INSTITUTIONS_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstSource_INSTITUTIONS_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstSource_INVESTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlInstSource_INVESTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_SUPRANATIONAL_COUPONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_SUPRANATIONAL_COUPONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FEDERAL_AGENCY_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FEDERAL_AGENCY_COUPON);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FEDERAL_AGENCY_DISCOUNT_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FEDERAL_AGENCY_DISCOUNT_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PRIVATE_EXPORT_FUNDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PRIVATE_EXPORT_FUNDING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_USD_SUPRANATIONAL_COUPONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_USD_SUPRANATIONAL_COUPONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FUTURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FUTURE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OPTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CORPORATE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CORPORATE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CORPORATE_PRIVATE_PLACEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CORPORATE_PRIVATE_PLACEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CONVERTIBLE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CONVERTIBLE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DUAL_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DUAL_CURRENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_CORPORATE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_CORPORATE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_INDEXED_LINKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_INDEXED_LINKED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_STRUCTURED_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_STRUCTURED_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_YANKEE_CORPORATE_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_YANKEE_CORPORATE_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FOREIGN_EXCHANGE_CONTRACT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FOREIGN_EXCHANGE_CONTRACT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_COMMON_STOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_COMMON_STOCK);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PREFERRED_STOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PREFERRED_STOCK);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BRADY_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BRADY_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_SOVEREIGNS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_SOVEREIGNS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_US_TREASURY_BOND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_US_TREASURY_BOND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TREASURY_INFLATION_PROTECTED_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TREASURY_INFLATION_PROTECTED_SECURITIES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_US_TREASURY_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_US_TREASURY_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_US_TREASURY_BILL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_US_TREASURY_BILL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REPURCHASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REPURCHASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_FORWARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_FORWARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BUY_SELLBACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BUY_SELLBACK);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SECURITIES_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SECURITIES_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SECURITIES_PLEDGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SECURITIES_PLEDGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TERM_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TERM_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REVOLVER_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REVOLVER_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REVOLVER_TERM_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REVOLVER_TERM_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BRIDGE_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BRIDGE_LOAN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_LETTER_OF_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_LETTER_OF_CREDIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SWING_LINE_FACILITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SWING_LINE_FACILITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DEBTOR_IN_POSSESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DEBTOR_IN_POSSESSION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DEFAULTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DEFAULTED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_WITHDRAWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_WITHDRAWN);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REPLACED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REPLACED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MATURED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MATURED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_AMENDED_AND_RESTATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_AMENDED_AND_RESTATED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_RETIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_RETIRED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BANKERS_ACCEPTANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BANKERS_ACCEPTANCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BANK_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BANK_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_BILL_OF_EXCHANGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_BILL_OF_EXCHANGES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CERTIFICATE_OF_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CERTIFICATE_OF_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CALL_LOANS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CALL_LOANS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_DEPOSIT_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_DEPOSIT_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_CERTIFICATE_OF_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_CERTIFICATE_OF_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EURO_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EURO_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_LIQUIDITY_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_LIQUIDITY_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MEDIUM_TERM_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MEDIUM_TERM_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OVERNIGHT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OVERNIGHT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PROMISSORY_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PROMISSORY_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PLAZOS_FIJOS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PLAZOS_FIJOS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SHORT_TERM_LOAN_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SHORT_TERM_LOAN_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TIME_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TIME_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_EXTENDED_COMM_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_EXTENDED_COMM_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_YANKEE_CERTIFICATE_OF_DEPOSIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_YANKEE_CERTIFICATE_OF_DEPOSIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_ASSET_BACKED_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_ASSET_BACKED_SECURITIES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CORP_MORTGAGE_BACKED_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CORP_MORTGAGE_BACKED_SECURITIES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_COLLATERALIZED_MORTGAGE_OBLIGATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_COLLATERALIZED_MORTGAGE_OBLIGATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_IOETTE_MORTGAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_IOETTE_MORTGAGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MORTGAGE_BACKED_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MORTGAGE_BACKED_SECURITIES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MORTGAGE_INTEREST_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MORTGAGE_INTEREST_ONLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MORTGAGE_PRINCIPAL_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MORTGAGE_PRINCIPAL_ONLY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MORTGAGE_PRIVATE_PLACEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MORTGAGE_PRIVATE_PLACEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MISCELLANEOUS_PASS_THROUGH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MISCELLANEOUS_PASS_THROUGH);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_PFANDBRIEFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_PFANDBRIEFE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TO_BE_ANNOUNCED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TO_BE_ANNOUNCED);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_OTHER_ANTICIPATION_NOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_OTHER_ANTICIPATION_NOTES);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CERTIFICATE_OF_OBLIGATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CERTIFICATE_OF_OBLIGATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_CERTIFICATE_OF_PARTICIPATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_CERTIFICATE_OF_PARTICIPATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_GENERAL_OBLIGATION_BONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_GENERAL_OBLIGATION_BONDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MANDATORY_TENDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MANDATORY_TENDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REVENUE_ANTICIPATION_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REVENUE_ANTICIPATION_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_REVENUE_BONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_REVENUE_BONDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SPECIAL_ASSESSMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SPECIAL_ASSESSMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SPECIAL_OBLIGATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SPECIAL_OBLIGATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_SPECIAL_TAX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_SPECIAL_TAX);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TAX_ANTICIPATION_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TAX_ANTICIPATION_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TAX_ALLOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TAX_ALLOCATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TAX_EXEMPT_COMMERCIAL_PAPER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TAX_EXEMPT_COMMERCIAL_PAPER);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_TAX_AND_REVENUE_ANTICIPATION_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_TAX_AND_REVENUE_ANTICIPATION_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_VARIABLE_RATE_DEMAND_NOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_VARIABLE_RATE_DEMAND_NOTE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_WARRANT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_WARRANT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MUTUAL_FUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MUTUAL_FUND);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_MULTI_LEG_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_MULTI_LEG_INSTRUMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_NO_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_NO_SECURITY_TYPE);
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityType_WILDCARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SecurityType_WILDCARD);
  return _val;
}


SWIGINTERN VALUE
_wrap_StandInstDbType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StandInstDbType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_StandInstDbType_DTC_SID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StandInstDbType_DTC_SID));
  return _val;
}


SWIGINTERN VALUE
_wrap_StandInstDbType_THOMSON_ALERT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StandInstDbType_THOMSON_ALERT));
  return _val;
}


SWIGINTERN VALUE
_wrap_StandInstDbType_A_GLOBAL_CUSTODIAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StandInstDbType_A_GLOBAL_CUSTODIAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_StandInstDbType_ACCOUNTNET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StandInstDbType_ACCOUNTNET));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlDeliveryType_VERSUS_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlDeliveryType_VERSUS_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlDeliveryType_FREE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlDeliveryType_FREE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlDeliveryType_TRI_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlDeliveryType_TRI_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlDeliveryType_HOLD_IN_CUSTODY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlDeliveryType_HOLD_IN_CUSTODY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocLinkType_F_X_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocLinkType_F_X_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocLinkType_F_X_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocLinkType_F_X_SWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_CoveredOrUncovered_COVERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CoveredOrUncovered_COVERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CoveredOrUncovered_UNCOVERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CoveredOrUncovered_UNCOVERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocHandlInst_MATCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocHandlInst_MATCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocHandlInst_FORWARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocHandlInst_FORWARD));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocHandlInst_FORWARD_AND_MATCH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocHandlInst_FORWARD_AND_MATCH));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingType_TARGET_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingType_TARGET_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingType_TARGET_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingType_TARGET_LIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingType_BLOCK_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingType_BLOCK_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoutingType_BLOCK_LIST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RoutingType_BLOCK_LIST));
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_MUNIAAA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_MUNIAAA);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_FUTURESWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_FUTURESWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_LIBID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_LIBID);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_LIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_LIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_OTHER);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_SWAP);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_TREASURY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_TREASURY);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_EURIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_EURIBOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_PFANDBRIEFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_PFANDBRIEFE);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_EONIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_EONIA);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_SONIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_SONIA);
  return _val;
}


SWIGINTERN VALUE
_wrap_BenchmarkCurveName_EUREPO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BenchmarkCurveName_EUREPO);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_AMT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_AMT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_AUTO_REINVESTMENT_AT_OR_BETTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_AUTO_REINVESTMENT_AT_OR_BETTER);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_BANK_QUALIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_BANK_QUALIFIED);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_BARGAIN_CONDITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_BARGAIN_CONDITIONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_COUPON_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_COUPON_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ISO_CURRENCY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ISO_CURRENCY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_CUSTOM_START_END_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_CUSTOM_START_END_DATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_GEOGRAPHICS_AND_PERCENT_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_GEOGRAPHICS_AND_PERCENT_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_VALUATION_DISCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_VALUATION_DISCOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_INSURED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_INSURED);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_YEAR_OR_YEAR_MONTH_OF_ISSUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_YEAR_OR_YEAR_MONTH_OF_ISSUE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ISSUERS_TICKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ISSUERS_TICKER);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ISSUE_SIZE_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ISSUE_SIZE_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_LOOKBACK_DAYS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_LOOKBACK_DAYS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_EXPLICIT_LOT_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_EXPLICIT_LOT_IDENTIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_LOT_VARIANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_LOT_VARIANCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MATURITY_YEAR_AND_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MATURITY_YEAR_AND_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MATURITY_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MATURITY_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MAXIMUM_SUBSTITUTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MAXIMUM_SUBSTITUTIONS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MINIMUM_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MINIMUM_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MINIMUM_INCREMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MINIMUM_INCREMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MINIMUM_DENOMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MINIMUM_DENOMINATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PAYMENT_FREQUENCY_CALENDAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PAYMENT_FREQUENCY_CALENDAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_NUMBER_OF_PIECES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_NUMBER_OF_PIECES);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOLS_MAXIMUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOLS_MAXIMUM);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOLS_PER_MILLION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOLS_PER_MILLION);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOLS_PER_LOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOLS_PER_LOT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_POOLS_PER_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_POOLS_PER_TRADE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PRICE_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PRICE_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PRICING_FREQUENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PRICING_FREQUENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PRODUCTION_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PRODUCTION_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_CALL_PROTECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_CALL_PROTECTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PURPOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PURPOSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_BENCHMARK_PRICE_SOURCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_BENCHMARK_PRICE_SOURCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_RATING_SOURCE_AND_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_RATING_SOURCE_AND_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_RESTRICTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_RESTRICTED);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MARKET_SECTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MARKET_SECTOR);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_SECURITYTYPE_INCLUDED_OR_EXCLUDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_SECURITYTYPE_INCLUDED_OR_EXCLUDED);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_STRUCTURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_STRUCTURE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_SUBSTITUTIONS_FREQUENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_SUBSTITUTIONS_FREQUENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_SUBSTITUTIONS_LEFT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_SUBSTITUTIONS_LEFT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_FREEFORM_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_FREEFORM_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_TRADE_VARIANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_TRADE_VARIANCE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_WEIGHTED_AVERAGE_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_WEIGHTED_AVERAGE_COUPON);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_WEIGHTED_AVERAGE_LIFE_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_WEIGHTED_AVERAGE_LIFE_COUPON);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_WEIGHTED_AVERAGE_LOAN_AGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_WEIGHTED_AVERAGE_LOAN_AGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_WEIGHTED_AVERAGE_MATURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_WEIGHTED_AVERAGE_MATURITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_WHOLE_POOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_WHOLE_POOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_YIELD_RANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_YIELD_RANGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_SINGLE_MONTHLY_MORTALITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_SINGLE_MONTHLY_MORTALITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_CONSTANT_PREPAYMENT_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_CONSTANT_PREPAYMENT_RATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_CONSTANT_PREPAYMENT_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_CONSTANT_PREPAYMENT_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_CONSTANT_PREPAYMENT_PENALTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_CONSTANT_PREPAYMENT_PENALTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_ABSOLUTE_PREPAYMENT_SPEED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_ABSOLUTE_PREPAYMENT_SPEED);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_MONTHLY_PREPAYMENT_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_MONTHLY_PREPAYMENT_RATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PERCENT_OF_BMA_PREPAYMENT_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PERCENT_OF_BMA_PREPAYMENT_CURVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PERCENT_OF_PROSPECTUS_PREPAYMENT_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PERCENT_OF_PROSPECTUS_PREPAYMENT_CURVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_PERCENT_OF_MANUFACTURED_HOUSING_PREPAYMENT_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_PERCENT_OF_MANUFACTURED_HOUSING_PREPAYMENT_CURVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationType_FINAL_CPR_OF_HOME_EQUITY_PREPAYMENT_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationType_FINAL_CPR_OF_HOME_EQUITY_PREPAYMENT_CURVE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_CUM_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_CUM_DIVIDEND);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_EX_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_EX_DIVIDEND);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_CUM_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_CUM_COUPON);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_EX_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_EX_COUPON);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_CUM_BONUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_CUM_BONUS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_EX_BONUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_EX_BONUS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_CUM_RIGHTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_CUM_RIGHTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_EX_RIGHTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_EX_RIGHTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_CUM_CAPITAL_REPAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_CUM_CAPITAL_REPAYMENTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_EX_CAPITAL_REPAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_EX_CAPITAL_REPAYMENTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_CASH_SETTLEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_CASH_SETTLEMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_SPECIAL_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_SPECIAL_PRICE);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_REPORT_FOR_EUROPEAN_EQUITY_MARKET_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_REPORT_FOR_EUROPEAN_EQUITY_MARKET_SECURITIES);
  return _val;
}


SWIGINTERN VALUE
_wrap_StipulationValue_GUARANTEED_DELIVERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::StipulationValue_GUARANTEED_DELIVERY);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_AFTER_TAX_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_AFTER_TAX_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_ANNUAL_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_ANNUAL_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_AT_ISSUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_AT_ISSUE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_AVERAGE_MATURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_AVERAGE_MATURITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_BOOK_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_BOOK_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_NEXT_CALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_NEXT_CALL);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_CHANGE_SINCE_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_CHANGE_SINCE_CLOSE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_CLOSING_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_CLOSING_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_COMPOUND_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_COMPOUND_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_CURRENT_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_CURRENT_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_TRUE_GROSS_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_TRUE_GROSS_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_GOVERNMENT_EQUIVALENT_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_GOVERNMENT_EQUIVALENT_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_WITH_INFLATION_ASSUMPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_WITH_INFLATION_ASSUMPTION);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_INVERSE_FLOATER_BOND_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_INVERSE_FLOATER_BOND_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_MOST_RECENT_CLOSING_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_MOST_RECENT_CLOSING_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_MONTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_CLOSING_YIELD_MOST_RECENT_MONTH);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_QUARTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_CLOSING_YIELD_MOST_RECENT_QUARTER);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_CLOSING_YIELD_MOST_RECENT_YEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_LONGEST_AVERAGE_LIFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_LONGEST_AVERAGE_LIFE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_MARK_TO_MARKET_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_MARK_TO_MARKET_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_MATURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_MATURITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_NEXT_REFUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_NEXT_REFUND);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_OPEN_AVERAGE_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_OPEN_AVERAGE_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_NEXT_PUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_NEXT_PUT);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_PREVIOUS_CLOSE_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_PREVIOUS_CLOSE_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_PROCEEDS_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_PROCEEDS_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_SEMI_ANNUAL_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_SEMI_ANNUAL_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_SHORTEST_AVERAGE_LIFE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_SHORTEST_AVERAGE_LIFE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_SIMPLE_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_SIMPLE_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_TAX_EQUIVALENT_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_TAX_EQUIVALENT_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_TENDER_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_TENDER_DATE);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_TRUE_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_TRUE_YIELD);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_VALUE_OF_1_32_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_VALUE_OF_1_32);
  return _val;
}


SWIGINTERN VALUE
_wrap_YieldType_YIELD_TO_WORST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::YieldType_YIELD_TO_WORST);
  return _val;
}


SWIGINTERN VALUE
_wrap_SubscriptionRequestType_SNAPSHOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SubscriptionRequestType_SNAPSHOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SubscriptionRequestType_SNAPSHOT_PLUS_UPDATES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SubscriptionRequestType_SNAPSHOT_PLUS_UPDATES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SubscriptionRequestType_DISABLE_PREVIOUS_SNAPSHOT_PLUS_UPDATE_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SubscriptionRequestType_DISABLE_PREVIOUS_SNAPSHOT_PLUS_UPDATE_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateType_FULL_REFRESH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDUpdateType_FULL_REFRESH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateType_INCREMENTAL_REFRESH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MDUpdateType_INCREMENTAL_REFRESH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_BID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_BID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_OFFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_OFFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_INDEX_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_INDEX_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_OPENING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_OPENING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_CLOSING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_CLOSING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_SETTLEMENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_SETTLEMENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TRADING_SESSION_HIGH_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TRADING_SESSION_HIGH_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TRADING_SESSION_LOW_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TRADING_SESSION_LOW_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TRADING_SESSION_VWAP_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TRADING_SESSION_VWAP_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_TRADE_VOLUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_TRADE_VOLUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDEntryType_OPEN_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDEntryType_OPEN_INTEREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickDirection_PLUS_TICK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TickDirection_PLUS_TICK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickDirection_ZERO_PLUS_TICK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TickDirection_ZERO_PLUS_TICK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickDirection_MINUS_TICK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TickDirection_MINUS_TICK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TickDirection_ZERO_MINUS_TICK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TickDirection_ZERO_MINUS_TICK));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_OPEN_ACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteCondition_OPEN_ACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_CLOSED_INACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteCondition_CLOSED_INACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_EXCHANGE_BEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteCondition_EXCHANGE_BEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_CONSOLIDATED_BEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteCondition_CONSOLIDATED_BEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_LOCKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteCondition_LOCKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_CROSSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteCondition_CROSSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_DEPTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteCondition_DEPTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_FAST_TRADING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteCondition_FAST_TRADING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCondition_NON_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::QuoteCondition_NON_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CASH_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_CASH_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_AVERAGE_PRICE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_AVERAGE_PRICE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_CASH_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_CASH_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_NEXT_DAY_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_NEXT_DAY_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OPENING_REOPENING_TRADE_DETAIL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_OPENING_REOPENING_TRADE_DETAIL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_INTRADAY_TRADE_DETAIL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_INTRADAY_TRADE_DETAIL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_RULE127_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_RULE127));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_RULE155_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_RULE155));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SOLD_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_SOLD_LAST));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_NEXT_DAY_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_NEXT_DAY_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OPENED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_OPENED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SELLER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_SELLER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_SOLD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_SOLD));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_STOPPED_STOCK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_STOPPED_STOCK));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_IMBALANCE_MORE_BUYERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_IMBALANCE_MORE_BUYERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_IMBALANCE_MORE_SELLERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_IMBALANCE_MORE_SELLERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeCondition_OPENING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::TradeCondition_OPENING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateAction_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDUpdateAction_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateAction_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDUpdateAction_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDUpdateAction_DELETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDUpdateAction_DELETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_DUPLICATE_MDREQID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_DUPLICATE_MDREQID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_INSUFFICIENT_BANDWIDTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_INSUFFICIENT_BANDWIDTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_INSUFFICIENT_PERMISSIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_INSUFFICIENT_PERMISSIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_SUBSCRIPTIONREQUESTTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_SUBSCRIPTIONREQUESTTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_MARKETDEPTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_MARKETDEPTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_MDUPDATETYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_MDUPDATETYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_AGGREGATEDBOOK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_AGGREGATEDBOOK));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_MDENTRYTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_MDENTRYTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_TRADINGSESSIONID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_TRADINGSESSIONID));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_SCOPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_SCOPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_OPENCLOSESETTLEFLAG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_OPENCLOSESETTLEFLAG));
  return _val;
}


SWIGINTERN VALUE
_wrap_MDReqRejReason_UNSUPPORTED_MDIMPLICITDELETE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MDReqRejReason_UNSUPPORTED_MDIMPLICITDELETE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeleteReason_CANCELATION_TRADE_BUST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DeleteReason_CANCELATION_TRADE_BUST));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeleteReason_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DeleteReason_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_DAILY_OPEN_CLOSE_SETTLEMENT_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_DAILY_OPEN_CLOSE_SETTLEMENT_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_SESSION_OPEN_CLOSE_SETTLEMENT_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_SESSION_OPEN_CLOSE_SETTLEMENT_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_DELIVERY_SETTLEMENT_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_DELIVERY_SETTLEMENT_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_EXPECTED_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_EXPECTED_ENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettlFlag_THEORETICAL_PRICE_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettlFlag_THEORETICAL_PRICE_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_FinancialStatus_BANKRUPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::FinancialStatus_BANKRUPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_FinancialStatus_PENDING_DELISTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::FinancialStatus_PENDING_DELISTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_EX_DIVIDEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_EX_DIVIDEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_EX_DISTRIBUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_EX_DISTRIBUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_EX_RIGHTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_EX_RIGHTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_CorporateAction_EX_INTEREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CorporateAction_EX_INTEREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_FOR_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_FOR_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_FOR_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_FOR_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_FOR_UNDERLYING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_FOR_UNDERLYING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_ALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_ALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_REMOVED_FROM_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_REMOVED_FROM_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_QUERY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_QUERY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_QUOTE_NOT_FOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_QUOTE_NOT_FOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_PASS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_PASS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_LOCKED_MARKET_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_LOCKED_MARKET_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CROSS_MARKET_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CROSS_MARKET_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_DUE_TO_LOCK_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_DUE_TO_LOCK_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteStatus_CANCELED_DUE_TO_CROSS_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteStatus_CANCELED_DUE_TO_CROSS_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_FOR_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_FOR_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_FOR_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_FOR_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_FOR_UNDERLYING_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_FOR_UNDERLYING_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteCancelType_CANCEL_ALL_QUOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteCancelType_CANCEL_ALL_QUOTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_EXCHANGE_CLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_EXCHANGE_CLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_TOO_LATE_TO_ENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_TOO_LATE_TO_ENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_UNKNOWN_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_UNKNOWN_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_DUPLICATE_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_DUPLICATE_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_INVALID_BID_ASK_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_INVALID_BID_ASK_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_INVALID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_INVALID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteResponseLevel_NO_ACKNOWLEDGEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteResponseLevel_NO_ACKNOWLEDGEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteResponseLevel_ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteResponseLevel_ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteResponseLevel_ACKNOWLEDGE_EACH_QUOTE_MESSAGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteResponseLevel_ACKNOWLEDGE_EACH_QUOTE_MESSAGES));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestType_MANUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestType_MANUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestType_AUTOMATIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestType_AUTOMATIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_REQUEST_SECURITY_IDENTITY_FOR_THE_SPECIFICATIONS_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_REQUEST_SECURITY_IDENTITY_FOR_THE_SPECIFICATIONS_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_REQUEST_LIST_SECURITY_TYPES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_REQUEST_LIST_SECURITY_TYPES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestType_REQUEST_LIST_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestType_REQUEST_LIST_SECURITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_ACCEPT_SECURITY_PROPOSAL_AS_IS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_ACCEPT_SECURITY_PROPOSAL_AS_IS));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_ACCEPT_SECURITY_PROPOSAL_WITH_REVISIONS_AS_INDICATED_IN_THE_MESSAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_ACCEPT_SECURITY_PROPOSAL_WITH_REVISIONS_AS_INDICATED_IN_THE_MESSAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_LIST_OF_SECURITY_TYPES_RETURNED_PER_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_LIST_OF_SECURITY_TYPES_RETURNED_PER_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_LIST_OF_SECURITIES_RETURNED_PER_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_LIST_OF_SECURITIES_RETURNED_PER_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_REJECT_SECURITY_PROPOSAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_REJECT_SECURITY_PROPOSAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityResponseType_CAN_NOT_MATCH_SELECTION_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityResponseType_CAN_NOT_MATCH_SELECTION_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_OPENING_DELAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_OPENING_DELAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_TRADING_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_TRADING_HALT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_RESUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_RESUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NO_OPEN_NO_RESUME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NO_OPEN_NO_RESUME));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_PRICE_INDICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_PRICE_INDICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_TRADING_RANGE_INDICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_TRADING_RANGE_INDICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_MARKET_IMBALANCE_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_MARKET_IMBALANCE_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_MARKET_IMBALANCE_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_MARKET_IMBALANCE_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_BUY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_BUY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_SELL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_SELL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NOT_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NOT_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NO_MARKET_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NO_MARKET_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NO_MARKET_ON_CLOSE_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NO_MARKET_ON_CLOSE_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_ITS_PRE_OPENING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_ITS_PRE_OPENING));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NEW_PRICE_INDICATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NEW_PRICE_INDICATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_TRADE_DISSEMINATION_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_TRADE_DISSEMINATION_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_READY_TO_TRADE_START_OF_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_READY_TO_TRADE_START_OF_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NOT_AVAILABLE_FOR_TRADING_END_OF_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NOT_AVAILABLE_FOR_TRADING_END_OF_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_NOT_TRADED_ON_THIS_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_NOT_TRADED_ON_THIS_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_UNKNOWN_OR_INVALID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_UNKNOWN_OR_INVALID));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_PRE_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_PRE_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_OPENING_ROTATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_OPENING_ROTATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityTradingStatus_FAST_MARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityTradingStatus_FAST_MARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReason_ORDER_IMBALANCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReason_ORDER_IMBALANCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReason_EQUIPMENT_CHANGEOVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReason_EQUIPMENT_CHANGEOVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReason_NEWS_PENDING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReason_NEWS_PENDING));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReason_NEWS_DISSEMINATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReason_NEWS_DISSEMINATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReason_ORDER_INFLUX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReason_ORDER_INFLUX));
  return _val;
}


SWIGINTERN VALUE
_wrap_HaltReason_ADDITIONAL_INFORMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::HaltReason_ADDITIONAL_INFORMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_Adjustment_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Adjustment_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Adjustment_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Adjustment_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Adjustment_CORRECTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Adjustment_CORRECTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMethod_ELECTRONIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMethod_ELECTRONIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMethod_OPEN_OUTCRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMethod_OPEN_OUTCRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMethod_TWO_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMethod_TWO_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMode_TESTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMode_TESTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMode_SIMULATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMode_SIMULATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesMode_PRODUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesMode_PRODUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_UNKNOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_UNKNOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_HALTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_HALTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_CLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_CLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_PRE_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_PRE_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_PRE_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_PRE_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatus_REQUEST_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatus_REQUEST_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MessageEncoding_ISO_2022_JP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MessageEncoding_ISO_2022_JP);
  return _val;
}


SWIGINTERN VALUE
_wrap_MessageEncoding_EUC_JP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MessageEncoding_EUC_JP);
  return _val;
}


SWIGINTERN VALUE
_wrap_MessageEncoding_SHIFT_JIS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MessageEncoding_SHIFT_JIS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MessageEncoding_UTF_8_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MessageEncoding_UTF_8);
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_EXCHANGE_CLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_EXCHANGE_CLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_QUOTE_EXCEEDS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_QUOTE_EXCEEDS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_TOO_LATE_TO_ENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_TOO_LATE_TO_ENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_UNKNOWN_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_UNKNOWN_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_DUPLICATE_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_DUPLICATE_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_INVALID_BID_ASK_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_INVALID_BID_ASK_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_INVALID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_INVALID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteEntryRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteEntryRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INVALID_TAG_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INVALID_TAG_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_REQUIRED_TAG_MISSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_REQUIRED_TAG_MISSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_UNDEFINED_TAG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_UNDEFINED_TAG));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_VALUE_IS_INCORRECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_VALUE_IS_INCORRECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_DECRYPTION_PROBLEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_DECRYPTION_PROBLEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_SIGNATURE_PROBLEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_SIGNATURE_PROBLEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_COMPID_PROBLEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_COMPID_PROBLEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INVALID_MSGTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INVALID_MSGTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_XML_VALIDATION_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_XML_VALIDATION_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_REPEATING_GROUP_FIELDS_OUT_OF_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_REPEATING_GROUP_FIELDS_OUT_OF_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SessionRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidRequestTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidRequestTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidRequestTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidRequestTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_GT_CORPORATE_ACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_GT_CORPORATE_ACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_GT_RENEWAL_RESTATEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_GT_RENEWAL_RESTATEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_VERBAL_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_VERBAL_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_REPRICING_OF_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_REPRICING_OF_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_BROKER_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_BROKER_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_PARTIAL_DECLINE_OF_ORDERQTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_PARTIAL_DECLINE_OF_ORDERQTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CANCEL_ON_TRADING_HALT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CANCEL_ON_TRADING_HALT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CANCEL_ON_SYSTEM_FAILURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CANCEL_ON_SYSTEM_FAILURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_MARKET_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_MARKET_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecRestatementReason_CANCELED_NOT_BEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExecRestatementReason_CANCELED_NOT_BEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNKOWN_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_UNKOWN_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNKNOWN_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_UNKNOWN_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_APPLICATION_NOT_AVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_APPLICATION_NOT_AVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_NOT_AUTHORIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_NOT_AUTHORIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BusinessRejectReason_DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgDirection_SEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MsgDirection_SEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_MsgDirection_RECEIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MsgDirection_RECEIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_DISPLAYED_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_DISPLAYED_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_MARKET_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_MARKET_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_PRIMARY_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_PRIMARY_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_LOCAL_PRIMARY_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_LOCAL_PRIMARY_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_MIDPOINT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_MIDPOINT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_LAST_TRADE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_LAST_TRADE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionInst_RELATED_TO_VWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DiscretionInst_RELATED_TO_VWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidType_NON_DISCLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidType_NON_DISCLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidType_DISCLOSED_STYLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidType_DISCLOSED_STYLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidType_NO_BIDDING_PROCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidType_NO_BIDDING_PROCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidDescriptorType_SECTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidDescriptorType_SECTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidDescriptorType_COUNTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidDescriptorType_COUNTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidDescriptorType_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BidDescriptorType_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideValueInd_SIDEVALUE1_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideValueInd_SIDEVALUE1));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideValueInd_SIDEVALUE2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideValueInd_SIDEVALUE2));
  return _val;
}


SWIGINTERN VALUE
_wrap_LiquidityIndType_FIVEDAY_MOVING_AVERAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LiquidityIndType_FIVEDAY_MOVING_AVERAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LiquidityIndType_TWENTYDAY_MOVING_AVERAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LiquidityIndType_TWENTYDAY_MOVING_AVERAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LiquidityIndType_NORMAL_MARKET_SIZE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LiquidityIndType_NORMAL_MARKET_SIZE));
  return _val;
}


SWIGINTERN VALUE
_wrap_LiquidityIndType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LiquidityIndType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProgRptReqs_BUYSIDE_EXPLICITLY_REQUESTS_STATUS_USING_STATUSREQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProgRptReqs_BUYSIDE_EXPLICITLY_REQUESTS_STATUS_USING_STATUSREQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProgRptReqs_SELLSIDE_PERIODICALLY_SENDS_STATUS_USING_LISTSTATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProgRptReqs_SELLSIDE_PERIODICALLY_SENDS_STATUS_USING_LISTSTATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ProgRptReqs_REAL_TIME_EXECUTION_REPORTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ProgRptReqs_REAL_TIME_EXECUTION_REPORTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_IncTaxInd_NET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::IncTaxInd_NET));
  return _val;
}


SWIGINTERN VALUE
_wrap_IncTaxInd_GROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::IncTaxInd_GROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidTradeType_RISK_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidTradeType_RISK_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidTradeType_VWAP_GUARANTEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidTradeType_VWAP_GUARANTEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidTradeType_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidTradeType_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BidTradeType_GUARANTEED_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BidTradeType_GUARANTEED_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_CLOSING_PRICE_AT_MORNING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_CLOSING_PRICE_AT_MORNING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_CLOSING_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_CLOSING_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_CURRENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_CURRENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_SQ_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_SQ));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_A_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_A_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_A_MORNING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_A_DAY_EXCEPT_YORI_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_A_DAY_EXCEPT_YORI));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_YORI_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_YORI));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_YORI_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_YORI));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_STRIKE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_STRIKE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_BasisPxType_OTHERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BasisPxType_OTHERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PER_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PER_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_FIXED_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_FIXED_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_DISCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_DISCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_PREMIUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_PREMIUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_TED_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_TED_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_TED_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_TED_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriceType_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriceType_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_GTBookingInst_BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::GTBookingInst_BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_GTBookingInst_ACCUMULATE_EXECUTIONS_UNTIL_ORDER_IS_FILLED_OR_EXPIRES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::GTBookingInst_ACCUMULATE_EXECUTIONS_UNTIL_ORDER_IS_FILLED_OR_EXPIRES));
  return _val;
}


SWIGINTERN VALUE
_wrap_GTBookingInst_ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::GTBookingInst_ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_ACK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_ACK));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_RESPONSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_RESPONSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_TIMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_TIMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_EXECSTARTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_EXECSTARTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_ALLDONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_ALLDONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListStatusType_ALERT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListStatusType_ALERT));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetGrossInd_NET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetGrossInd_NET));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetGrossInd_GROSS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetGrossInd_GROSS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_INBIDDINGPROCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_INBIDDINGPROCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_RECEIVEDFOREXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_RECEIVEDFOREXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_EXECUTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_EXECUTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_CANCELING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_CANCELING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_ALERT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_ALERT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_ALL_DONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_ALL_DONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListOrderStatus_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ListOrderStatus_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListExecInstType_IMMEDIATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListExecInstType_IMMEDIATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListExecInstType_WAIT_FOR_EXECUTE_INSTRUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListExecInstType_WAIT_FOR_EXECUTE_INSTRUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_SELL_DRIVEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_SELL_DRIVEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_TOP_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_TOP_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_WITHDRAW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_WITHDRAW));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejResponseTo_ORDER_CANCEL_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CxlRejResponseTo_ORDER_CANCEL_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlRejResponseTo_ORDER_CANCEL_REPLACE_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CxlRejResponseTo_ORDER_CANCEL_REPLACE_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegReportingType_SINGLE_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MultiLegReportingType_SINGLE_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegReportingType_MULTI_LEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MultiLegReportingType_MULTI_LEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_BIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_BIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_GENERALLY_ACCEPTED_MARKET_PARTICIPANT_IDENTIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_GENERALLY_ACCEPTED_MARKET_PARTICIPANT_IDENTIFIER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_PROPRIETARY_CUSTOM_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_PROPRIETARY_CUSTOM_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_ISO_COUNTRY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_ISO_COUNTRY_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_SETTLEMENT_ENTITY_LOCATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_SETTLEMENT_ENTITY_LOCATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_MIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_MIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_CSD_PARTICIPANT_MEMBER_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_CSD_PARTICIPANT_MEMBER_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_KOREAN_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_KOREAN_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_TAIWANESE_QUALIFIED_FOREIGN_INVESTOR_ID_QFII_FID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_TAIWANESE_QUALIFIED_FOREIGN_INVESTOR_ID_QFII_FID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_TAIWANESE_TRADING_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_TAIWANESE_TRADING_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_MALAYSIAN_CENTRAL_DEPOSITORY_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_MALAYSIAN_CENTRAL_DEPOSITORY_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_CHINESE_B_SHARE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_CHINESE_B_SHARE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_US_SOCIAL_SECURITY_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_US_SOCIAL_SECURITY_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_US_EMPLOYER_IDENTIFICATION_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_US_EMPLOYER_IDENTIFICATION_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_AUSTRALIAN_BUSINESS_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_AUSTRALIAN_BUSINESS_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_AUSTRALIAN_TAX_FILE_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_AUSTRALIAN_TAX_FILE_NUMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyIDSource_DIRECTED_BROKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PartyIDSource_DIRECTED_BROKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_EXECUTING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_EXECUTING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_BROKER_OF_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_BROKER_OF_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CLIENT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CLIENT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_CLEARING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_CLEARING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_INTRODUCING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_INTRODUCING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_ENTERING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_ENTERING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_LOCATE_LENDING_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_LOCATE_LENDING_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PartyRole_FUND_MANAGER_CLIENT_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PartyRole_FUND_MANAGER_CLIENT_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_COMMODITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_COMMODITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_CORPORATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_CORPORATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_EQUITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_EQUITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_GOVERNMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_GOVERNMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_INDEX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_INDEX));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_LOAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_LOAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_MONEYMARKET_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_MONEYMARKET));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_MORTGAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_MORTGAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_MUNICIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_MUNICIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Product_FINANCING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::Product_FINANCING));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_SHARES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_SHARES));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_BONDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_BONDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_CURRENTFACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_CURRENTFACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_ORIGINALFACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_ORIGINALFACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_CURRENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_CURRENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_CONTRACTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_CONTRACTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuantityType_PAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuantityType_PAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoundingDirection_ROUND_TO_NEAREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RoundingDirection_ROUND_TO_NEAREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoundingDirection_ROUND_DOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RoundingDirection_ROUND_DOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_RoundingDirection_ROUND_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RoundingDirection_ROUND_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_CREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_CREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_NSCC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_NSCC));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_EUROCLEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_EUROCLEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_CLEARSTREAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_CLEARSTREAM));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_CHEQUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_CHEQUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_TELEGRAPHIC_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_TELEGRAPHIC_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_FEDWIRE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_FEDWIRE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_DIRECT_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_DIRECT_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DistribPaymentMethod_ACH_CREDIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DistribPaymentMethod_ACH_CREDIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CancellationRights_NO_EXECUTION_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CancellationRights_NO_EXECUTION_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CancellationRights_NO_WAIVER_AGREEMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CancellationRights_NO_WAIVER_AGREEMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CancellationRights_NO_INSTITUTIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CancellationRights_NO_INSTITUTIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_MoneyLaunderingStatus_PASSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MoneyLaunderingStatus_PASSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MoneyLaunderingStatus_NOT_CHECKED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MoneyLaunderingStatus_NOT_CHECKED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MoneyLaunderingStatus_EXEMPT_BELOW_THE_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MoneyLaunderingStatus_EXEMPT_BELOW_THE_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MoneyLaunderingStatus_EXEMPT_CLIENT_MONEY_TYPE_EXEMPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MoneyLaunderingStatus_EXEMPT_CLIENT_MONEY_TYPE_EXEMPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MoneyLaunderingStatus_EXEMPT_AUTHORISED_CREDIT_OR_FINANCIAL_INSTITUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MoneyLaunderingStatus_EXEMPT_AUTHORISED_CREDIT_OR_FINANCIAL_INSTITUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_BID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_BID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_CREATION_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_CREATION_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_OFFER_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_OFFER_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecPriceType_SINGLE_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecPriceType_SINGLE_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_RELEASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_RELEASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportTransType_REVERSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportTransType_REVERSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_CREST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_CREST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_NSCC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_NSCC));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_EUROCLEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_EUROCLEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_CLEARSTREAM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_CLEARSTREAM));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_CHEQUE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_CHEQUE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_TELEGRAPHIC_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_TELEGRAPHIC_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_FEDWIRE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_FEDWIRE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_DEBIT_CARD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_DEBIT_CARD));
  return _val;
}


SWIGINTERN VALUE
_wrap_PaymentMethod_DIRECT_DEBIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PaymentMethod_DIRECT_DEBIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_MAXI_ISA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_MAXI_ISA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_TESSA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_TESSA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_MINI_CASH_ISA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_MINI_CASH_ISA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_MINI_STOCKS_AND_SHARES_ISA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_MINI_STOCKS_AND_SHARES_ISA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_MINI_INSURANCE_ISA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_MINI_INSURANCE_ISA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_CURRENT_YEAR_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_CURRENT_YEAR_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_PRIOR_YEAR_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_PRIOR_YEAR_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_ASSET_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_ASSET_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_EMPLOYEE_PRIOR_YEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_EMPLOYEE_PRIOR_YEAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_TaxAdvantageType_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TaxAdvantageType_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundRenewWaiv_YES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::FundRenewWaiv_YES));
  return _val;
}


SWIGINTERN VALUE
_wrap_FundRenewWaiv_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::FundRenewWaiv_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistStatus_HELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistStatus_HELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistStatus_REMINDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistStatus_REMINDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_ACCOUNT_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_ACCOUNT_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_TAX_EXEMPT_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_TAX_EXEMPT_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_OWNERSHIP_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_OWNERSHIP_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_NO_REG_DETLS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_NO_REG_DETLS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_REG_SEQ_NO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_REG_SEQ_NO));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_REG_DTLS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_REG_DTLS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_MAILING_DTLS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_MAILING_DTLS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_MAILING_INST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_MAILING_INST));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_ID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_ID));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_ID_SOURCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_ID_SOURCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_DATE_OF_BIRTH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_DATE_OF_BIRTH));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_COUNTRY_OF_RESIDENCE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_COUNTRY_OF_RESIDENCE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_NODISTRIBINSTNS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_NODISTRIBINSTNS));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_DISTRIB_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_DISTRIB_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_DISTRIB_PAYMENT_METHOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_DISTRIB_PAYMENT_METHOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NAME));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistRejReasonCode_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::RegistRejReasonCode_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_RegistTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::RegistTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnershipType_JOINT_INVESTORS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OwnershipType_JOINT_INVESTORS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnershipType_TENANTS_IN_COMMON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OwnershipType_TENANTS_IN_COMMON));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnershipType_JOINT_TRUSTEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OwnershipType_JOINT_TRUSTEES));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_COMMISSION_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_COMMISSION_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_COMMISSION_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_COMMISSION_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_INITIAL_CHARGE_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_INITIAL_CHARGE_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_INITIAL_CHARGE_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_INITIAL_CHARGE_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_DISCOUNT_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_DISCOUNT_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_DISCOUNT_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_DISCOUNT_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_DILUTION_LEVY_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_DILUTION_LEVY_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_DILUTION_LEVY_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_DILUTION_LEVY_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ContAmtType_EXIT_CHARGE_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ContAmtType_EXIT_CHARGE_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_INDIVIDUAL_INVESTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_INDIVIDUAL_INVESTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_PUBLIC_COMPANY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_PUBLIC_COMPANY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_PRIVATE_COMPANY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_PRIVATE_COMPANY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_INDIVIDUAL_TRUSTEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_INDIVIDUAL_TRUSTEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_COMPANY_TRUSTEE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_COMPANY_TRUSTEE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_PENSION_PLAN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_PENSION_PLAN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_TRUSTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_TRUSTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_OwnerType_FIDUCIARIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::OwnerType_FIDUCIARIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_PROPRIETARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_PROPRIETARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_INDIVIDUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_INDIVIDUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_RISKLESS_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_RISKLESS_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderCapacity_AGENT_FOR_OTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderCapacity_AGENT_FOR_OTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_PROGRAM_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_PROGRAM_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_INDEX_ARBITRAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_INDEX_ARBITRAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_NON_INDEX_ARBITRAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_NON_INDEX_ARBITRAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_COMPETING_MARKET_MAKER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_COMPETING_MARKET_MAKER));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_UNDERLYING_SECURITY_OF_A_DERIVATIVE_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_UNDERLYING_SECURITY_OF_A_DERIVATIVE_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_FOREIGN_ENTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_FOREIGN_ENTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_EXTERNAL_MARKET_PARTICIPANT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_EXTERNAL_MARKET_PARTICIPANT));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OrderRestrictions_RISKLESS_ARBITRAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OrderRestrictions_RISKLESS_ARBITRAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_CFICODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_CFICODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITYTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITYTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ORDERS_FOR_A_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRequestType_CANCEL_ALL_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRequestType_CANCEL_ALL_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_REQUEST_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_REQUEST_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_CFICODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_CFICODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITYTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITYTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ORDERS_FOR_A_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelResponse_CANCEL_ALL_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelResponse_CANCEL_ALL_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_MASS_CANCEL_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRejectReason_MASS_CANCEL_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_UNDERLYING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_UNDERLYING));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_CFICODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_CFICODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MassCancelRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteType_INDICATIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteType_INDICATIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteType_TRADEABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteType_TRADEABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteType_RESTRICTED_TRADEABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteType_RESTRICTED_TRADEABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteType_COUNTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteType_COUNTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashMargin_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CashMargin_CASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashMargin_MARGIN_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CashMargin_MARGIN_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_CashMargin_MARGIN_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CashMargin_MARGIN_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Scope_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Scope_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Scope_NATIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Scope_NATIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Scope_GLOBAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Scope_GLOBAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_CROSS_TRADE_WHICH_IS_EXECUTED_COMPLETELY_OR_NOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_CROSS_TRADE_WHICH_IS_EXECUTED_COMPLETELY_OR_NOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_CROSS_TRADE_WHICH_IS_EXECUTED_PARTIALLY_AND_THE_REST_IS_CANCELLED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_CROSS_TRADE_WHICH_IS_EXECUTED_PARTIALLY_AND_THE_REST_IS_CANCELLED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_CROSS_TRADE_WHICH_IS_PARTIALLY_EXECUTED_WITH_THE_UNFILLED_PORTIONS_REMAINING_ACTIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_CROSS_TRADE_WHICH_IS_PARTIALLY_EXECUTED_WITH_THE_UNFILLED_PORTIONS_REMAINING_ACTIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossType_CROSS_TRADE_IS_EXECUTED_WITH_EXISTING_ORDERS_WITH_THE_SAME_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossType_CROSS_TRADE_IS_EXECUTED_WITH_EXISTING_ORDERS_WITH_THE_SAME_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossPrioritization_NONE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossPrioritization_NONE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossPrioritization_BUY_SIDE_IS_PRIORITIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossPrioritization_BUY_SIDE_IS_PRIORITIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CrossPrioritization_SELL_SIDE_IS_PRIORITIZED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CrossPrioritization_SELL_SIDE_IS_PRIORITIZED));
  return _val;
}


SWIGINTERN VALUE
_wrap_NoSides_ONE_SIDE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::NoSides_ONE_SIDE));
  return _val;
}


SWIGINTERN VALUE
_wrap_NoSides_BOTH_SIDES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::NoSides_BOTH_SIDES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_SECURITYTYPE_AND_OR_CFICODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_SECURITYTYPE_AND_OR_CFICODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_TRADINGSESSIONID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_TRADINGSESSIONID));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityListRequestType_ALL_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityListRequestType_ALL_SECURITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_VALID_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_VALID_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_INVALID_OR_UNSUPPORTED_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_INVALID_OR_UNSUPPORTED_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_NO_INSTRUMENTS_FOUND_THAT_MATCH_SELECTION_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_NO_INSTRUMENTS_FOUND_THAT_MATCH_SELECTION_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SecurityRequestResult_REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SecurityRequestResult_REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegRptTypeReq_REPORT_BY_MULITLEG_SECURITY_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultiLegRptTypeReq_REPORT_BY_MULITLEG_SECURITY_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegRptTypeReq_REPORT_BY_MULTILEG_SECURITY_AND_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultiLegRptTypeReq_REPORT_BY_MULTILEG_SECURITY_AND_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MultiLegRptTypeReq_REPORT_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MultiLegRptTypeReq_REPORT_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradSesStatusRejReason_UNKNOWN_OR_INVALID_TRADINGSESSIONID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradSesStatusRejReason_UNKNOWN_OR_INVALID_TRADINGSESSIONID));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestType_ALL_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestType_ALL_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestType_MATCHED_TRADES_MATCHING_CRITERIA_PROVIDED_ON_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestType_MATCHED_TRADES_MATCHING_CRITERIA_PROVIDED_ON_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestType_UNMATCHED_TRADES_THAT_MATCH_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestType_UNMATCHED_TRADES_THAT_MATCH_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestType_UNREPORTED_TRADES_THAT_MATCH_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestType_UNREPORTED_TRADES_THAT_MATCH_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestType_ADVISORIES_THAT_MATCH_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestType_ADVISORIES_THAT_MATCH_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchStatus_COMPARED_MATCHED_OR_AFFIRMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MatchStatus_COMPARED_MATCHED_OR_AFFIRMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchStatus_UNCOMPARED_UNMATCHED_OR_UNAFFIRMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MatchStatus_UNCOMPARED_UNMATCHED_OR_UNAFFIRMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MatchStatus_ADVISORY_OR_ALERT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::MatchStatus_ADVISORY_OR_ALERT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_PROCESS_NORMALLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_PROCESS_NORMALLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_EXCLUDE_FROM_ALL_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_EXCLUDE_FROM_ALL_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_BILATERAL_NETTING_ONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_BILATERAL_NETTING_ONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_EX_CLEARING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_EX_CLEARING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_SPECIAL_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_SPECIAL_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_MULTILATERAL_NETTING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_MULTILATERAL_NETTING));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_CLEAR_AGAINST_CENTRAL_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_CLEAR_AGAINST_CENTRAL_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_EXCLUDE_FROM_CENTRAL_COUNTERPARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_EXCLUDE_FROM_CENTRAL_COUNTERPARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_MANUAL_MODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_MANUAL_MODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingInstruction_AUTOMATIC_POSTING_MODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ClearingInstruction_AUTOMATIC_POSTING_MODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_HOUSE_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_HOUSE_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_FLOOR_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_FLOOR_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AccountType_JOINT_BACKOFFICE_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AccountType_JOINT_BACKOFFICE_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustOrderCapacity_ALL_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustOrderCapacity_ALL_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PRODUCT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PRODUCT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_CFICODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_CFICODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITYTYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITYTYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ALL_ORDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ALL_ORDERS));
  return _val;
}


SWIGINTERN VALUE
_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PARTYID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PARTYID));
  return _val;
}


SWIGINTERN VALUE
_wrap_DayBookingInst_CAN_TRIGGER_BOOKING_WITHOUT_REFERENCE_TO_THE_ORDER_INITIATOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DayBookingInst_CAN_TRIGGER_BOOKING_WITHOUT_REFERENCE_TO_THE_ORDER_INITIATOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_DayBookingInst_SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DayBookingInst_SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING));
  return _val;
}


SWIGINTERN VALUE
_wrap_DayBookingInst_ACCUMULATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DayBookingInst_ACCUMULATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingUnit_EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BookingUnit_EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingUnit_AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_AND_BOOK_ONE_TRADE_PER_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BookingUnit_AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_AND_BOOK_ONE_TRADE_PER_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingUnit_AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_SIDE_AND_SETTLEMENT_DATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::BookingUnit_AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_SIDE_AND_SETTLEMENT_DATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PreallocMethod_PRO_RATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PreallocMethod_PRO_RATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_PreallocMethod_DO_NOT_PRO_RATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::PreallocMethod_DO_NOT_PRO_RATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_CALCULATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_CALCULATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_READY_TO_BOOK_SINGLE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_READY_TO_BOOK_SINGLE_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_WAREHOUSE_INSTRUCTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_WAREHOUSE_INSTRUCTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocType_REQUEST_TO_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocType_REQUEST_TO_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_CBOE_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_CBOE_MEMBER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_NON_MEMBER_AND_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_NON_MEMBER_AND_CUSTOMER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_EQUITY_MEMBER_AND_CLEARING_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_EQUITY_MEMBER_AND_CLEARING_MEMBER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_FULL_AND_ASSOCIATE_MEMBER_TRADING_FOR_OWN_ACCOUNT_AND_AS_FLOOR_BROKERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_FULL_AND_ASSOCIATE_MEMBER_TRADING_FOR_OWN_ACCOUNT_AND_AS_FLOOR_BROKERS);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_FIRMS_106H_AND_106J_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_FIRMS_106H_AND_106J);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_GIM_IDEM_AND_COM_MEMBERSHIP_INTEREST_HOLDERS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_GIM_IDEM_AND_COM_MEMBERSHIP_INTEREST_HOLDERS);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_LESSEE_AND_106F_EMPLOYEES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_LESSEE_AND_106F_EMPLOYEES);
  return _val;
}


SWIGINTERN VALUE
_wrap_ClearingFeeIndicator_ALL_OTHER_OWNERSHIP_TYPES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ClearingFeeIndicator_ALL_OTHER_OWNERSHIP_TYPES);
  return _val;
}


SWIGINTERN VALUE
_wrap_PriorityIndicator_PRIORITY_UNCHANGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriorityIndicator_PRIORITY_UNCHANGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PriorityIndicator_LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PriorityIndicator_LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_UNKNOWN_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_UNKNOWN_SYMBOL));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_EXCHANGE_CLOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_EXCHANGE_CLOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_TOO_LATE_TO_ENTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_TOO_LATE_TO_ENTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_INVALID_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_INVALID_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_NOT_AUTHORIZED_TO_REQUEST_QUOTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_NOT_AUTHORIZED_TO_REQUEST_QUOTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_NO_MATCH_FOR_INQUIRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_NO_MATCH_FOR_INQUIRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_NO_MARKET_FOR_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_NO_MARKET_FOR_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRequestRejectReason_NO_INVENTORY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRequestRejectReason_NO_INVENTORY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_BIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_BIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_SID_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_SID_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_TFM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_TFM));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_OMGEO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_OMGEO));
  return _val;
}


SWIGINTERN VALUE
_wrap_AcctIDSource_DTCC_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AcctIDSource_DTCC_CODE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmStatus_MISMATCHED_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmStatus_MISMATCHED_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmStatus_MISSING_SETTLEMENT_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmStatus_MISSING_SETTLEMENT_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmStatus_CONFIRMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmStatus_CONFIRMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmStatus_REQUEST_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmStatus_REQUEST_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryForm_BOOKENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryForm_BOOKENTRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryForm_BEARER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryForm_BEARER));
  return _val;
}


SWIGINTERN VALUE
_wrap_LegSwapType_PAR_FOR_PAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LegSwapType_PAR_FOR_PAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_LegSwapType_MODIFIED_DURATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LegSwapType_MODIFIED_DURATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_LegSwapType_RISK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LegSwapType_RISK));
  return _val;
}


SWIGINTERN VALUE
_wrap_LegSwapType_PROCEEDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LegSwapType_PROCEEDS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PERCENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PERCENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PER_SHARE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PER_SHARE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_FIXED_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_FIXED_AMOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_DISCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_DISCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_PREMIUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_PREMIUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_BASIS_POINTS_RELATIVE_TO_BENCHMARK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_BASIS_POINTS_RELATIVE_TO_BENCHMARK));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_TED_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_TED_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_TED_YIELD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_TED_YIELD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuotePriceType_YIELD_SPREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuotePriceType_YIELD_SPREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_HIT_LIFT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_HIT_LIFT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_COUNTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_COUNTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_EXPIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_EXPIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_COVER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_COVER));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_DONE_AWAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_DONE_AWAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_QuoteRespType_PASS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QuoteRespType_PASS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_TRANSACTION_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_TRANSACTION_QUANTITY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_INTRA_SPREAD_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_INTRA_SPREAD_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_INTER_SPREAD_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_INTER_SPREAD_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_END_OF_DAY_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_END_OF_DAY_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_START_OF_DAY_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_START_OF_DAY_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_OPTION_EXERCISE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_OPTION_EXERCISE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_OPTION_ASSIGNMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_OPTION_ASSIGNMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_TRANSACTION_FROM_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_TRANSACTION_FROM_EXERCISE);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_TRANSACTION_FROM_ASSIGNMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_TRANSACTION_FROM_ASSIGNMENT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_PIT_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_PIT_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_TRANSFER_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_TRANSFER_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_ELECTRONIC_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_ELECTRONIC_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_ALLOCATION_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_ALLOCATION_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_ADJUSTMENT_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_ADJUSTMENT_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_AS_OF_TRADE_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_AS_OF_TRADE_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_DELIVERY_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_DELIVERY_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_TOTAL_TRANSACTION_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_TOTAL_TRANSACTION_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_CROSS_MARGIN_QTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_CROSS_MARGIN_QTY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosType_INTEGRAL_SPLIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosType_INTEGRAL_SPLIT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosQtyStatus_SUBMITTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosQtyStatus_SUBMITTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosQtyStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosQtyStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosQtyStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosQtyStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_FINAL_MARK_TO_MARKET_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_FINAL_MARK_TO_MARKET_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_INCREMENTAL_MARK_TO_MARKET_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_INCREMENTAL_MARK_TO_MARKET_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_TRADE_VARIATION_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_TRADE_VARIATION_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_START_OF_DAY_MARK_TO_MARKET_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_START_OF_DAY_MARK_TO_MARKET_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_PREMIUM_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_PREMIUM_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_CASH_RESIDUAL_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_CASH_RESIDUAL_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_CASH_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_CASH_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosAmtType_VALUE_ADJUSTED_AMOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PosAmtType_VALUE_ADJUSTED_AMOUNT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_DO_NOT_EXERCISE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_DO_NOT_EXERCISE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_POSITION_ADJUSTMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_POSITION_ADJUSTMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_POSITION_CHANGE_SUBMISSION_MARGIN_DISPOSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_POSITION_CHANGE_SUBMISSION_MARGIN_DISPOSITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosTransType_PLEDGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosTransType_PLEDGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintAction_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintAction_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintAction_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintAction_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintAction_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintAction_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdjustmentType_PROCESS_REQUEST_AS_MARGIN_DISPOSITION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AdjustmentType_PROCESS_REQUEST_AS_MARGIN_DISPOSITION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdjustmentType_DELTA_PLUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AdjustmentType_DELTA_PLUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdjustmentType_DELTA_MINUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AdjustmentType_DELTA_MINUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AdjustmentType_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AdjustmentType_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintStatus_ACCEPTED_WITH_WARNINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintStatus_ACCEPTED_WITH_WARNINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintStatus_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintStatus_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintStatus_COMPLETED_WITH_WARNINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintStatus_COMPLETED_WITH_WARNINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintResult_SUCCESSFUL_COMPLETION_NO_WARNINGS_OR_ERRORS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintResult_SUCCESSFUL_COMPLETION_NO_WARNINGS_OR_ERRORS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosMaintResult_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosMaintResult_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_POSITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_EXERCISES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_EXERCISES));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqType_ASSIGNMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqType_ASSIGNMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ResponseTransportType_INBAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ResponseTransportType_INBAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_ResponseTransportType_OUT_OF_BAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ResponseTransportType_OUT_OF_BAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_VALID_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_VALID_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_INVALID_OR_UNSUPPORTED_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_INVALID_OR_UNSUPPORTED_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_NOT_AUTHORIZED_TO_REQUEST_POSITIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_NOT_AUTHORIZED_TO_REQUEST_POSITIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_REQUEST_FOR_POSITION_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_REQUEST_FOR_POSITION_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqStatus_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqStatus_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqStatus_COMPLETED_WITH_WARNINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqStatus_COMPLETED_WITH_WARNINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PosReqStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PosReqStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlPriceType_FINAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlPriceType_FINAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlPriceType_THEORETICAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlPriceType_THEORETICAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssignmentMethod_RANDOM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AssignmentMethod_RANDOM));
  return _val;
}


SWIGINTERN VALUE
_wrap_AssignmentMethod_PRORATA_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::AssignmentMethod_PRORATA));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseMethod_AUTOMATIC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExerciseMethod_AUTOMATIC));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExerciseMethod_MANUAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExerciseMethod_MANUAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_INVALID_OR_UNKNOWN_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_INVALID_OR_UNKNOWN_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_INVALID_TYPE_OF_TRADE_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_INVALID_TYPE_OF_TRADE_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_INVALID_PARTIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_INVALID_PARTIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_INVALID_TRANSPORT_TYPE_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_INVALID_TRANSPORT_TYPE_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_INVALID_DESTINATION_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_INVALID_DESTINATION_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_TRADEREQUESTTYPE_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_TRADEREQUESTTYPE_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestResult_UNAUTHORIZED_FOR_TRADE_CAPTURE_REPORT_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestResult_UNAUTHORIZED_FOR_TRADE_CAPTURE_REPORT_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestStatus_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestStatus_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeRequestStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeRequestStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_INVALID_PARTY_INFORMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_INVALID_PARTY_INFORMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_UNKNOWN_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_UNKNOWN_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_UNAUTHORIZED_TO_REPORT_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_UNAUTHORIZED_TO_REPORT_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportRejectReason_INVALID_TRADE_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportRejectReason_INVALID_TRADE_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideMultiLegReportingType_SINGLE_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideMultiLegReportingType_SINGLE_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideMultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideMultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SideMultiLegReportingType_MULTI_LEG_SECURITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SideMultiLegReportingType_MULTI_LEG_SECURITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_EXECUTION_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_EXECUTION_TIME));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_TIME_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_TIME_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_TIME_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_TIME_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_BROKER_RECEIPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_BROKER_RECEIPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRegTimestampType_BROKER_EXECUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRegTimestampType_BROKER_EXECUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmType_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmType_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmType_CONFIRMATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmType_CONFIRMATION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmType_CONFIRMATION_REQUEST_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmType_CONFIRMATION_REQUEST_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_MISMATCHED_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_MISMATCHED_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ConfirmRejReason_MISSING_SETTLEMENT_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ConfirmRejReason_MISSING_SETTLEMENT_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingType_REGULAR_BOOKING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BookingType_REGULAR_BOOKING));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingType_CFD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BookingType_CFD));
  return _val;
}


SWIGINTERN VALUE
_wrap_BookingType_TOTAL_RETURN_SWAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::BookingType_TOTAL_RETURN_SWAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocSettlInstType_USE_DEFAULT_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocSettlInstType_USE_DEFAULT_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocSettlInstType_DERIVE_FROM_PARAMETERS_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocSettlInstType_DERIVE_FROM_PARAMETERS_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocSettlInstType_FULL_DETAILS_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocSettlInstType_FULL_DETAILS_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocSettlInstType_SSI_DB_IDS_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocSettlInstType_SSI_DB_IDS_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocSettlInstType_PHONE_FOR_INSTRUCTIONS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocSettlInstType_PHONE_FOR_INSTRUCTIONS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DlvyInstType_SECURITIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DlvyInstType_SECURITIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_DlvyInstType_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::DlvyInstType_CASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_TerminationType_OVERNIGHT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TerminationType_OVERNIGHT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TerminationType_TERM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TerminationType_TERM));
  return _val;
}


SWIGINTERN VALUE
_wrap_TerminationType_FLEXIBLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TerminationType_FLEXIBLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TerminationType_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TerminationType_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstReqRejCode_UNABLE_TO_PROCESS_REQUEST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlInstReqRejCode_UNABLE_TO_PROCESS_REQUEST));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstReqRejCode_UNKNOWN_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlInstReqRejCode_UNKNOWN_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlInstReqRejCode_NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::SettlInstReqRejCode_NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_SELLSIDE_CALCULATED_USING_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_SELLSIDE_CALCULATED_USING_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_WAREHOUSE_RECAP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_WAREHOUSE_RECAP));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocReportType_REQUEST_TO_INTERMEDIARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocReportType_REQUEST_TO_INTERMEDIARY));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocCancReplaceReason_ORIGINAL_DETAILS_INCOMPLETE_INCORRECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocCancReplaceReason_ORIGINAL_DETAILS_INCOMPLETE_INCORRECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocCancReplaceReason_CHANGE_IN_UNDERLYING_ORDER_DETAILS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocCancReplaceReason_CHANGE_IN_UNDERLYING_ORDER_DETAILS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_HOUSE_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_HOUSE_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_FLOOR_TRADER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_FLOOR_TRADER));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocAccountType_JOINT_BACKOFFICE_ACCOUNT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocAccountType_JOINT_BACKOFFICE_ACCOUNT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_PENDING_ACCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_PENDING_ACCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_PENDING_RELEASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_PENDING_RELEASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_PENDING_REVERSAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_PENDING_REVERSAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_ACCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_ACCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_BLOCK_LEVEL_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_BLOCK_LEVEL_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocIntermedReqType_ACCOUNT_LEVEL_REJECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocIntermedReqType_ACCOUNT_LEVEL_REJECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueResolution_NO_ACTION_TAKEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueResolution_NO_ACTION_TAKEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueResolution_QUEUE_FLUSHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueResolution_QUEUE_FLUSHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueResolution_OVERLAY_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueResolution_OVERLAY_LAST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueResolution_END_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueResolution_END_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueAction_NO_ACTION_TAKEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueAction_NO_ACTION_TAKEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueAction_QUEUE_FLUSHED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueAction_QUEUE_FLUSHED));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueAction_OVERLAY_LAST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueAction_OVERLAY_LAST));
  return _val;
}


SWIGINTERN VALUE
_wrap_ApplQueueAction_END_SESSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ApplQueueAction_END_SESSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_AvgPxIndicator_NO_AVERAGE_PRICING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AvgPxIndicator_NO_AVERAGE_PRICING));
  return _val;
}


SWIGINTERN VALUE
_wrap_AvgPxIndicator_TRADE_IS_PART_OF_AN_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AvgPxIndicator_TRADE_IS_PART_OF_AN_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID));
  return _val;
}


SWIGINTERN VALUE
_wrap_AvgPxIndicator_LAST_TRADE_IN_THE_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AvgPxIndicator_LAST_TRADE_IN_THE_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocIndicator_ALLOCATION_NOT_REQUIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocIndicator_ALLOCATION_NOT_REQUIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocIndicator_ALLOCATION_REQUIRED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocIndicator_ALLOCATION_REQUIRED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeAllocIndicator_USE_ALLOCATION_PROVIDED_WITH_THE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeAllocIndicator_USE_ALLOCATION_PROVIDED_WITH_THE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpirationCycle_EXPIRE_ON_TRADING_SESSION_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpirationCycle_EXPIRE_ON_TRADING_SESSION_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExpirationCycle_EXPIRE_ON_TRADING_SESSION_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ExpirationCycle_EXPIRE_ON_TRADING_SESSION_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_REGULAR_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_REGULAR_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_BLOCK_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_BLOCK_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_EFP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_EFP));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_TRANSFER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_TRANSFER));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_LATE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_LATE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_T_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_T_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_WEIGHTED_AVERAGE_PRICE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_WEIGHTED_AVERAGE_PRICE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_BUNCHED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_BUNCHED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_LATE_BUNCHED_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_LATE_BUNCHED_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdType_PRIOR_REFERENCE_PRICE_TRADE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdType_PRIOR_REFERENCE_PRICE_TRADE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegMoveType_FLOATING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegMoveType_FLOATING));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegMoveType_FIXED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegMoveType_FIXED));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegOffsetType_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegOffsetType_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegOffsetType_BASIS_POINTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegOffsetType_BASIS_POINTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegOffsetType_TICKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegOffsetType_TICKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegOffsetType_PRICE_TIER_LEVEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegOffsetType_PRICE_TIER_LEVEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegLimitType_OR_BETTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegLimitType_OR_BETTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegLimitType_STRICT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegLimitType_STRICT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegLimitType_OR_WORSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegLimitType_OR_WORSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegRoundDirection_MORE_AGGRESSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegRoundDirection_MORE_AGGRESSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegRoundDirection_MORE_PASSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegRoundDirection_MORE_PASSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegScope_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegScope_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegScope_NATIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegScope_NATIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegScope_GLOBAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegScope_GLOBAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_PegScope_NATIONAL_EXCLUDING_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PegScope_NATIONAL_EXCLUDING_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionMoveType_FLOATING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionMoveType_FLOATING));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionMoveType_FIXED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionMoveType_FIXED));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionOffsetType_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionOffsetType_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionOffsetType_BASIS_POINTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionOffsetType_BASIS_POINTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionOffsetType_TICKS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionOffsetType_TICKS));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionOffsetType_PRICE_TIER_LEVEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionOffsetType_PRICE_TIER_LEVEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionLimitType_OR_BETTER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionLimitType_OR_BETTER));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionLimitType_STRICT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionLimitType_STRICT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionLimitType_OR_WORSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionLimitType_OR_WORSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionRoundDirection_MORE_AGGRESSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionRoundDirection_MORE_AGGRESSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionRoundDirection_MORE_PASSIVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionRoundDirection_MORE_PASSIVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionScope_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionScope_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionScope_NATIONAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionScope_NATIONAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionScope_GLOBAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionScope_GLOBAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_DiscretionScope_NATIONAL_EXCLUDING_LOCAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DiscretionScope_NATIONAL_EXCLUDING_LOCAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_ADDED_LIQUIDITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_ADDED_LIQUIDITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_REMOVED_LIQUIDITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_REMOVED_LIQUIDITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_LastLiquidityInd_LIQUIDITY_ROUTED_OUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::LastLiquidityInd_LIQUIDITY_ROUTED_OUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_DEALER_SOLD_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_DEALER_SOLD_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_DEALER_SOLD_SHORT_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_DEALER_SOLD_SHORT_EXEMPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_EXEMPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_QUALIFED_SERVICE_REPRESENTATIVE_OR_AUTOMATIC_GIVEUP_CONTRA_SIDE_SOLD_SHORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_QUALIFED_SERVICE_REPRESENTATIVE_OR_AUTOMATIC_GIVEUP_CONTRA_SIDE_SOLD_SHORT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ShortSaleReason_QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::ShortSaleReason_QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_QtyType_UNITS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QtyType_UNITS));
  return _val;
}


SWIGINTERN VALUE
_wrap_QtyType_CONTRACTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::QtyType_CONTRACTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_SUBMIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_SUBMIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ALLEGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ALLEGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ACCEPT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ACCEPT));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_DECLINE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_DECLINE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_ADDENDUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_ADDENDUM));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_NO_WAS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_NO_WAS));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_TRADE_REPORT_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_TRADE_REPORT_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_TradeReportType_LOCKED_IN_TRADE_BREAK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TradeReportType_LOCKED_IN_TRADE_BREAK));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocNoOrdersType_NOT_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocNoOrdersType_NOT_SPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AllocNoOrdersType_EXPLICIT_LIST_PROVIDED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AllocNoOrdersType_EXPLICIT_LIST_PROVIDED));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_PUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_PUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_CALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_CALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_TENDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_TENDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_EventType_SINKING_FUND_CALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::EventType_SINKING_FUND_CALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_FLAT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_FLAT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_ZERO_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_ZERO_COUPON));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_INTEREST_BEARING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_INTEREST_BEARING));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_NO_PERIODIC_PAYMENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_NO_PERIODIC_PAYMENTS));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_VARIABLE_RATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_VARIABLE_RATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_LESS_FEE_FOR_PUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_LESS_FEE_FOR_PUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_STEPPED_COUPON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_STEPPED_COUPON));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_COUPON_PERIOD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_COUPON_PERIOD));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstrAttribType_WHEN_AND_IF_ISSUED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::InstrAttribType_WHEN_AND_IF_ISSUED));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeBasis_ABSOLUTE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MiscFeeBasis_ABSOLUTE));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeBasis_PER_UNIT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MiscFeeBasis_PER_UNIT));
  return _val;
}


SWIGINTERN VALUE
_wrap_MiscFeeBasis_PERCENTAGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::MiscFeeBasis_PERCENTAGE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_INITIAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_INITIAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_SCHEDULED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_SCHEDULED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_TIME_WARNING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_TIME_WARNING));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_MARGIN_DEFICIENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_MARGIN_DEFICIENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_MARGIN_EXCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_MARGIN_EXCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_FORWARD_COLLATERAL_DEMAND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_FORWARD_COLLATERAL_DEMAND));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_EVENT_OF_DEFAULT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_EVENT_OF_DEFAULT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnReason_ADVERSE_TAX_EVENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnReason_ADVERSE_TAX_EVENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_TRADEDATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_TRADEDATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_GC_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_GC_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_COLLATERALINSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_COLLATERALINSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_SUBSTITUTION_ELIGIBLE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_SUBSTITUTION_ELIGIBLE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_NOT_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_NOT_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_PARTIALLY_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_PARTIALLY_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_FULLY_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_FULLY_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryQualifier_OUTSTANDING_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryQualifier_OUTSTANDING_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnTransType_REPLACE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnTransType_REPLACE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnTransType_RELEASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnTransType_RELEASE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnTransType_REVERSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnTransType_REVERSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRespType_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRespType_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRespType_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRespType_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRespType_DECLINED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRespType_DECLINED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRespType_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRespType_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_UNKNOWN_DEAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_UNKNOWN_DEAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_UNKNOWN_OR_INVALID_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_UNKNOWN_OR_INVALID_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_UNAUTHORIZED_TRANSACTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_UNAUTHORIZED_TRANSACTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_INSUFFICIENT_COLLATERAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_INSUFFICIENT_COLLATERAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_INVALID_TYPE_OF_COLLATERAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_INVALID_TYPE_OF_COLLATERAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAsgnRejectReason_EXCESSIVE_SUBSTITUTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAsgnRejectReason_EXCESSIVE_SUBSTITUTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_UNASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_UNASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_PARTIALLY_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_PARTIALLY_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_ASSIGNMENT_PROPOSED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_ASSIGNMENT_PROPOSED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_ASSIGNED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_ASSIGNED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollStatus_CHALLENGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollStatus_CHALLENGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryType_VERSUS_PAYMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryType_VERSUS_PAYMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryType_FREE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryType_FREE));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryType_TRI_PARTY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryType_TRI_PARTY));
  return _val;
}


SWIGINTERN VALUE
_wrap_DeliveryType_HOLD_IN_CUSTODY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::DeliveryType_HOLD_IN_CUSTODY));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserRequestType_LOGONUSER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserRequestType_LOGONUSER));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserRequestType_LOGOFFUSER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserRequestType_LOGOFFUSER));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserRequestType_CHANGEPASSWORDFORUSER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserRequestType_CHANGEPASSWORDFORUSER));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserRequestType_REQUEST_INDIVIDUAL_USER_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserRequestType_REQUEST_INDIVIDUAL_USER_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_LOGGED_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_LOGGED_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_NOT_LOGGED_IN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_NOT_LOGGED_IN));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_USER_NOT_RECOGNISED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_USER_NOT_RECOGNISED));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_PASSWORD_INCORRECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_PASSWORD_INCORRECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_PASSWORD_CHANGED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_PASSWORD_CHANGED));
  return _val;
}


SWIGINTERN VALUE
_wrap_UserStatus_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::UserStatus_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatusValue_CONNECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatusValue_CONNECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatusValue_NOT_CONNECTED_DOWN_EXPECTED_UP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatusValue_NOT_CONNECTED_DOWN_EXPECTED_UP));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatusValue_NOT_CONNECTED_DOWN_EXPECTED_DOWN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatusValue_NOT_CONNECTED_DOWN_EXPECTED_DOWN));
  return _val;
}


SWIGINTERN VALUE
_wrap_StatusValue_IN_PROCESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::StatusValue_IN_PROCESS));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkRequestType_SNAPSHOT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkRequestType_SNAPSHOT));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkRequestType_SUBSCRIBE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkRequestType_SUBSCRIBE));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkRequestType_STOP_SUBSCRIBING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkRequestType_STOP_SUBSCRIBING));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkRequestType_LEVEL_OF_DETAIL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkRequestType_LEVEL_OF_DETAIL));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkStatusResponseType_FULL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkStatusResponseType_FULL));
  return _val;
}


SWIGINTERN VALUE
_wrap_NetworkStatusResponseType_INCREMENTAL_UPDATE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::NetworkStatusResponseType_INCREMENTAL_UPDATE));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_TrdRptStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::TrdRptStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AffirmStatus_RECEIVED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AffirmStatus_RECEIVED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AffirmStatus_CONFIRM_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AffirmStatus_CONFIRM_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_AffirmStatus_AFFIRMED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::AffirmStatus_AFFIRMED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAction_RETAIN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAction_RETAIN));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAction_ADD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAction_ADD));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollAction_REMOVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollAction_REMOVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryStatus_ACCEPTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryStatus_ACCEPTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryStatus_ACCEPTED_WITH_WARNINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryStatus_ACCEPTED_WITH_WARNINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryStatus_COMPLETED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryStatus_COMPLETED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryStatus_COMPLETED_WITH_WARNINGS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryStatus_COMPLETED_WITH_WARNINGS));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryStatus_REJECTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryStatus_REJECTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_SUCCESSFUL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_SUCCESSFUL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_INVALID_OR_UNKNOWN_INSTRUMENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_INVALID_OR_UNKNOWN_INSTRUMENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_INVALID_OR_UNKNOWN_COLLATERAL_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_INVALID_OR_UNKNOWN_COLLATERAL_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_INVALID_PARTIES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_INVALID_PARTIES));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_INVALID_TRANSPORT_TYPE_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_INVALID_TRANSPORT_TYPE_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_INVALID_DESTINATION_REQUESTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_INVALID_DESTINATION_REQUESTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_UNAUTHORIZED_FOR_COLLATERAL_INQUIRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_UNAUTHORIZED_FOR_COLLATERAL_INQUIRY));
  return _val;
}


SWIGINTERN VALUE
_wrap_CollInquiryResult_OTHER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CollInquiryResult_OTHER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INVALID_TAG_NUMBER_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_INVALID_TAG_NUMBER_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_REQUIRED_TAG_MISSING_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_REQUIRED_TAG_MISSING_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_UNDEFINED_TAG_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_UNDEFINED_TAG_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_VALUE_IS_INCORRECT_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_VALUE_IS_INCORRECT_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_DECRYPTION_PROBLEM_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_DECRYPTION_PROBLEM_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_SIGNATURE_PROBLEM_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_SIGNATURE_PROBLEM_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_COMPID_PROBLEM_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_COMPID_PROBLEM_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INVALID_MSGTYPE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_INVALID_MSGTYPE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_OTHER_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_OTHER_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNKNOWN_ID_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_UNKNOWN_ID_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNKNOWN_SECURITY_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_UNKNOWN_SECURITY_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_APPLICATION_NOT_AVAILABLE_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_APPLICATION_NOT_AVAILABLE_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_NOT_AUTHORIZED_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_NOT_AUTHORIZED_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_BusinessRejectReason_DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_TEXT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BusinessRejectReason_DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_TEXT);
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTransType_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecTransType_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTransType_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecTransType_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTransType_CORRECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecTransType_CORRECT));
  return _val;
}


SWIGINTERN VALUE
_wrap_ExecTransType_STATUS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::ExecTransType_STATUS));
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_CUSIP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_CUSIP);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_SEDOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_SEDOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_QUIK_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_QUIK);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_ISIN_NUMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_ISIN_NUMBER);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_RIC_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_RIC_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_ISO_CURRENCY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_ISO_CURRENCY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_ISO_COUNTRY_CODE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_ISO_COUNTRY_CODE);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_EXCHANGE_SYMBOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_EXCHANGE_SYMBOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_IDSource_CONSOLIDATED_TAPE_ASSOCIATION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IDSource_CONSOLIDATED_TAPE_ASSOCIATION);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIShares_SMALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IOIShares_SMALL);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIShares_MEDIUM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IOIShares_MEDIUM);
  return _val;
}


SWIGINTERN VALUE
_wrap_IOIShares_LARGE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::IOIShares_LARGE);
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_AGENCY_SINGLE_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_AGENCY_SINGLE_ORDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_A_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_A_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_MEMBER_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_MEMBER_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_MEMBER_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_MEMBER_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_FOR_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_FOR_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_W_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_W_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_I_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_I_TYPE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_INDIVIDUAL_INVESTOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_INDIVIDUAL_INVESTOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_INDIVIDUAL_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_INDIVIDUAL_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_INDIVIDUAL_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_INDIVIDUAL_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_AFFILIATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_AFFILIATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_OTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_OTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_OTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_OTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROPRIETARY_AFFILIATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROPRIETARY_AFFILIATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PRINCIPAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PRINCIPAL));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_TRANSACTIONS_NON_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_TRANSACTIONS_NON_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SPECIALIST_TRADES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SPECIALIST_TRADES));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_TRANSACTIONS_UNAFFILIATED_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_TRANSACTIONS_UNAFFILIATED_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_OTHER_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_OTHER_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_ALL_OTHER_ORDERS_AS_AGENT_FOR_OTHER_MEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_ALL_OTHER_ORDERS_AS_AGENT_FOR_OTHER_MEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_NOT_AFFILIATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_NOT_AFFILIATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_OTHER_AGENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_OTHER_AGENCY));
  return _val;
}


SWIGINTERN VALUE
_wrap_Rule80A_SHORT_EXEMPT_NONMEMBER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Rule80A_SHORT_EXEMPT_NONMEMBER));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_REGULAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_REGULAR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_CASH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_CASH));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_NEXT_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_NEXT_DAY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_T_PLUS_2_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_T_PLUS_2));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_T_PLUS_3_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_T_PLUS_3));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_T_PLUS_4_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_T_PLUS_4));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_FUTURE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_FUTURE));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_WHEN_AND_IF_ISSUED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_WHEN_AND_IF_ISSUED));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_SELLERS_OPTION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_SELLERS_OPTION));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_T_PLUS_5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_T_PLUS_5));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlmntTyp_T_PLUS_1_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::SettlmntTyp_T_PLUS_1));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenClose_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenClose_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenClose_CLOSE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenClose_CLOSE));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlType_PARTIAL_CANCEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CxlType_PARTIAL_CANCEL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CxlType_FULL_REMAINING_QUANTITY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::CxlType_FULL_REMAINING_QUANTITY));
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_CEDEL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_CEDEL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_DEPOSITORY_TRUST_COMPANY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_DEPOSITORY_TRUST_COMPANY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_EUROCLEAR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_EUROCLEAR);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_FEDERAL_BOOK_ENTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_FEDERAL_BOOK_ENTRY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_PHYSICAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_PHYSICAL);
  return _val;
}


SWIGINTERN VALUE
_wrap_SettlLocation_PARTICIPANT_TRUST_COMPANY_ISO_COUNTRY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SettlLocation_PARTICIPANT_TRUST_COMPANY_ISO_COUNTRY);
  return _val;
}


SWIGINTERN VALUE
_wrap_PutOrCall_PUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PutOrCall_PUT));
  return _val;
}


SWIGINTERN VALUE
_wrap_PutOrCall_CALL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::PutOrCall_CALL));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustomerOrFirm_CUSTOMER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustomerOrFirm_CUSTOMER));
  return _val;
}


SWIGINTERN VALUE
_wrap_CustomerOrFirm_FIRM_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(FIX::CustomerOrFirm_FIRM));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_CURVE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_CURVE));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_FIVEYR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_FIVEYR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_OLD5_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_OLD5));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_TENYR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_TENYR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_OLD10_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_OLD10));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_THIRTYYR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_THIRTYYR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_OLD30_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_OLD30));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_THREEMOLIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_THREEMOLIBOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_Benchmark_SIXMOLIBOR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::Benchmark_SIXMOLIBOR));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_DAILY_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettleFlag_DAILY_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_SESSION_OPEN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettleFlag_SESSION_OPEN));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_DELIVERY_SETTLEMENT_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettleFlag_DELIVERY_SETTLEMENT_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_EXPECTED_PRICE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettleFlag_EXPECTED_PRICE));
  return _val;
}


SWIGINTERN VALUE
_wrap_OpenCloseSettleFlag_PRICE_FROM_PREVIOUS_BUSINESS_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(FIX::OpenCloseSettleFlag_PRICE_FROM_PREVIOUS_BUSINESS_DAY));
  return _val;
}


swig_class cSessionID;

SWIGINTERN VALUE
_wrap_new_SessionID__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SessionID";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SessionID *)new FIX::SessionID();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SessionID__SWIG_1(int argc, VALUE *argv, VALUE self) {
  BeginString *arg1 = 0 ;
  SenderCompID *arg2 = 0 ;
  TargetCompID *arg3 = 0 ;
  std::string *arg4 = 0 ;
  FIX::SessionID *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SessionID";
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_BeginString,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "BeginString const &","FIX::SessionID", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "BeginString const &","FIX::SessionID", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< BeginString * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_SenderCompID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SenderCompID const &","FIX::SessionID", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SenderCompID const &","FIX::SessionID", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< SenderCompID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_TargetCompID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "TargetCompID const &","FIX::SessionID", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "TargetCompID const &","FIX::SessionID", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< TargetCompID * >(argp3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","FIX::SessionID", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SessionID", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  result = (FIX::SessionID *)new FIX::SessionID((BeginString const &)*arg1,(SenderCompID const &)*arg2,(TargetCompID const &)*arg3,(std::string const &)*arg4);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SessionID__SWIG_2(int argc, VALUE *argv, VALUE self) {
  BeginString *arg1 = 0 ;
  SenderCompID *arg2 = 0 ;
  TargetCompID *arg3 = 0 ;
  FIX::SessionID *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SessionID";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_BeginString,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "BeginString const &","FIX::SessionID", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "BeginString const &","FIX::SessionID", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< BeginString * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_SenderCompID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SenderCompID const &","FIX::SessionID", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SenderCompID const &","FIX::SessionID", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< SenderCompID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_TargetCompID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "TargetCompID const &","FIX::SessionID", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "TargetCompID const &","FIX::SessionID", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< TargetCompID * >(argp3);
  result = (FIX::SessionID *)new FIX::SessionID((BeginString const &)*arg1,(SenderCompID const &)*arg2,(TargetCompID const &)*arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SessionID__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  FIX::SessionID *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SessionID";
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::SessionID", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SessionID", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::SessionID", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SessionID", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","FIX::SessionID", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SessionID", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","FIX::SessionID", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SessionID", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  result = (FIX::SessionID *)new FIX::SessionID((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SessionID_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SessionID_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SessionID);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SessionID__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  FIX::SessionID *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SessionID";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::SessionID", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SessionID", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::SessionID", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SessionID", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","FIX::SessionID", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SessionID", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  result = (FIX::SessionID *)new FIX::SessionID((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SessionID(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SessionID__SWIG_0(nargs, args, self);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_BeginString, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SenderCompID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_TargetCompID, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SessionID__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SessionID__SWIG_4(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_BeginString, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SenderCompID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_TargetCompID, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SessionID__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SessionID__SWIG_3(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SessionID.new", 
    "    SessionID.new()\n"
    "    SessionID.new(BeginString const &beginString, SenderCompID const &senderCompID, TargetCompID const &targetCompID, std::string const &sessionQualifier)\n"
    "    SessionID.new(BeginString const &beginString, SenderCompID const &senderCompID, TargetCompID const &targetCompID)\n"
    "    SessionID.new(std::string const &beginString, std::string const &senderCompID, std::string const &targetCompID, std::string const &sessionQualifier)\n"
    "    SessionID.new(std::string const &beginString, std::string const &senderCompID, std::string const &targetCompID)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_getBeginString(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  BeginString *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","getBeginString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    BeginString const &_result_ref = ((FIX::SessionID const *)arg1)->getBeginString();
    result = (BeginString *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_BeginString, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_getSenderCompID(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  SenderCompID *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","getSenderCompID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    SenderCompID const &_result_ref = ((FIX::SessionID const *)arg1)->getSenderCompID();
    result = (SenderCompID *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SenderCompID, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_getTargetCompID(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  TargetCompID *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","getTargetCompID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    TargetCompID const &_result_ref = ((FIX::SessionID const *)arg1)->getTargetCompID();
    result = (TargetCompID *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TargetCompID, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_getSessionQualifier(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","getSessionQualifier", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    std::string const &_result_ref = ((FIX::SessionID const *)arg1)->getSessionQualifier();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_toString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  result = ((FIX::SessionID const *)arg1)->toString();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_fromString(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID *","fromString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","fromString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","fromString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->fromString((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID_toString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  std::string *arg2 = 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string temp2 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  {
    temp2 = std::string((char*)STR2CSTR(argv[0]));
    arg2 = &temp2;
  }
  {
    std::string &_result_ref = ((FIX::SessionID const *)arg1)->toString(*arg2);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  {
    if( std::string("std::string &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SessionID_toString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SessionID_toString__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SessionID_toString__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SessionID.toString", 
    "    std::string & SessionID.toString()\n"
    "    std::string & SessionID.toString(std::string &str)\n");
  
  return Qnil;
}



/*
  Document-method: Quickfix::SessionID.~

  call-seq:
    ~ -> SessionID

Invert operator.
*/
SWIGINTERN VALUE
_wrap_SessionID___invert__(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  FIX::SessionID result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID *","operator ~", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  result = (arg1)->operator ~();
  vresult = SWIG_NewPointerObj((new FIX::SessionID(static_cast< const FIX::SessionID& >(result))), SWIGTYPE_p_FIX__SessionID, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionID___str__(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = (FIX::SessionID *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID *","__str__", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  result = FIX_SessionID___str__(arg1);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_SessionID(FIX::SessionID *arg1) {
    delete arg1;
}


/*
  Document-method: Quickfix::FIX.<

  call-seq:
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool
    <(lhs, rhs) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap___lt____SWIG_4(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::operator <", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::operator <", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::operator <", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::operator <", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (bool)FIX::operator <((FIX::SessionID const &)*arg1,(FIX::SessionID const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___lt__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lt____SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__lt__", 
    "    bool __lt__(FIX::StringField const &lhs, char const *rhs)\n"
    "    bool __lt__(char const *lhs, FIX::StringField const &rhs)\n"
    "    bool __lt__(FIX::StringField const &lhs, std::string const &rhs)\n"
    "    bool __lt__(std::string const &lhs, FIX::StringField const &rhs)\n"
    "    bool __lt__(FIX::SessionID const &lhs, FIX::SessionID const &rhs)\n");
  
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.==

  call-seq:
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool
    ==(lhs, rhs) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap___eq____SWIG_4(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::operator ==", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::operator ==", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::operator ==", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::operator ==", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (bool)FIX::operator ==((FIX::SessionID const &)*arg1,(FIX::SessionID const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___eq__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__StringField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__StringField, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___eq____SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__eq__", 
    "    bool __eq__(FIX::StringField const &lhs, char const *rhs)\n"
    "    bool __eq__(char const *lhs, FIX::StringField const &rhs)\n"
    "    bool __eq__(FIX::StringField const &lhs, std::string const &rhs)\n"
    "    bool __eq__(std::string const &lhs, FIX::StringField const &rhs)\n"
    "    bool __eq__(FIX::SessionID const &lhs, FIX::SessionID const &rhs)\n");
  
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.<<

  call-seq:
    <<(stream, field) -> std::ostream
    <<(stream, message) -> std::ostream
    <<(stream, sessionID) -> std::ostream
    <<(?, ?) -> std::ostream

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap___lshift____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  std::ostream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","FIX::operator <<", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","FIX::operator <<", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::operator <<", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::operator <<", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    std::ostream &_result_ref = FIX::operator <<(*arg1,(FIX::SessionID const &)*arg2);
    result = (std::ostream *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.>>

  call-seq:
    >>(stream, sessionID) -> std::istream
    >>(?, ?) -> std::istream

Right shifting operator or extracting operator.
*/
SWIGINTERN VALUE
_wrap___rshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  std::istream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream &","FIX::operator >>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","FIX::operator >>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID &","FIX::operator >>", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID &","FIX::operator >>", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    std::istream &_result_ref = FIX::operator >>(*arg1,*arg2);
    result = (std::istream *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__istream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cDictionary;

SWIGINTERN VALUE
_wrap_new_Dictionary__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::Dictionary *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::Dictionary";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Dictionary", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Dictionary", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::Dictionary *)new FIX::Dictionary((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Dictionary_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Dictionary_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Dictionary);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Dictionary__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Dictionary";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::Dictionary *)new FIX::Dictionary();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Dictionary(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Dictionary__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Dictionary__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "Dictionary.new", 
    "    Dictionary.new(std::string const &name)\n"
    "    Dictionary.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_Dictionary(FIX::Dictionary *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Dictionary_getName(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  result = ((FIX::Dictionary const *)arg1)->getName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Quickfix::Dictionary.size

  call-seq:
    size -> int

Size or Length of the Dictionary.
*/
SWIGINTERN VALUE
_wrap_Dictionary_size(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  result = (int)((FIX::Dictionary const *)arg1)->size();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getString__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","getString", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  try {
    result = ((FIX::Dictionary const *)arg1)->getString((std::string const &)*arg2,arg3);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::FieldConvertError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldConvertError, SWIG_NewPointerObj((new FIX::FieldConvertError(static_cast< const FIX::FieldConvertError& >(_e))),SWIGTYPE_p_FIX__FieldConvertError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getString__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  try {
    result = ((FIX::Dictionary const *)arg1)->getString((std::string const &)*arg2);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::FieldConvertError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldConvertError, SWIG_NewPointerObj((new FIX::FieldConvertError(static_cast< const FIX::FieldConvertError& >(_e))),SWIGTYPE_p_FIX__FieldConvertError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Dictionary_getString(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Dictionary, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Dictionary_getString__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Dictionary, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Dictionary_getString__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Dictionary.getString", 
    "    std::string Dictionary.getString(std::string const &, bool capitalize)\n"
    "    std::string Dictionary.getString(std::string const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getLong(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  long result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getLong", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getLong", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getLong", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  try {
    result = (long)((FIX::Dictionary const *)arg1)->getLong((std::string const &)*arg2);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::FieldConvertError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldConvertError, SWIG_NewPointerObj((new FIX::FieldConvertError(static_cast< const FIX::FieldConvertError& >(_e))),SWIGTYPE_p_FIX__FieldConvertError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_long(static_cast< long >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getDouble(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getDouble", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getDouble", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getDouble", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  try {
    result = (double)((FIX::Dictionary const *)arg1)->getDouble((std::string const &)*arg2);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::FieldConvertError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldConvertError, SWIG_NewPointerObj((new FIX::FieldConvertError(static_cast< const FIX::FieldConvertError& >(_e))),SWIGTYPE_p_FIX__FieldConvertError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_double(static_cast< double >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getBool(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getBool", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getBool", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getBool", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  try {
    result = (bool)((FIX::Dictionary const *)arg1)->getBool((std::string const &)*arg2);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::FieldConvertError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldConvertError, SWIG_NewPointerObj((new FIX::FieldConvertError(static_cast< const FIX::FieldConvertError& >(_e))),SWIGTYPE_p_FIX__FieldConvertError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_getDay(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","getDay", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getDay", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getDay", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  try {
    result = (int)((FIX::Dictionary const *)arg1)->getDay((std::string const &)*arg2);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::FieldConvertError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldConvertError, SWIG_NewPointerObj((new FIX::FieldConvertError(static_cast< const FIX::FieldConvertError& >(_e))),SWIGTYPE_p_FIX__FieldConvertError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_setString(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","setString", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","setString", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setString", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  (arg1)->setString((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = rb_ary_new();
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_setLong(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  long val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","setLong", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setLong", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setLong", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setLong", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->setLong((std::string const &)*arg2,arg3);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_setDouble(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","setDouble", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setDouble", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setDouble", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","setDouble", 3, argv[1] ));
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->setDouble((std::string const &)*arg2,arg3);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_setBool(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","setBool", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setBool", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setBool", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setBool", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->setBool((std::string const &)*arg2,arg3);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_setDay(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","setDay", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setDay", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setDay", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","setDay", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->setDay((std::string const &)*arg2,arg3);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_has(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","has", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","has", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","has", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)((FIX::Dictionary const *)arg1)->has((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_merge(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  FIX::Dictionary *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary *","merge", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Dictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Dictionary const &","merge", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Dictionary const &","merge", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Dictionary * >(argp2);
  (arg1)->merge((FIX::Dictionary const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_begin(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  FIX::Dictionary::iterator result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  result = ((FIX::Dictionary const *)arg1)->begin();
  vresult = SWIG_NewPointerObj((new FIX::Dictionary::iterator(static_cast< const FIX::Dictionary::iterator& >(result))), SWIGTYPE_p_FIX__Dictionary__Data__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Dictionary_end(int argc, VALUE *argv, VALUE self) {
  FIX::Dictionary *arg1 = (FIX::Dictionary *) 0 ;
  FIX::Dictionary::iterator result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Dictionary const *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Dictionary * >(argp1);
  result = ((FIX::Dictionary const *)arg1)->end();
  vresult = SWIG_NewPointerObj((new FIX::Dictionary::iterator(static_cast< const FIX::Dictionary::iterator& >(result))), SWIGTYPE_p_FIX__Dictionary__Data__const_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BEGINSTRING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::BEGINSTRING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SENDERCOMPID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SENDERCOMPID);
  return _val;
}


SWIGINTERN VALUE
_wrap_TARGETCOMPID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::TARGETCOMPID);
  return _val;
}


SWIGINTERN VALUE
_wrap_SESSION_QUALIFIER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SESSION_QUALIFIER);
  return _val;
}


SWIGINTERN VALUE
_wrap_CONNECTION_TYPE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CONNECTION_TYPE);
  return _val;
}


SWIGINTERN VALUE
_wrap_USE_DATA_DICTIONARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::USE_DATA_DICTIONARY);
  return _val;
}


SWIGINTERN VALUE
_wrap_SEND_RESETSEQNUMFLAG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SEND_RESETSEQNUMFLAG);
  return _val;
}


SWIGINTERN VALUE
_wrap_SEND_REDUNDANT_RESENDREQUESTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SEND_REDUNDANT_RESENDREQUESTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_DATA_DICTIONARY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::DATA_DICTIONARY);
  return _val;
}


SWIGINTERN VALUE
_wrap_START_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::START_TIME);
  return _val;
}


SWIGINTERN VALUE
_wrap_END_TIME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::END_TIME);
  return _val;
}


SWIGINTERN VALUE
_wrap_START_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::START_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_END_DAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::END_DAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_CHECK_COMPID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CHECK_COMPID);
  return _val;
}


SWIGINTERN VALUE
_wrap_CHECK_LATENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::CHECK_LATENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_MAX_LATENCY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MAX_LATENCY);
  return _val;
}


SWIGINTERN VALUE
_wrap_HEARTBTINT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::HEARTBTINT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_ACCEPT_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_ACCEPT_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_REUSE_ADDRESS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_REUSE_ADDRESS);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_CONNECT_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_CONNECT_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_CONNECT_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_CONNECT_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_SOCKET_NODELAY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SOCKET_NODELAY);
  return _val;
}


SWIGINTERN VALUE
_wrap_RECONNECT_INTERVAL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RECONNECT_INTERVAL);
  return _val;
}


SWIGINTERN VALUE
_wrap_VALIDATE_FIELDS_OUT_OF_ORDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::VALIDATE_FIELDS_OUT_OF_ORDER);
  return _val;
}


SWIGINTERN VALUE
_wrap_VALIDATE_FIELDS_HAVE_VALUES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::VALIDATE_FIELDS_HAVE_VALUES);
  return _val;
}


SWIGINTERN VALUE
_wrap_VALIDATE_USER_DEFINED_FIELDS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::VALIDATE_USER_DEFINED_FIELDS);
  return _val;
}


SWIGINTERN VALUE
_wrap_LOGON_TIMEOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::LOGON_TIMEOUT);
  return _val;
}


SWIGINTERN VALUE
_wrap_LOGOUT_TIMEOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::LOGOUT_TIMEOUT);
  return _val;
}


SWIGINTERN VALUE
_wrap_FILE_STORE_PATH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::FILE_STORE_PATH);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_USECONNECTIONPOOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_USECONNECTIONPOOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_DATABASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_STORE_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_STORE_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_USECONNECTIONPOOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_USECONNECTIONPOOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_DATABASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_STORE_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_STORE_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_STORE_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_STORE_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_STORE_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_STORE_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_STORE_CONNECTION_STRING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_STORE_CONNECTION_STRING);
  return _val;
}


SWIGINTERN VALUE
_wrap_FILE_LOG_PATH_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::FILE_LOG_PATH);
  return _val;
}


SWIGINTERN VALUE
_wrap_SCREEN_LOG_SHOW_INCOMING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SCREEN_LOG_SHOW_INCOMING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SCREEN_LOG_SHOW_OUTGOING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SCREEN_LOG_SHOW_OUTGOING);
  return _val;
}


SWIGINTERN VALUE
_wrap_SCREEN_LOG_SHOW_EVENTS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::SCREEN_LOG_SHOW_EVENTS);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_USECONNECTIONPOOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_USECONNECTIONPOOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_DATABASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_MYSQL_LOG_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MYSQL_LOG_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_USECONNECTIONPOOL_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_USECONNECTIONPOOL);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_DATABASE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_DATABASE);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_HOST_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_HOST);
  return _val;
}


SWIGINTERN VALUE
_wrap_POSTGRESQL_LOG_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::POSTGRESQL_LOG_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_LOG_USER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_LOG_USER);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_LOG_PASSWORD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_LOG_PASSWORD);
  return _val;
}


SWIGINTERN VALUE
_wrap_ODBC_LOG_CONNECTION_STRING_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::ODBC_LOG_CONNECTION_STRING);
  return _val;
}


SWIGINTERN VALUE
_wrap_RESET_ON_LOGON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RESET_ON_LOGON);
  return _val;
}


SWIGINTERN VALUE
_wrap_RESET_ON_LOGOUT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RESET_ON_LOGOUT);
  return _val;
}


SWIGINTERN VALUE
_wrap_RESET_ON_DISCONNECT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::RESET_ON_DISCONNECT);
  return _val;
}


SWIGINTERN VALUE
_wrap_REFRESH_ON_LOGON_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::REFRESH_ON_LOGON);
  return _val;
}


SWIGINTERN VALUE
_wrap_MILLISECONDS_IN_TIMESTAMP_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::MILLISECONDS_IN_TIMESTAMP);
  return _val;
}


SWIGINTERN VALUE
_wrap_HTTP_ACCEPT_PORT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::HTTP_ACCEPT_PORT);
  return _val;
}


SWIGINTERN VALUE
_wrap_PERSIST_MESSAGES_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(FIX::PERSIST_MESSAGES);
  return _val;
}


swig_class cSessionSettings;

SWIGINTERN VALUE
_wrap_new_SessionSettings__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SessionSettings";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::SessionSettings *)new FIX::SessionSettings();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SessionSettings__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = 0 ;
  FIX::SessionSettings *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SessionSettings";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream &","FIX::SessionSettings", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","FIX::SessionSettings", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  try {
    result = (FIX::SessionSettings *)new FIX::SessionSettings(*arg1);DATA_PTR(self) = result;
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SessionSettings_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SessionSettings_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SessionSettings);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SessionSettings__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::SessionSettings *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::SessionSettings";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::SessionSettings", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::SessionSettings", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  try {
    result = (FIX::SessionSettings *)new FIX::SessionSettings((std::string const &)*arg1);DATA_PTR(self) = result;
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SessionSettings(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SessionSettings__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SessionSettings__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SessionSettings__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SessionSettings.new", 
    "    SessionSettings.new()\n"
    "    SessionSettings.new(std::istream &stream)\n"
    "    SessionSettings.new(std::string const &file)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_has(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const *","has", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","has", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","has", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (bool)((FIX::SessionSettings const *)arg1)->has((FIX::SessionID const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::Dictionary *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","get", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","get", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  try {
    {
      FIX::Dictionary const &_result_ref = ((FIX::SessionSettings const *)arg1)->get((FIX::SessionID const &)*arg2);
      result = (FIX::Dictionary *) &_result_ref;
    }
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_set__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::Dictionary arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","set", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","set", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__Dictionary,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::Dictionary","set", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Dictionary","set", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< FIX::Dictionary * >(argp3));
    }
  }
  try {
    (arg1)->set((FIX::SessionID const &)*arg2,arg3);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  FIX::Dictionary *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  {
    FIX::Dictionary const &_result_ref = ((FIX::SessionSettings const *)arg1)->get();
    result = (FIX::Dictionary *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Dictionary, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SessionSettings_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SessionSettings_get__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SessionSettings_get__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SessionSettings.get", 
    "    FIX::Dictionary const & SessionSettings.get(FIX::SessionID const &)\n"
    "    FIX::Dictionary const & SessionSettings.get()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_set__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  FIX::Dictionary *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Dictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Dictionary const &","set", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Dictionary const &","set", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Dictionary * >(argp2);
  try {
    (arg1)->set((FIX::Dictionary const &)*arg2);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SessionSettings_set(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Dictionary, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SessionSettings_set__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__Dictionary, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SessionSettings_set__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SessionSettings.set", 
    "    void SessionSettings.set(FIX::SessionID const &, FIX::Dictionary)\n"
    "    void SessionSettings.set(FIX::Dictionary const &defaults)\n");
  
  return Qnil;
}



/*
  Document-method: Quickfix::SessionSettings.size

  call-seq:
    size -> int

Size or Length of the SessionSettings.
*/
SWIGINTERN VALUE
_wrap_SessionSettings_size(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  result = (int)(arg1)->size();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SessionSettings_getSessions(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = (FIX::SessionSettings *) 0 ;
  SwigValueWrapper< std::set< FIX::SessionID > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SessionSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const *","getSessions", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  result = ((FIX::SessionSettings const *)arg1)->getSessions();
  vresult = SWIG_NewPointerObj((new std::set< FIX::SessionID >(static_cast< const std::set< FIX::SessionID >& >(result))), SWIGTYPE_p_std__setT_FIX__SessionID_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_SessionSettings(FIX::SessionSettings *arg1) {
    delete arg1;
}


/*
  Document-method: Quickfix::FIX.>>

  call-seq:
    >>(stream, sessionID) -> std::istream
    >>(?, ?) -> std::istream

Right shifting operator or extracting operator.
*/
SWIGINTERN VALUE
_wrap___rshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = 0 ;
  FIX::SessionSettings *arg2 = 0 ;
  std::istream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream &","FIX::operator >>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","FIX::operator >>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionSettings &","FIX::operator >>", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings &","FIX::operator >>", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionSettings * >(argp2);
  try {
    {
      std::istream &_result_ref = FIX::operator >>(*arg1,*arg2);
      result = (std::istream *) &_result_ref;
    }
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__istream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___rshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___rshift____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___rshift____SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__rshift__", 
    "    std::istream & __rshift__(std::istream &stream, FIX::SessionID &sessionID)\n"
    "    std::istream & __rshift__(std::istream &, FIX::SessionSettings &)\n");
  
  return Qnil;
}



/*
  Document-method: Quickfix::FIX.<<

  call-seq:
    <<(stream, field) -> std::ostream
    <<(stream, message) -> std::ostream
    <<(stream, sessionID) -> std::ostream
    <<(?, ?) -> std::ostream

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap___lshift____SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  FIX::SessionSettings *arg2 = 0 ;
  std::ostream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","FIX::operator <<", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","FIX::operator <<", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FIX::operator <<", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FIX::operator <<", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionSettings * >(argp2);
  {
    std::ostream &_result_ref = FIX::operator <<(*arg1,(FIX::SessionSettings const &)*arg2);
    result = (std::ostream *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ostream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__FieldBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ostream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Message, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ostream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lshift____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ostream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___lshift____SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "__lshift__", 
    "    std::ostream & __lshift__(std::ostream &stream, FIX::FieldBase const &field)\n"
    "    std::ostream & __lshift__(std::ostream &stream, FIX::Message const &message)\n"
    "    std::ostream & __lshift__(std::ostream &stream, FIX::SessionID const &sessionID)\n"
    "    std::ostream & __lshift__(std::ostream &, FIX::SessionSettings const &)\n");
  
  return Qnil;
}


swig_class cSession;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Session_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Session_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Session);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Session(int argc, VALUE *argv, VALUE self) {
  Application *arg1 = 0 ;
  MessageStoreFactory *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  DataDictionary *arg4 = 0 ;
  SessionTime *arg5 = 0 ;
  int arg6 ;
  LogFactory *arg7 = (LogFactory *) 0 ;
  FIX::Session *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Session";
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Application &","FIX::Session", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Application &","FIX::Session", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "MessageStoreFactory &","FIX::Session", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "MessageStoreFactory &","FIX::Session", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_DataDictionary,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "DataDictionary const &","FIX::Session", 4, argv[3] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "DataDictionary const &","FIX::Session", 4, argv[3])); 
  }
  arg4 = reinterpret_cast< DataDictionary * >(argp4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_SessionTime,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "SessionTime const &","FIX::Session", 5, argv[4] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SessionTime const &","FIX::Session", 5, argv[4])); 
  }
  arg5 = reinterpret_cast< SessionTime * >(argp5);
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","FIX::Session", 6, argv[5] ));
  } 
  arg6 = static_cast< int >(val6);
  res7 = SWIG_ConvertPtr(argv[6], &argp7,SWIGTYPE_p_LogFactory, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), Ruby_Format_TypeError( "", "LogFactory *","FIX::Session", 7, argv[6] )); 
  }
  arg7 = reinterpret_cast< LogFactory * >(argp7);
  result = (FIX::Session *)new FIX::Session(*arg1,*arg2,(FIX::SessionID const &)*arg3,(DataDictionary const &)*arg4,(SessionTime const &)*arg5,arg6,arg7);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_Session(FIX::Session *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Session_logon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","logon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  (arg1)->logon();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_logout__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","logout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","logout", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","logout", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->logout((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_logout__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","logout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  (arg1)->logout();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Session_logout(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Session_logout__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Session_logout__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Session.logout", 
    "    void Session.logout(std::string const &reason)\n"
    "    void Session.logout()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isEnabled(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isEnabled", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->isEnabled();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sentLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","sentLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->sentLogon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sentLogout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","sentLogout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->sentLogout();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_receivedLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","receivedLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->receivedLogon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isLoggedOn(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isLoggedOn", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->isLoggedOn();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_reset(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  try {
    (arg1)->reset();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  try {
    (arg1)->refresh();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    (arg1)->setNextSenderMsgSeqNum(arg2);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    (arg1)->setNextTargetMsgSeqNum(arg2);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getSessionID(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  FIX::SessionID *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session const *","getSessionID", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    FIX::SessionID const &_result_ref = ((FIX::Session const *)arg1)->getSessionID();
    result = (FIX::SessionID *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__SessionID, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setDataDictionary(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  DataDictionary *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setDataDictionary", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_DataDictionary,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "DataDictionary const &","setDataDictionary", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "DataDictionary const &","setDataDictionary", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< DataDictionary * >(argp2);
  (arg1)->setDataDictionary((DataDictionary const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getDataDictionary(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  DataDictionary *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session const *","getDataDictionary", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    DataDictionary const &_result_ref = ((FIX::Session const *)arg1)->getDataDictionary();
    result = (DataDictionary *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DataDictionary, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  try {
    result = (bool)FIX::Session::sendToTarget(*arg1,(std::string const &)*arg2);
  }
  catch(FIX::SessionNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__SessionNotFound, SWIG_NewPointerObj((new FIX::SessionNotFound(static_cast< const FIX::SessionNotFound& >(_e))),SWIGTYPE_p_FIX__SessionNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  try {
    result = (bool)FIX::Session::sendToTarget(*arg1);
  }
  catch(FIX::SessionNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__SessionNotFound, SWIG_NewPointerObj((new FIX::SessionNotFound(static_cast< const FIX::SessionNotFound& >(_e))),SWIGTYPE_p_FIX__SessionNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::sendToTarget", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::sendToTarget", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  try {
    result = (bool)FIX::Session::sendToTarget(*arg1,(FIX::SessionID const &)*arg2);
  }
  catch(FIX::SessionNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__SessionNotFound, SWIG_NewPointerObj((new FIX::SessionNotFound(static_cast< const FIX::SessionNotFound& >(_e))),SWIGTYPE_p_FIX__SessionNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  SenderCompID *arg2 = 0 ;
  TargetCompID *arg3 = 0 ;
  std::string *arg4 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_SenderCompID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SenderCompID const &","FIX::Session::sendToTarget", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SenderCompID const &","FIX::Session::sendToTarget", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< SenderCompID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_TargetCompID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "TargetCompID const &","FIX::Session::sendToTarget", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "TargetCompID const &","FIX::Session::sendToTarget", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< TargetCompID * >(argp3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  try {
    result = (bool)FIX::Session::sendToTarget(*arg1,(SenderCompID const &)*arg2,(TargetCompID const &)*arg3,(std::string const &)*arg4);
  }
  catch(FIX::SessionNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__SessionNotFound, SWIG_NewPointerObj((new FIX::SessionNotFound(static_cast< const FIX::SessionNotFound& >(_e))),SWIGTYPE_p_FIX__SessionNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_4(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  SenderCompID *arg2 = 0 ;
  TargetCompID *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_SenderCompID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SenderCompID const &","FIX::Session::sendToTarget", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SenderCompID const &","FIX::Session::sendToTarget", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< SenderCompID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_TargetCompID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "TargetCompID const &","FIX::Session::sendToTarget", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "TargetCompID const &","FIX::Session::sendToTarget", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< TargetCompID * >(argp3);
  try {
    result = (bool)FIX::Session::sendToTarget(*arg1,(SenderCompID const &)*arg2,(TargetCompID const &)*arg3);
  }
  catch(FIX::SessionNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__SessionNotFound, SWIG_NewPointerObj((new FIX::SessionNotFound(static_cast< const FIX::SessionNotFound& >(_e))),SWIGTYPE_p_FIX__SessionNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_5(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  try {
    result = (bool)FIX::Session::sendToTarget(*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  }
  catch(FIX::SessionNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__SessionNotFound, SWIG_NewPointerObj((new FIX::SessionNotFound(static_cast< const FIX::SessionNotFound& >(_e))),SWIGTYPE_p_FIX__SessionNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[3], 0 );
      rb_str_append( argv[3], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_sendToTarget__SWIG_6(int argc, VALUE *argv, VALUE self) {
  FIX::Message *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","FIX::Session::sendToTarget", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Message * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::sendToTarget", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::sendToTarget", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  try {
    result = (bool)FIX::Session::sendToTarget(*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
  }
  catch(FIX::SessionNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__SessionNotFound, SWIG_NewPointerObj((new FIX::SessionNotFound(static_cast< const FIX::SessionNotFound& >(_e))),SWIGTYPE_p_FIX__SessionNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Session_sendToTarget(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Session_sendToTarget__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Session_sendToTarget__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Session_sendToTarget__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SenderCompID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_TargetCompID, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Session_sendToTarget__SWIG_4(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Session_sendToTarget__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SenderCompID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_TargetCompID, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_Session_sendToTarget__SWIG_3(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Message, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_Session_sendToTarget__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Session.sendToTarget", 
    "    bool Session.sendToTarget(FIX::Message &message, std::string const &qualifier)\n"
    "    bool Session.sendToTarget(FIX::Message &message)\n"
    "    bool Session.sendToTarget(FIX::Message &message, FIX::SessionID const &sessionID)\n"
    "    bool Session.sendToTarget(FIX::Message &, SenderCompID const &senderCompID, TargetCompID const &targetCompID, std::string const &qualifier)\n"
    "    bool Session.sendToTarget(FIX::Message &, SenderCompID const &senderCompID, TargetCompID const &targetCompID)\n"
    "    bool Session.sendToTarget(FIX::Message &message, std::string const &senderCompID, std::string const &targetCompID, std::string const &qualifier)\n"
    "    bool Session.sendToTarget(FIX::Message &message, std::string const &senderCompID, std::string const &targetCompID)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getSessions(int argc, VALUE *argv, VALUE self) {
  SwigValueWrapper< std::set< FIX::SessionID > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = FIX::Session::getSessions();
  vresult = SWIG_NewPointerObj((new std::set< FIX::SessionID >(static_cast< const std::set< FIX::SessionID >& >(result))), SWIGTYPE_p_std__setT_FIX__SessionID_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_doesSessionExist(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::doesSessionExist", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::doesSessionExist", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  result = (bool)FIX::Session::doesSessionExist((FIX::SessionID const &)*arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_lookupSession__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  FIX::Session *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::lookupSession", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::lookupSession", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  result = (FIX::Session *)FIX::Session::lookupSession((FIX::SessionID const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_lookupSession__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  bool arg2 ;
  FIX::Session *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::lookupSession", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::lookupSession", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","FIX::Session::lookupSession", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (FIX::Session *)FIX::Session::lookupSession((std::string const &)*arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_lookupSession__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::Session *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::Session::lookupSession", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::Session::lookupSession", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::Session *)FIX::Session::lookupSession((std::string const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Session_lookupSession(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Session_lookupSession__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Session_lookupSession__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Session_lookupSession__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Session.lookupSession", 
    "    FIX::Session * Session.lookupSession(FIX::SessionID const &)\n"
    "    FIX::Session * Session.lookupSession(std::string const &, bool reverse)\n"
    "    FIX::Session * Session.lookupSession(std::string const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isSessionRegistered(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  bool result;
  void *argp1 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::isSessionRegistered", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::isSessionRegistered", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  result = (bool)FIX::Session::isSessionRegistered((FIX::SessionID const &)*arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_registerSession(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  FIX::Session *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::registerSession", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::registerSession", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  result = (FIX::Session *)FIX::Session::registerSession((FIX::SessionID const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_unregisterSession(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::Session::unregisterSession", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::Session::unregisterSession", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  FIX::Session::unregisterSession((FIX::SessionID const &)*arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_numSessions(int argc, VALUE *argv, VALUE self) {
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (int)FIX::Session::numSessions();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isSessionTime(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isSessionTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->isSessionTime();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isInitiator(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isInitiator", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->isInitiator();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_isAcceptor(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","isAcceptor", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->isAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getSendRedundantResendRequests(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getSendRedundantResendRequests", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->getSendRedundantResendRequests();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setSendRedundantResendRequests(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setSendRedundantResendRequests", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setSendRedundantResendRequests", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setSendRedundantResendRequests(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getCheckCompId(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getCheckCompId", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->getCheckCompId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setCheckCompId(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setCheckCompId", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setCheckCompId", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setCheckCompId(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getCheckLatency(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getCheckLatency", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->getCheckLatency();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setCheckLatency(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setCheckLatency", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setCheckLatency", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setCheckLatency(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getMaxLatency(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getMaxLatency", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (int)(arg1)->getMaxLatency();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setMaxLatency(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setMaxLatency", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setMaxLatency", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->setMaxLatency(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getLogonTimeout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getLogonTimeout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (int)(arg1)->getLogonTimeout();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setLogonTimeout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setLogonTimeout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setLogonTimeout", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->setLogonTimeout(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getLogoutTimeout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getLogoutTimeout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (int)(arg1)->getLogoutTimeout();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setLogoutTimeout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setLogoutTimeout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setLogoutTimeout", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->setLogoutTimeout(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getResetOnLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getResetOnLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->getResetOnLogon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setResetOnLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setResetOnLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setResetOnLogon", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setResetOnLogon(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getResetOnLogout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getResetOnLogout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->getResetOnLogout();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setResetOnLogout(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setResetOnLogout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setResetOnLogout", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setResetOnLogout(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getResetOnDisconnect(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getResetOnDisconnect", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->getResetOnDisconnect();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setResetOnDisconnect(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setResetOnDisconnect", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setResetOnDisconnect", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setResetOnDisconnect(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getRefreshOnLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getRefreshOnLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->getRefreshOnLogon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setRefreshOnLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setRefreshOnLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setRefreshOnLogon", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setRefreshOnLogon(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getMillisecondsInTimeStamp(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getMillisecondsInTimeStamp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->getMillisecondsInTimeStamp();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setMillisecondsInTimeStamp(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setMillisecondsInTimeStamp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setMillisecondsInTimeStamp", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setMillisecondsInTimeStamp(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getPersistMessages(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getPersistMessages", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (bool)(arg1)->getPersistMessages();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setPersistMessages(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setPersistMessages", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setPersistMessages", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setPersistMessages(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_setResponder(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  Responder *arg2 = (Responder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","setResponder", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Responder, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Responder *","setResponder", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Responder * >(argp2);
  (arg1)->setResponder(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_send(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  FIX::Message *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","send", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message &","send", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","send", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  result = (bool)(arg1)->send(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  (arg1)->next();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","next", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","next", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","next", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->next((std::string const &)*arg2,arg3);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_next__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","next", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","next", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->next((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_next__SWIG_3(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  FIX::Message *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","next", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","next", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","next", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->next((FIX::Message const &)*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_next__SWIG_4(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  FIX::Message *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","next", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","next", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  (arg1)->next((FIX::Message const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Session_next(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Session_next__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Message, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Session_next__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Session_next__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__Message, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Session_next__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Session, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Session_next__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "Session.next", 
    "    void Session.next()\n"
    "    void Session.next(std::string const &, bool queued)\n"
    "    void Session.next(std::string const &)\n"
    "    void Session.next(FIX::Message const &, bool queued)\n"
    "    void Session.next(FIX::Message const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_disconnect(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","disconnect", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  (arg1)->disconnect();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getExpectedSenderNum(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  long result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getExpectedSenderNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (long)(arg1)->getExpectedSenderNum();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getExpectedTargetNum(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  long result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getExpectedTargetNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (long)(arg1)->getExpectedTargetNum();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getLog(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  Log *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getLog", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (Log *)(arg1)->getLog();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Session_getStore(int argc, VALUE *argv, VALUE self) {
  FIX::Session *arg1 = (FIX::Session *) 0 ;
  MessageStore *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Session, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Session *","getStore", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Session * >(argp1);
  result = (MessageStore *)(arg1)->getStore();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cLogFactory;

SWIGINTERN void
free_FIX_LogFactory(FIX::LogFactory *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_LogFactory_create__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::LogFactory *arg1 = (FIX::LogFactory *) 0 ;
  FIX::Log *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__LogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::LogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::LogFactory * >(argp1);
  result = (FIX::Log *)(arg1)->create();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LogFactory_create__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::LogFactory *arg1 = (FIX::LogFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::Log *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__LogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::LogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::LogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (FIX::Log *)(arg1)->create((FIX::SessionID const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_LogFactory_create(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__LogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_LogFactory_create__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__LogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_LogFactory_create__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "LogFactory.create", 
    "    FIX::Log * LogFactory.create()\n"
    "    FIX::Log * LogFactory.create(FIX::SessionID const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LogFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::LogFactory *arg1 = (FIX::LogFactory *) 0 ;
  FIX::Log *arg2 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__LogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::LogFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::LogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Log *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::Log * >(argp2);
  (arg1)->destroy(arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class cScreenLogFactory;

SWIGINTERN VALUE
_wrap_new_ScreenLogFactory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = 0 ;
  FIX::ScreenLogFactory *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ScreenLogFactory";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FIX::ScreenLogFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FIX::ScreenLogFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  result = (FIX::ScreenLogFactory *)new FIX::ScreenLogFactory((FIX::SessionSettings const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ScreenLogFactory_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ScreenLogFactory_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ScreenLogFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ScreenLogFactory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  FIX::ScreenLogFactory *result = 0 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ScreenLogFactory";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_bool(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "bool","FIX::ScreenLogFactory", 1, argv[0] ));
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","FIX::ScreenLogFactory", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","FIX::ScreenLogFactory", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (FIX::ScreenLogFactory *)new FIX::ScreenLogFactory(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ScreenLogFactory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ScreenLogFactory__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_bool(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_ScreenLogFactory__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ScreenLogFactory.new", 
    "    ScreenLogFactory.new(FIX::SessionSettings const &settings)\n"
    "    ScreenLogFactory.new(bool incoming, bool outgoing, bool event)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLogFactory_create__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLogFactory *arg1 = (FIX::ScreenLogFactory *) 0 ;
  FIX::Log *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLogFactory * >(argp1);
  result = (FIX::Log *)(arg1)->create();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLogFactory_create__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLogFactory *arg1 = (FIX::ScreenLogFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::Log *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (FIX::Log *)(arg1)->create((FIX::SessionID const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ScreenLogFactory_create(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__ScreenLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ScreenLogFactory_create__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__ScreenLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ScreenLogFactory_create__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ScreenLogFactory.create", 
    "    FIX::Log * ScreenLogFactory.create()\n"
    "    FIX::Log * ScreenLogFactory.create(FIX::SessionID const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLogFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLogFactory *arg1 = (FIX::ScreenLogFactory *) 0 ;
  FIX::Log *arg2 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLogFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Log *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::Log * >(argp2);
  (arg1)->destroy(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_ScreenLogFactory(FIX::ScreenLogFactory *arg1) {
    delete arg1;
}

swig_class cLog;

SWIGINTERN void
free_FIX_Log(FIX::Log *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Log_clear(int argc, VALUE *argv, VALUE self) {
  FIX::Log *arg1 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Log *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Log * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Log_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::Log *arg1 = (FIX::Log *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Log *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Log * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onIncoming((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Log_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::Log *arg1 = (FIX::Log *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Log *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Log * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onOutgoing((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Log_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::Log *arg1 = (FIX::Log *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Log *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Log * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onEvent((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


swig_class cScreenLog;

SWIGINTERN VALUE
_wrap_new_ScreenLog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  FIX::ScreenLog *result = 0 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ScreenLog";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_bool(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "bool","FIX::ScreenLog", 1, argv[0] ));
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","FIX::ScreenLog", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","FIX::ScreenLog", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (FIX::ScreenLog *)new FIX::ScreenLog(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ScreenLog_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ScreenLog_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__ScreenLog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ScreenLog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::SessionID *arg1 = 0 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  FIX::ScreenLog *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::ScreenLog";
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::ScreenLog", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::ScreenLog", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionID * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","FIX::ScreenLog", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","FIX::ScreenLog", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","FIX::ScreenLog", 4, argv[3] ));
  } 
  arg4 = static_cast< bool >(val4);
  result = (FIX::ScreenLog *)new FIX::ScreenLog((FIX::SessionID const &)*arg1,arg2,arg3,arg4);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ScreenLog(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_bool(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_ScreenLog__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_ScreenLog__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "ScreenLog.new", 
    "    ScreenLog.new(bool incoming, bool outgoing, bool event)\n"
    "    ScreenLog.new(FIX::SessionID const &sessionID, bool incoming, bool outgoing, bool event)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLog_clear(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLog *arg1 = (FIX::ScreenLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLog *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLog * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLog_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLog *arg1 = (FIX::ScreenLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLog *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onIncoming((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLog_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLog *arg1 = (FIX::ScreenLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLog *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onOutgoing((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ScreenLog_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::ScreenLog *arg1 = (FIX::ScreenLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__ScreenLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::ScreenLog *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::ScreenLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onEvent((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN void
free_FIX_ScreenLog(FIX::ScreenLog *arg1) {
    delete arg1;
}

swig_class cFileLogFactory;

SWIGINTERN VALUE
_wrap_new_FileLogFactory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = 0 ;
  FIX::FileLogFactory *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FileLogFactory";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FIX::FileLogFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FIX::FileLogFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  result = (FIX::FileLogFactory *)new FIX::FileLogFactory((FIX::SessionSettings const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FileLogFactory_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FileLogFactory_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FileLogFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FileLogFactory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::FileLogFactory *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FileLogFactory";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::FileLogFactory", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::FileLogFactory", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::FileLogFactory *)new FIX::FileLogFactory((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FileLogFactory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FileLogFactory__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FileLogFactory__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "FileLogFactory.new", 
    "    FileLogFactory.new(FIX::SessionSettings const &settings)\n"
    "    FileLogFactory.new(std::string const &path)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLogFactory_create__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::FileLogFactory *arg1 = (FIX::FileLogFactory *) 0 ;
  FIX::Log *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLogFactory * >(argp1);
  result = (FIX::Log *)(arg1)->create();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLogFactory_create__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::FileLogFactory *arg1 = (FIX::FileLogFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::Log *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLogFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (FIX::Log *)(arg1)->create((FIX::SessionID const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Log, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FileLogFactory_create(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FileLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FileLogFactory_create__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__FileLogFactory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FileLogFactory_create__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "FileLogFactory.create", 
    "    FIX::Log * FileLogFactory.create()\n"
    "    FIX::Log * FileLogFactory.create(FIX::SessionID const &)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLogFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::FileLogFactory *arg1 = (FIX::FileLogFactory *) 0 ;
  FIX::Log *arg2 = (FIX::Log *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLogFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLogFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLogFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__Log, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Log *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::Log * >(argp2);
  (arg1)->destroy(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_FileLogFactory(FIX::FileLogFactory *arg1) {
    delete arg1;
}

swig_class cFileLog;

SWIGINTERN VALUE
_wrap_new_FileLog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::FileLog *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FileLog";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::FileLog", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::FileLog", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::FileLog *)new FIX::FileLog((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FileLog_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FileLog_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FileLog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FileLog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::FileLog *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FileLog";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::FileLog", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::FileLog", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::FileLog", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::FileLog", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (FIX::FileLog *)new FIX::FileLog((std::string const &)*arg1,(FIX::SessionID const &)*arg2);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FileLog(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FileLog__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__SessionID, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_FileLog__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FileLog.new", 
    "    FileLog.new(std::string const &path)\n"
    "    FileLog.new(std::string const &path, FIX::SessionID const &sessionID)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_FileLog(FIX::FileLog *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FileLog_clear(int argc, VALUE *argv, VALUE self) {
  FIX::FileLog *arg1 = (FIX::FileLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLog *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLog * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLog_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::FileLog *arg1 = (FIX::FileLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLog *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onIncoming((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLog_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::FileLog *arg1 = (FIX::FileLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLog *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onOutgoing((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileLog_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::FileLog *arg1 = (FIX::FileLog *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileLog *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileLog * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onEvent((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


swig_class cMessageStoreFactory;

SWIGINTERN void
free_FIX_MessageStoreFactory(FIX::MessageStoreFactory *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MessageStoreFactory_create(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreFactory *arg1 = (FIX::MessageStoreFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::MessageStore *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (FIX::MessageStore *)(arg1)->create((FIX::SessionID const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreFactory *arg1 = (FIX::MessageStoreFactory *) 0 ;
  FIX::MessageStore *arg2 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStore *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::MessageStore * >(argp2);
  (arg1)->destroy(arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class cMemoryStoreFactory;

SWIGINTERN VALUE
_wrap_MemoryStoreFactory_create(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStoreFactory *arg1 = (FIX::MemoryStoreFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::MessageStore *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStoreFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (FIX::MessageStore *)(arg1)->create((FIX::SessionID const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStoreFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStoreFactory *arg1 = (FIX::MemoryStoreFactory *) 0 ;
  FIX::MessageStore *arg2 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStoreFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStore *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::MessageStore * >(argp2);
  (arg1)->destroy(arg2);
  return Qnil;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MemoryStoreFactory_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MemoryStoreFactory_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MemoryStoreFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MemoryStoreFactory(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStoreFactory *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MemoryStoreFactory";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::MemoryStoreFactory *)new FIX::MemoryStoreFactory();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_MemoryStoreFactory(FIX::MemoryStoreFactory *arg1) {
    delete arg1;
}

swig_class cMessageStore;

SWIGINTERN void
free_FIX_MessageStore(FIX::MessageStore *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MessageStore_set(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","set", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","set", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  try {
    result = (bool)(arg1)->set(arg2,(std::string const &)*arg3);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_get(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","get", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string > &","get", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","get", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< std::string > * >(argp4);
  try {
    ((FIX::MessageStore const *)arg1)->get(arg2,arg3,*arg4);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_getNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore const *","getNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  try {
    result = (int)((FIX::MessageStore const *)arg1)->getNextSenderMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_getNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore const *","getNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  try {
    result = (int)((FIX::MessageStore const *)arg1)->getNextTargetMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    (arg1)->setNextSenderMsgSeqNum(arg2);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    (arg1)->setNextTargetMsgSeqNum(arg2);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_incrNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","incrNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  try {
    (arg1)->incrNextSenderMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_incrNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","incrNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  try {
    (arg1)->incrNextTargetMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_getCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  UtcTimeStamp result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore const *","getCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  try {
    result = ((FIX::MessageStore const *)arg1)->getCreationTime();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new UtcTimeStamp(static_cast< const UtcTimeStamp& >(result))), SWIGTYPE_p_UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_reset(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  try {
    (arg1)->reset();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStore_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  try {
    (arg1)->refresh();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


swig_class cMemoryStore;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MemoryStore_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MemoryStore_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MemoryStore);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MemoryStore(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MemoryStore";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::MemoryStore *)new FIX::MemoryStore();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_set(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","set", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","set", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  try {
    result = (bool)(arg1)->set(arg2,(std::string const &)*arg3);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_get(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","get", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string > &","get", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","get", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< std::string > * >(argp4);
  try {
    ((FIX::MemoryStore const *)arg1)->get(arg2,arg3,*arg4);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_getNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore const *","getNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  try {
    result = (int)((FIX::MemoryStore const *)arg1)->getNextSenderMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_getNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore const *","getNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  try {
    result = (int)((FIX::MemoryStore const *)arg1)->getNextTargetMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    (arg1)->setNextSenderMsgSeqNum(arg2);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    (arg1)->setNextTargetMsgSeqNum(arg2);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_incrNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","incrNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  try {
    (arg1)->incrNextSenderMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_incrNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","incrNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  try {
    (arg1)->incrNextTargetMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_setCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  UtcTimeStamp *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","setCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_UtcTimeStamp,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UtcTimeStamp const &","setCreationTime", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "UtcTimeStamp const &","setCreationTime", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< UtcTimeStamp * >(argp2);
  try {
    (arg1)->setCreationTime((UtcTimeStamp const &)*arg2);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_getCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  UtcTimeStamp result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore const *","getCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  try {
    result = ((FIX::MemoryStore const *)arg1)->getCreationTime();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new UtcTimeStamp(static_cast< const UtcTimeStamp& >(result))), SWIGTYPE_p_UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_reset(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  try {
    (arg1)->reset();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MemoryStore_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::MemoryStore *arg1 = (FIX::MemoryStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MemoryStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MemoryStore *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MemoryStore * >(argp1);
  try {
    (arg1)->refresh();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_MemoryStore(FIX::MemoryStore *arg1) {
    delete arg1;
}

swig_class cMessageStoreFactoryExceptionWrapper;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MessageStoreFactoryExceptionWrapper_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MessageStoreFactoryExceptionWrapper_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MessageStoreFactoryExceptionWrapper);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MessageStoreFactoryExceptionWrapper(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreFactory *arg1 = (FIX::MessageStoreFactory *) 0 ;
  FIX::MessageStoreFactoryExceptionWrapper *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MessageStoreFactoryExceptionWrapper";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FIX__MessageStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory *","FIX::MessageStoreFactoryExceptionWrapper", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreFactory * >(argp1);
  result = (FIX::MessageStoreFactoryExceptionWrapper *)new FIX::MessageStoreFactoryExceptionWrapper(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreFactoryExceptionWrapper_create(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreFactoryExceptionWrapper *arg1 = (FIX::MessageStoreFactoryExceptionWrapper *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  bool *arg3 = 0 ;
  FIX::ConfigError *arg4 = 0 ;
  FIX::MessageStore *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreFactoryExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreFactoryExceptionWrapper *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreFactoryExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "bool &","create", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","create", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< bool * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_FIX__ConfigError,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::ConfigError &","create", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::ConfigError &","create", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< FIX::ConfigError * >(argp4);
  result = (FIX::MessageStore *)(arg1)->create((FIX::SessionID const &)*arg2,*arg3,*arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreFactoryExceptionWrapper_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreFactoryExceptionWrapper *arg1 = (FIX::MessageStoreFactoryExceptionWrapper *) 0 ;
  FIX::MessageStore *arg2 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreFactoryExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreFactoryExceptionWrapper *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreFactoryExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStore *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::MessageStore * >(argp2);
  (arg1)->destroy(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_MessageStoreFactoryExceptionWrapper(FIX::MessageStoreFactoryExceptionWrapper *arg1) {
    delete arg1;
}

swig_class cMessageStoreExceptionWrapper;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MessageStoreExceptionWrapper_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__MessageStoreExceptionWrapper);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MessageStoreExceptionWrapper(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStore *arg1 = (FIX::MessageStore *) 0 ;
  FIX::MessageStoreExceptionWrapper *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::MessageStoreExceptionWrapper";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStore *","FIX::MessageStoreExceptionWrapper", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStore * >(argp1);
  result = (FIX::MessageStoreExceptionWrapper *)new FIX::MessageStoreExceptionWrapper(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_MessageStoreExceptionWrapper(FIX::MessageStoreExceptionWrapper *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_set(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  bool *arg4 = 0 ;
  FIX::IOException *arg5 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","set", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","set", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "bool &","set", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","set", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< bool * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "FIX::IOException &","set", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","set", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< FIX::IOException * >(argp5);
  result = (bool)(arg1)->set(arg2,(std::string const &)*arg3,*arg4,*arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_get(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  bool *arg5 = 0 ;
  FIX::IOException *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","get", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string > &","get", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","get", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< std::string > * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "bool &","get", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","get", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< bool * >(argp5);
  res6 = SWIG_ConvertPtr(argv[4], &argp6, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "FIX::IOException &","get", 6, argv[4] )); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","get", 6, argv[4])); 
  }
  arg6 = reinterpret_cast< FIX::IOException * >(argp6);
  ((FIX::MessageStoreExceptionWrapper const *)arg1)->get(arg2,arg3,*arg4,*arg5,*arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_getNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper const *","getNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","getNextSenderMsgSeqNum", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","getNextSenderMsgSeqNum", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","getNextSenderMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","getNextSenderMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  result = (int)((FIX::MessageStoreExceptionWrapper const *)arg1)->getNextSenderMsgSeqNum(*arg2,*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_getNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper const *","getNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","getNextTargetMsgSeqNum", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","getNextTargetMsgSeqNum", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","getNextTargetMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","getNextTargetMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  result = (int)((FIX::MessageStoreExceptionWrapper const *)arg1)->getNextTargetMsgSeqNum(*arg2,*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  int arg2 ;
  bool *arg3 = 0 ;
  FIX::IOException *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "bool &","setNextSenderMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","setNextSenderMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< bool * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::IOException &","setNextSenderMsgSeqNum", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","setNextSenderMsgSeqNum", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< FIX::IOException * >(argp4);
  (arg1)->setNextSenderMsgSeqNum(arg2,*arg3,*arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  int arg2 ;
  bool *arg3 = 0 ;
  FIX::IOException *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "bool &","setNextTargetMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","setNextTargetMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< bool * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::IOException &","setNextTargetMsgSeqNum", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","setNextTargetMsgSeqNum", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< FIX::IOException * >(argp4);
  (arg1)->setNextTargetMsgSeqNum(arg2,*arg3,*arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_incrNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","incrNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","incrNextSenderMsgSeqNum", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","incrNextSenderMsgSeqNum", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","incrNextSenderMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","incrNextSenderMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  (arg1)->incrNextSenderMsgSeqNum(*arg2,*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_incrNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","incrNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","incrNextTargetMsgSeqNum", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","incrNextTargetMsgSeqNum", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","incrNextTargetMsgSeqNum", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","incrNextTargetMsgSeqNum", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  (arg1)->incrNextTargetMsgSeqNum(*arg2,*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_getCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  UtcTimeStamp result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","getCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","getCreationTime", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","getCreationTime", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","getCreationTime", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","getCreationTime", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  result = (arg1)->getCreationTime(*arg2,*arg3);
  vresult = SWIG_NewPointerObj((new UtcTimeStamp(static_cast< const UtcTimeStamp& >(result))), SWIGTYPE_p_UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_reset(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","reset", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","reset", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","reset", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","reset", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  (arg1)->reset(*arg2,*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MessageStoreExceptionWrapper_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::MessageStoreExceptionWrapper *arg1 = (FIX::MessageStoreExceptionWrapper *) 0 ;
  bool *arg2 = 0 ;
  FIX::IOException *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::MessageStoreExceptionWrapper *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::MessageStoreExceptionWrapper * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "bool &","refresh", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "bool &","refresh", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__IOException,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::IOException &","refresh", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::IOException &","refresh", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::IOException * >(argp3);
  (arg1)->refresh(*arg2,*arg3);
  return Qnil;
fail:
  return Qnil;
}


swig_class cFileStoreFactory;

SWIGINTERN VALUE
_wrap_new_FileStoreFactory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::SessionSettings *arg1 = 0 ;
  FIX::FileStoreFactory *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FileStoreFactory";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FIX::FileStoreFactory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FIX::FileStoreFactory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::SessionSettings * >(argp1);
  result = (FIX::FileStoreFactory *)new FIX::FileStoreFactory((FIX::SessionSettings const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FileStoreFactory_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FileStoreFactory_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FileStoreFactory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FileStoreFactory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::FileStoreFactory *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::FileStoreFactory";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::FileStoreFactory", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::FileStoreFactory", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (FIX::FileStoreFactory *)new FIX::FileStoreFactory((std::string const &)*arg1);DATA_PTR(self) = result;
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FileStoreFactory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FileStoreFactory__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FileStoreFactory__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "FileStoreFactory.new", 
    "    FileStoreFactory.new(FIX::SessionSettings const &settings)\n"
    "    FileStoreFactory.new(std::string const &path)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStoreFactory_create(int argc, VALUE *argv, VALUE self) {
  FIX::FileStoreFactory *arg1 = (FIX::FileStoreFactory *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::MessageStore *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStoreFactory *","create", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","create", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","create", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (FIX::MessageStore *)(arg1)->create((FIX::SessionID const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStoreFactory_destroy(int argc, VALUE *argv, VALUE self) {
  FIX::FileStoreFactory *arg1 = (FIX::FileStoreFactory *) 0 ;
  FIX::MessageStore *arg2 = (FIX::MessageStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStoreFactory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStoreFactory *","destroy", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStoreFactory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FIX__MessageStore, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStore *","destroy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FIX::MessageStore * >(argp2);
  (arg1)->destroy(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_FileStoreFactory(FIX::FileStoreFactory *arg1) {
    delete arg1;
}

swig_class cFileStore;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FileStore_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FileStore_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__FileStore);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FileStore(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  FIX::SessionID *arg2 = 0 ;
  FIX::FileStore *result = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::FileStore";
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","FIX::FileStore", 1, argv[0] )); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","FIX::FileStore", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","FIX::FileStore", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (FIX::FileStore *)new FIX::FileStore(arg1,(FIX::SessionID const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_FileStore(FIX::FileStore *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FileStore_set(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","set", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","set", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","set", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  try {
    result = (bool)(arg1)->set(arg2,(std::string const &)*arg3);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_get(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","get", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string > &","get", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","get", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< std::string > * >(argp4);
  try {
    ((FIX::FileStore const *)arg1)->get(arg2,arg3,*arg4);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_getNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore const *","getNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  try {
    result = (int)((FIX::FileStore const *)arg1)->getNextSenderMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_getNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore const *","getNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  try {
    result = (int)((FIX::FileStore const *)arg1)->getNextTargetMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_setNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","setNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextSenderMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    (arg1)->setNextSenderMsgSeqNum(arg2);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_setNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","setNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setNextTargetMsgSeqNum", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  try {
    (arg1)->setNextTargetMsgSeqNum(arg2);
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_incrNextSenderMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","incrNextSenderMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  try {
    (arg1)->incrNextSenderMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_incrNextTargetMsgSeqNum(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","incrNextTargetMsgSeqNum", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  try {
    (arg1)->incrNextTargetMsgSeqNum();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_getCreationTime(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  UtcTimeStamp result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore const *","getCreationTime", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  try {
    result = ((FIX::FileStore const *)arg1)->getCreationTime();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new UtcTimeStamp(static_cast< const UtcTimeStamp& >(result))), SWIGTYPE_p_UtcTimeStamp, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_reset(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","reset", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  try {
    (arg1)->reset();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileStore_refresh(int argc, VALUE *argv, VALUE self) {
  FIX::FileStore *arg1 = (FIX::FileStore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__FileStore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::FileStore *","refresh", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::FileStore * >(argp1);
  try {
    (arg1)->refresh();
  }
  catch(FIX::IOException &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IOException, SWIG_NewPointerObj((new FIX::IOException(static_cast< const FIX::IOException& >(_e))),SWIGTYPE_p_FIX__IOException,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


swig_class cApplication;

SWIGINTERN void
free_FIX_Application(FIX::Application *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Application_onCreate(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","onCreate", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onCreate", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onCreate", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    if (upcall) {
      Swig::DirectorPureVirtualException::raise("FIX::Application::onCreate");
    } else {
      (arg1)->onCreate((FIX::SessionID const &)*arg2);
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_onLogon(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","onLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onLogon", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onLogon", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    if (upcall) {
      Swig::DirectorPureVirtualException::raise("FIX::Application::onLogon");
    } else {
      (arg1)->onLogon((FIX::SessionID const &)*arg2);
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_onLogout(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","onLogout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onLogout", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onLogout", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    if (upcall) {
      Swig::DirectorPureVirtualException::raise("FIX::Application::onLogout");
    } else {
      (arg1)->onLogout((FIX::SessionID const &)*arg2);
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_toAdmin(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","toAdmin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message &","toAdmin", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","toAdmin", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","toAdmin", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","toAdmin", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    if (upcall) {
      Swig::DirectorPureVirtualException::raise("FIX::Application::toAdmin");
    } else {
      (arg1)->toAdmin(*arg2,(FIX::SessionID const &)*arg3);
    }
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_toApp(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","toApp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message &","toApp", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","toApp", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","toApp", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","toApp", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    try {
      if (upcall) {
        Swig::DirectorPureVirtualException::raise("FIX::Application::toApp");
      } else {
        (arg1)->toApp(*arg2,(FIX::SessionID const &)*arg3);
      }
    }
    catch(FIX::DoNotSend &_e) {
      rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__DoNotSend, SWIG_NewPointerObj((new FIX::DoNotSend(static_cast< const FIX::DoNotSend& >(_e))),SWIGTYPE_p_FIX__DoNotSend,SWIG_POINTER_OWN))); SWIG_fail;
    }
    
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_fromAdmin(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","fromAdmin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","fromAdmin", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","fromAdmin", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","fromAdmin", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","fromAdmin", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    try {
      if (upcall) {
        Swig::DirectorPureVirtualException::raise("FIX::Application::fromAdmin");
      } else {
        (arg1)->fromAdmin((FIX::Message const &)*arg2,(FIX::SessionID const &)*arg3);
      }
    }
    catch(FIX::FieldNotFound &_e) {
      rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
    }
    catch(FIX::IncorrectDataFormat &_e) {
      rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
    }
    catch(FIX::IncorrectTagValue &_e) {
      rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectTagValue, SWIG_NewPointerObj((new FIX::IncorrectTagValue(static_cast< const FIX::IncorrectTagValue& >(_e))),SWIGTYPE_p_FIX__IncorrectTagValue,SWIG_POINTER_OWN))); SWIG_fail;
    }
    catch(FIX::RejectLogon &_e) {
      rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RejectLogon, SWIG_NewPointerObj((new FIX::RejectLogon(static_cast< const FIX::RejectLogon& >(_e))),SWIGTYPE_p_FIX__RejectLogon,SWIG_POINTER_OWN))); SWIG_fail;
    }
    
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Application_fromApp(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","fromApp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","fromApp", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","fromApp", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","fromApp", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","fromApp", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  director = dynamic_cast<Swig::Director *>(arg1);
  upcall = (director && (director->swig_get_self() == self));
  try {
    try {
      if (upcall) {
        Swig::DirectorPureVirtualException::raise("FIX::Application::fromApp");
      } else {
        (arg1)->fromApp((FIX::Message const &)*arg2,(FIX::SessionID const &)*arg3);
      }
    }
    catch(FIX::FieldNotFound &_e) {
      rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
    }
    catch(FIX::IncorrectDataFormat &_e) {
      rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
    }
    catch(FIX::IncorrectTagValue &_e) {
      rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectTagValue, SWIG_NewPointerObj((new FIX::IncorrectTagValue(static_cast< const FIX::IncorrectTagValue& >(_e))),SWIGTYPE_p_FIX__IncorrectTagValue,SWIG_POINTER_OWN))); SWIG_fail;
    }
    catch(FIX::UnsupportedMessageType &_e) {
      rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__UnsupportedMessageType, SWIG_NewPointerObj((new FIX::UnsupportedMessageType(static_cast< const FIX::UnsupportedMessageType& >(_e))),SWIGTYPE_p_FIX__UnsupportedMessageType,SWIG_POINTER_OWN))); SWIG_fail;
    }
    
  } catch (Swig::DirectorException& e) {
    rb_exc_raise(e.getError());
    SWIG_fail;
  }
  return Qnil;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Application_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Application_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__Application);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Application(int argc, VALUE *argv, VALUE self) {
  VALUE arg1 = (VALUE) 0 ;
  FIX::Application *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::Application";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  arg1 = self;
  if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
    /* subclassed */
    result = (FIX::Application *)new SwigDirector_Application(arg1); 
  } else {
    rb_raise(rb_eNameError,"accessing abstract class or protected constructor"); 
    return Qnil;
  }
  DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_disown_Application(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = (FIX::Application *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_FIX__Application, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application *","disown_Application", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  {
    Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
    if (director) director->swig_disown();
  }
  
  return Qnil;
fail:
  return Qnil;
}


swig_class cSynchronizedApplication;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SynchronizedApplication_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SynchronizedApplication_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SynchronizedApplication);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SynchronizedApplication(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::SynchronizedApplication *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SynchronizedApplication";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","FIX::SynchronizedApplication", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","FIX::SynchronizedApplication", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  result = (FIX::SynchronizedApplication *)new FIX::SynchronizedApplication(*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_onCreate(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","onCreate", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onCreate", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onCreate", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  (arg1)->onCreate((FIX::SessionID const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_onLogon(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","onLogon", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onLogon", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onLogon", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  (arg1)->onLogon((FIX::SessionID const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_onLogout(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","onLogout", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","onLogout", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","onLogout", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  (arg1)->onLogout((FIX::SessionID const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_toAdmin(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","toAdmin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message &","toAdmin", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","toAdmin", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","toAdmin", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","toAdmin", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  (arg1)->toAdmin(*arg2,(FIX::SessionID const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_toApp(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","toApp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message &","toApp", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message &","toApp", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","toApp", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","toApp", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  try {
    (arg1)->toApp(*arg2,(FIX::SessionID const &)*arg3);
  }
  catch(FIX::DoNotSend &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__DoNotSend, SWIG_NewPointerObj((new FIX::DoNotSend(static_cast< const FIX::DoNotSend& >(_e))),SWIGTYPE_p_FIX__DoNotSend,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_fromAdmin(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","fromAdmin", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","fromAdmin", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","fromAdmin", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","fromAdmin", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","fromAdmin", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  try {
    (arg1)->fromAdmin((FIX::Message const &)*arg2,(FIX::SessionID const &)*arg3);
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::IncorrectDataFormat &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::IncorrectTagValue &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectTagValue, SWIG_NewPointerObj((new FIX::IncorrectTagValue(static_cast< const FIX::IncorrectTagValue& >(_e))),SWIGTYPE_p_FIX__IncorrectTagValue,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::RejectLogon &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RejectLogon, SWIG_NewPointerObj((new FIX::RejectLogon(static_cast< const FIX::RejectLogon& >(_e))),SWIGTYPE_p_FIX__RejectLogon,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_fromApp(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Message *arg2 = 0 ;
  FIX::SessionID *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","fromApp", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","fromApp", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","fromApp", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionID const &","fromApp", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","fromApp", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< FIX::SessionID * >(argp3);
  try {
    (arg1)->fromApp((FIX::Message const &)*arg2,(FIX::SessionID const &)*arg3);
  }
  catch(FIX::FieldNotFound &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__FieldNotFound, SWIG_NewPointerObj((new FIX::FieldNotFound(static_cast< const FIX::FieldNotFound& >(_e))),SWIGTYPE_p_FIX__FieldNotFound,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::IncorrectDataFormat &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectDataFormat, SWIG_NewPointerObj((new FIX::IncorrectDataFormat(static_cast< const FIX::IncorrectDataFormat& >(_e))),SWIGTYPE_p_FIX__IncorrectDataFormat,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::IncorrectTagValue &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__IncorrectTagValue, SWIG_NewPointerObj((new FIX::IncorrectTagValue(static_cast< const FIX::IncorrectTagValue& >(_e))),SWIGTYPE_p_FIX__IncorrectTagValue,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::UnsupportedMessageType &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__UnsupportedMessageType, SWIG_NewPointerObj((new FIX::UnsupportedMessageType(static_cast< const FIX::UnsupportedMessageType& >(_e))),SWIGTYPE_p_FIX__UnsupportedMessageType,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_m_mutex_set(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  Mutex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","m_mutex", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_Mutex,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Mutex","m_mutex", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Mutex","m_mutex", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< Mutex * >(argp2));
    }
  }
  if (arg1) (arg1)->m_mutex = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_m_mutex_get(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  Mutex result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","m_mutex", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  result =  ((arg1)->m_mutex);
  vresult = SWIG_NewPointerObj((new Mutex(static_cast< const Mutex& >(result))), SWIGTYPE_p_Mutex, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_app(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Application *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Swig::Director *director = 0;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","app", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  {
    FIX::Application &_result_ref = (arg1)->app();
    result = (FIX::Application *) &_result_ref;
  }
  director = dynamic_cast<Swig::Director *>(result);
  if (director) {
    vresult = director->swig_get_self();
  } else {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Application, 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_m_app_set(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Application *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","m_app", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Application &","m_app", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","m_app", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Application * >(argp2);
  if (arg1) (arg1)->m_app = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SynchronizedApplication_m_app_get(int argc, VALUE *argv, VALUE self) {
  FIX::SynchronizedApplication *arg1 = (FIX::SynchronizedApplication *) 0 ;
  FIX::Application *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__SynchronizedApplication, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::SynchronizedApplication *","m_app", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::SynchronizedApplication * >(argp1);
  {
    FIX::Application &_result_ref = (FIX::Application &) ((arg1)->m_app);
    result = (FIX::Application *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Application, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_SynchronizedApplication(FIX::SynchronizedApplication *arg1) {
    delete arg1;
}

swig_class cNullApplication;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_NullApplication_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_NullApplication_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__NullApplication);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_NullApplication(int argc, VALUE *argv, VALUE self) {
  FIX::NullApplication *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::NullApplication";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::NullApplication *)new FIX::NullApplication();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FIX_NullApplication(FIX::NullApplication *arg1) {
    delete arg1;
}

swig_class cInitiator;

SWIGINTERN void
free_FIX_Initiator(FIX::Initiator *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Initiator_start(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","start", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  try {
    (arg1)->start();
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::RuntimeError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RuntimeError, SWIG_NewPointerObj((new FIX::RuntimeError(static_cast< const FIX::RuntimeError& >(_e))),SWIGTYPE_p_FIX__RuntimeError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_block(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","block", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  try {
    (arg1)->block();
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::RuntimeError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RuntimeError, SWIG_NewPointerObj((new FIX::RuntimeError(static_cast< const FIX::RuntimeError& >(_e))),SWIGTYPE_p_FIX__RuntimeError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_poll(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","poll", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  try {
    result = (bool)(arg1)->poll();
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::RuntimeError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RuntimeError, SWIG_NewPointerObj((new FIX::RuntimeError(static_cast< const FIX::RuntimeError& >(_e))),SWIGTYPE_p_FIX__RuntimeError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_stop__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","stop", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","stop", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->stop(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_stop__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","stop", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  (arg1)->stop();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Initiator_stop(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Initiator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Initiator_stop__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Initiator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Initiator_stop__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Initiator.stop", 
    "    void Initiator.stop(bool force)\n"
    "    void Initiator.stop()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_isLoggedOn(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","isLoggedOn", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  result = (bool)(arg1)->isLoggedOn();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getSession(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  Responder *arg3 = 0 ;
  FIX::Session *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","getSession", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","getSession", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","getSession", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_Responder,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "Responder &","getSession", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Responder &","getSession", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< Responder * >(argp3);
  result = (FIX::Session *)(arg1)->getSession((FIX::SessionID const &)*arg2,*arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getSessions(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  SwigValueWrapper< std::set< FIX::SessionID > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator const *","getSessions", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  result = ((FIX::Initiator const *)arg1)->getSessions();
  vresult = SWIG_NewPointerObj((new std::set< FIX::SessionID >(static_cast< const std::set< FIX::SessionID >& >(result))), SWIGTYPE_p_std__setT_FIX__SessionID_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_has(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","has", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","has", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","has", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (bool)(arg1)->has((FIX::SessionID const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_isStopped(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","isStopped", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  result = (bool)(arg1)->isStopped();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getApplication(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  FIX::Application *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Swig::Director *director = 0;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","getApplication", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    FIX::Application &_result_ref = (arg1)->getApplication();
    result = (FIX::Application *) &_result_ref;
  }
  director = dynamic_cast<Swig::Director *>(result);
  if (director) {
    vresult = director->swig_get_self();
  } else {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Application, 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_getMessageStoreFactory(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  FIX::MessageStoreFactory *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","getMessageStoreFactory", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    FIX::MessageStoreFactory &_result_ref = (arg1)->getMessageStoreFactory();
    result = (FIX::MessageStoreFactory *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStoreFactory, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onEvent((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onIncoming((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onOutgoing((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Initiator_clear(int argc, VALUE *argv, VALUE self) {
  FIX::Initiator *arg1 = (FIX::Initiator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Initiator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Initiator *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Initiator * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


swig_class cSocketInitiatorBase;

SWIGINTERN VALUE
_wrap_new_SocketInitiatorBase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  FIX::SocketInitiator *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketInitiatorBase";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","FIX::SocketInitiator", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","FIX::SocketInitiator", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","FIX::SocketInitiator", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","FIX::SocketInitiator", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FIX::SocketInitiator", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FIX::SocketInitiator", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  try {
    result = (FIX::SocketInitiator *)new FIX::SocketInitiator(*arg1,*arg2,(FIX::SessionSettings const &)*arg3);DATA_PTR(self) = result;
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SocketInitiatorBase_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SocketInitiatorBase_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketInitiator);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SocketInitiatorBase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  FIX::LogFactory *arg4 = 0 ;
  FIX::SocketInitiator *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketInitiatorBase";
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","FIX::SocketInitiator", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","FIX::SocketInitiator", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","FIX::SocketInitiator", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","FIX::SocketInitiator", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FIX::SocketInitiator", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FIX::SocketInitiator", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_FIX__LogFactory,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::LogFactory &","FIX::SocketInitiator", 4, argv[3] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::LogFactory &","FIX::SocketInitiator", 4, argv[3])); 
  }
  arg4 = reinterpret_cast< FIX::LogFactory * >(argp4);
  try {
    result = (FIX::SocketInitiator *)new FIX::SocketInitiator(*arg1,*arg2,(FIX::SessionSettings const &)*arg3,*arg4);DATA_PTR(self) = result;
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketInitiatorBase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SocketInitiatorBase__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__LogFactory, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SocketInitiatorBase__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SocketInitiator.new", 
    "    SocketInitiator.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &)\n"
    "    SocketInitiator.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &, FIX::LogFactory &)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketInitiator(FIX::SocketInitiator *arg1) {
    delete arg1;
}

swig_class cAcceptor;

SWIGINTERN void
free_FIX_Acceptor(FIX::Acceptor *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Acceptor_start(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","start", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  try {
    (arg1)->start();
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::RuntimeError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RuntimeError, SWIG_NewPointerObj((new FIX::RuntimeError(static_cast< const FIX::RuntimeError& >(_e))),SWIGTYPE_p_FIX__RuntimeError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_block(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","block", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  try {
    (arg1)->block();
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::RuntimeError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RuntimeError, SWIG_NewPointerObj((new FIX::RuntimeError(static_cast< const FIX::RuntimeError& >(_e))),SWIGTYPE_p_FIX__RuntimeError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_poll(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","poll", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  try {
    result = (bool)(arg1)->poll();
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  catch(FIX::RuntimeError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__RuntimeError, SWIG_NewPointerObj((new FIX::RuntimeError(static_cast< const FIX::RuntimeError& >(_e))),SWIGTYPE_p_FIX__RuntimeError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_stop__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","stop", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","stop", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->stop(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_stop__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","stop", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  (arg1)->stop();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Acceptor_stop(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Acceptor, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Acceptor_stop__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Acceptor, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Acceptor_stop__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Acceptor.stop", 
    "    void Acceptor.stop(bool force)\n"
    "    void Acceptor.stop()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_isLoggedOn(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","isLoggedOn", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  result = (bool)(arg1)->isLoggedOn();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_getSession(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  std::string *arg2 = 0 ;
  Responder *arg3 = 0 ;
  FIX::Session *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","getSession", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSession", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSession", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_Responder,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "Responder &","getSession", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Responder &","getSession", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< Responder * >(argp3);
  result = (FIX::Session *)(arg1)->getSession((std::string const &)*arg2,*arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Session, 0 |  0 );
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_getSessions(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  SwigValueWrapper< std::set< FIX::SessionID > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor const *","getSessions", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  result = ((FIX::Acceptor const *)arg1)->getSessions();
  vresult = SWIG_NewPointerObj((new std::set< FIX::SessionID >(static_cast< const std::set< FIX::SessionID >& >(result))), SWIGTYPE_p_std__setT_FIX__SessionID_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_has(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  FIX::SessionID *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","has", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__SessionID,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::SessionID const &","has", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionID const &","has", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::SessionID * >(argp2);
  result = (bool)(arg1)->has((FIX::SessionID const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_isStopped(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","isStopped", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  result = (bool)(arg1)->isStopped();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_getApplication(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  FIX::Application *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Swig::Director *director = 0;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","getApplication", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    FIX::Application &_result_ref = (arg1)->getApplication();
    result = (FIX::Application *) &_result_ref;
  }
  director = dynamic_cast<Swig::Director *>(result);
  if (director) {
    vresult = director->swig_get_self();
  } else {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__Application, 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_getMessageStoreFactory(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  FIX::MessageStoreFactory *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","getMessageStoreFactory", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    FIX::MessageStoreFactory &_result_ref = (arg1)->getMessageStoreFactory();
    result = (FIX::MessageStoreFactory *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FIX__MessageStoreFactory, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_onEvent(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","onEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onEvent((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_onIncoming(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","onIncoming", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onIncoming", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onIncoming", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onIncoming((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_onOutgoing(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","onOutgoing", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","onOutgoing", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","onOutgoing", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->onOutgoing((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Acceptor_clear(int argc, VALUE *argv, VALUE self) {
  FIX::Acceptor *arg1 = (FIX::Acceptor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__Acceptor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Acceptor *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::Acceptor * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


swig_class cSocketAcceptorBase;

SWIGINTERN VALUE
_wrap_new_SocketAcceptorBase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  FIX::SocketAcceptor *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketAcceptorBase";
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","FIX::SocketAcceptor", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","FIX::SocketAcceptor", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","FIX::SocketAcceptor", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","FIX::SocketAcceptor", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FIX::SocketAcceptor", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FIX::SocketAcceptor", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  try {
    result = (FIX::SocketAcceptor *)new FIX::SocketAcceptor(*arg1,*arg2,(FIX::SessionSettings const &)*arg3);DATA_PTR(self) = result;
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SocketAcceptorBase_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SocketAcceptorBase_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__SocketAcceptor);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SocketAcceptorBase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::Application *arg1 = 0 ;
  FIX::MessageStoreFactory *arg2 = 0 ;
  FIX::SessionSettings *arg3 = 0 ;
  FIX::LogFactory *arg4 = 0 ;
  FIX::SocketAcceptor *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::SocketAcceptorBase";
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__Application,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::Application &","FIX::SocketAcceptor", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Application &","FIX::SocketAcceptor", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::Application * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_FIX__MessageStoreFactory,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::MessageStoreFactory &","FIX::SocketAcceptor", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::MessageStoreFactory &","FIX::SocketAcceptor", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< FIX::MessageStoreFactory * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_FIX__SessionSettings,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "FIX::SessionSettings const &","FIX::SocketAcceptor", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::SessionSettings const &","FIX::SocketAcceptor", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< FIX::SessionSettings * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_FIX__LogFactory,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "FIX::LogFactory &","FIX::SocketAcceptor", 4, argv[3] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::LogFactory &","FIX::SocketAcceptor", 4, argv[3])); 
  }
  arg4 = reinterpret_cast< FIX::LogFactory * >(argp4);
  try {
    result = (FIX::SocketAcceptor *)new FIX::SocketAcceptor(*arg1,*arg2,(FIX::SessionSettings const &)*arg3,*arg4);DATA_PTR(self) = result;
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SocketAcceptorBase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SocketAcceptorBase__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__Application, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_FIX__MessageStoreFactory, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_FIX__SessionSettings, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_FIX__LogFactory, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SocketAcceptorBase__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SocketAcceptor.new", 
    "    SocketAcceptor.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &)\n"
    "    SocketAcceptor.new(FIX::Application &, FIX::MessageStoreFactory &, FIX::SessionSettings const &, FIX::LogFactory &)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_SocketAcceptor(FIX::SocketAcceptor *arg1) {
    delete arg1;
}

swig_class cDataDictionary;

SWIGINTERN VALUE
_wrap_new_DataDictionary__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *result = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionary";
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (FIX::DataDictionary *)new FIX::DataDictionary();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DataDictionary__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = 0 ;
  FIX::DataDictionary *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionary";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","FIX::DataDictionary", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","FIX::DataDictionary", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  result = (FIX::DataDictionary *)new FIX::DataDictionary((FIX::DataDictionary const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DataDictionary__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = 0 ;
  FIX::DataDictionary *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionary";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream &","FIX::DataDictionary", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","FIX::DataDictionary", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  try {
    result = (FIX::DataDictionary *)new FIX::DataDictionary(*arg1);DATA_PTR(self) = result;
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DataDictionary_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DataDictionary_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FIX__DataDictionary);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DataDictionary__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  FIX::DataDictionary *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Quickfix::DataDictionary";
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","FIX::DataDictionary", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","FIX::DataDictionary", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  try {
    result = (FIX::DataDictionary *)new FIX::DataDictionary((std::string const &)*arg1);DATA_PTR(self) = result;
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg1->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DataDictionary(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_DataDictionary__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FIX__DataDictionary, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataDictionary__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataDictionary__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataDictionary__SWIG_3(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "DataDictionary.new", 
    "    DataDictionary.new()\n"
    "    DataDictionary.new(FIX::DataDictionary const &copy)\n"
    "    DataDictionary.new(std::istream &stream)\n"
    "    DataDictionary.new(std::string const &url)\n");
  
  return Qnil;
}


SWIGINTERN void
free_FIX_DataDictionary(FIX::DataDictionary *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_DataDictionary_readFromURL(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","readFromURL", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","readFromURL", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","readFromURL", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  try {
    (arg1)->readFromURL((std::string const &)*arg2);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_readFromDocument(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  DOMDocumentPtr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","readFromDocument", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_DOMDocumentPtr,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "DOMDocumentPtr","readFromDocument", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "DOMDocumentPtr","readFromDocument", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< DOMDocumentPtr * >(argp2));
    }
  }
  try {
    (arg1)->readFromDocument(arg2);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_readFromStream(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::istream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","readFromStream", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::istream &","readFromStream", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","readFromStream", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::istream * >(argp2);
  try {
    (arg1)->readFromStream(*arg2);
  }
  catch(FIX::ConfigError &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__ConfigError, SWIG_NewPointerObj((new FIX::ConfigError(static_cast< const FIX::ConfigError& >(_e))),SWIGTYPE_p_FIX__ConfigError,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_getOrderedFields(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getOrderedFields", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  result = (int *)((FIX::DataDictionary const *)arg1)->getOrderedFields();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_setVersion(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","setVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setVersion", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setVersion", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->setVersion((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_getVersion(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  result = ((FIX::DataDictionary const *)arg1)->getVersion();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->addField(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addFieldName(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addFieldName", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addFieldName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addFieldName", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addFieldName", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  (arg1)->addFieldName(arg2,(std::string const &)*arg3);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary__getFieldName(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string temp3 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getFieldName", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getFieldName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    temp3 = std::string((char*)STR2CSTR(argv[1]));
    arg3 = &temp3;
  }
  result = (bool)((FIX::DataDictionary const *)arg1)->getFieldName(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary__getFieldTag(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string arg2 ;
  int *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp3 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getFieldTag", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","getFieldTag", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    temp3 = NUM2INT(argv[1]);
    arg3 = &temp3;
  }
  result = (bool)((FIX::DataDictionary const *)arg1)->getFieldTag(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("int &") == "int &" )
    {
      vresult = result ? SWIG_From_int(static_cast< int >(*arg3)) : Qnil;
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addValueName(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addValueName", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addValueName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addValueName", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addValueName", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","addValueName", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addValueName", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  (arg1)->addValueName(arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  vresult = rb_ary_new();
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary__getValueName(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  std::string temp4 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getValueName", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getValueName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","getValueName", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getValueName", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    temp4 = std::string((char*)STR2CSTR(argv[2]));
    arg4 = &temp4;
  }
  result = (bool)((FIX::DataDictionary const *)arg1)->getValueName(arg2,(std::string const &)*arg3,*arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  {
    if( std::string("std::string &") == "std::string &" )
    {
      rb_str_resize( argv[2], 0 );
      rb_str_append( argv[2], rb_str_new2(arg4->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((FIX::DataDictionary const *)arg1)->isField(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addMsgType(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addMsgType", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addMsgType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addMsgType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->addMsgType((std::string const &)*arg2);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isMsgType(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isMsgType", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isMsgType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isMsgType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)((FIX::DataDictionary const *)arg1)->isMsgType((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addMsgField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addMsgField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addMsgField", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addMsgField", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","addMsgField", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->addMsgField((std::string const &)*arg2,arg3);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isMsgField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isMsgField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isMsgField", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isMsgField", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isMsgField", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (bool)((FIX::DataDictionary const *)arg1)->isMsgField((std::string const &)*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addHeaderField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addHeaderField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addHeaderField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","addHeaderField", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->addHeaderField(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isHeaderField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isHeaderField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isHeaderField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((FIX::DataDictionary const *)arg1)->isHeaderField(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addTrailerField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addTrailerField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addTrailerField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","addTrailerField", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->addTrailerField(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isTrailerField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isTrailerField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isTrailerField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((FIX::DataDictionary const *)arg1)->isTrailerField(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addFieldType(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  TYPE::Type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addFieldType", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addFieldType", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_TYPE__Type,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "TYPE::Type","addFieldType", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "TYPE::Type","addFieldType", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< TYPE::Type * >(argp3));
    }
  }
  (arg1)->addFieldType(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_getFieldType(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  TYPE::Type *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getFieldType", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getFieldType", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_TYPE__Type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "TYPE::Type &","getFieldType", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "TYPE::Type &","getFieldType", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< TYPE::Type * >(argp3);
  result = (bool)((FIX::DataDictionary const *)arg1)->getFieldType(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addRequiredField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addRequiredField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addRequiredField", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addRequiredField", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","addRequiredField", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->addRequiredField((std::string const &)*arg2,arg3);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isRequiredField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isRequiredField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isRequiredField", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isRequiredField", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isRequiredField", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (bool)((FIX::DataDictionary const *)arg1)->isRequiredField((std::string const &)*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addFieldValue(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addFieldValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","addFieldValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addFieldValue", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addFieldValue", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  (arg1)->addFieldValue(arg2,(std::string const &)*arg3);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_hasFieldValue(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","hasFieldValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","hasFieldValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((FIX::DataDictionary const *)arg1)->hasFieldValue(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isFieldValue(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isFieldValue", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isFieldValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","isFieldValue", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isFieldValue", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (bool)((FIX::DataDictionary const *)arg1)->isFieldValue(arg2,(std::string const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[1], 0 );
      rb_str_append( argv[1], rb_str_new2(arg3->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_addGroup(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  FIX::DataDictionary *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","addGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addGroup", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addGroup", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","addGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","addGroup", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_FIX__DataDictionary,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "FIX::DataDictionary const &","addGroup", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::DataDictionary const &","addGroup", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< FIX::DataDictionary * >(argp5);
  (arg1)->addGroup((std::string const &)*arg2,arg3,arg4,(FIX::DataDictionary const &)*arg5);
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isGroup(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isGroup", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isGroup", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (bool)((FIX::DataDictionary const *)arg1)->isGroup((std::string const &)*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary__getGroup(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  int *arg4 = 0 ;
  FIX::DataDictionary **arg5 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  int temp4 ;
  FIX::DataDictionary *temp5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","getGroup", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getGroup", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getGroup", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","getGroup", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  {
    temp4 = NUM2INT(argv[2]);
    arg4 = &temp4;
  }
  {
    arg5 = new FIX::DataDictionary*[1];
    *arg5 = temp5;
  }
  result = (bool)((FIX::DataDictionary const *)arg1)->getGroup((std::string const &)*arg2,arg3,*arg4,(FIX::DataDictionary const *&)*arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  {
    if( std::string("std::string const &") == "std::string &" )
    {
      rb_str_resize( argv[0], 0 );
      rb_str_append( argv[0], rb_str_new2(arg2->c_str()) );
    }
  }
  {
    if( std::string("int &") == "int &" )
    {
      vresult = result ? SWIG_From_int(static_cast< int >(*arg4)) : Qnil;
    }
  }
  {
    void* argp;
    FIX::DataDictionary* pDD = 0;
    int res = SWIG_ConvertPtr(argv[3], &argp, SWIGTYPE_p_FIX__DataDictionary, 0 );
    pDD = reinterpret_cast< FIX::DataDictionary * >(argp);
    *pDD = *(*arg5);
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isDataField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isDataField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isDataField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((FIX::DataDictionary const *)arg1)->isDataField(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_isMultipleValueStringField(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary const *","isMultipleValueStringField", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","isMultipleValueStringField", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((FIX::DataDictionary const *)arg1)->isMultipleValueStringField(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_checkFieldsOutOfOrder(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","checkFieldsOutOfOrder", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","checkFieldsOutOfOrder", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->checkFieldsOutOfOrder(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_checkFieldsHaveValues(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","checkFieldsHaveValues", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","checkFieldsHaveValues", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->checkFieldsHaveValues(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_checkUserDefinedFields(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","checkUserDefinedFields", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","checkUserDefinedFields", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->checkUserDefinedFields(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DataDictionary_validate(int argc, VALUE *argv, VALUE self) {
  FIX::DataDictionary *arg1 = (FIX::DataDictionary *) 0 ;
  FIX::Message *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FIX__DataDictionary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FIX::DataDictionary *","validate", 1, self )); 
  }
  arg1 = reinterpret_cast< FIX::DataDictionary * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_FIX__Message,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FIX::Message const &","validate", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FIX::Message const &","validate", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< FIX::Message * >(argp2);
  try {
    (arg1)->validate((FIX::Message const &)*arg2);
  }
  catch(FIX::Exception &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_FIX__Exception, SWIG_NewPointerObj((new FIX::Exception(static_cast< const FIX::Exception& >(_e))),SWIGTYPE_p_FIX__Exception,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_FIX__SocketAcceptorTo_p_FIX__Acceptor(void *x, int *newmemory) {
    return (void *)((FIX::Acceptor *)  ((FIX::SocketAcceptor *) x));
}
static void *_p_FIX__SynchronizedApplicationTo_p_FIX__Application(void *x, int *newmemory) {
    return (void *)((FIX::Application *)  ((FIX::SynchronizedApplication *) x));
}
static void *_p_FIX__NullApplicationTo_p_FIX__Application(void *x, int *newmemory) {
    return (void *)((FIX::Application *)  ((FIX::NullApplication *) x));
}
static void *_p_IntArrayTo_p_int(void *x, int *newmemory) {
    return (void *)((int *)  ((IntArray *) x));
}
static void *_p_FIX__SecuritySettlAgentNameTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::SecuritySettlAgentName *) x));
}
static void *_p_FIX__ExecBrokerTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::ExecBroker *) x));
}
static void *_p_FIX__CashSettlAgentNameTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::CashSettlAgentName *) x));
}
static void *_p_FIX__BrokerOfCreditTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::BrokerOfCredit *) x));
}
static void *_p_FIX__SettlBrkrCodeTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::SettlBrkrCode *) x));
}
static void *_p_FIX__SettlLocationTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::SettlLocation *) x));
}
static void *_p_FIX__RegistDetlsTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::RegistDetls *) x));
}
static void *_p_FIX__CardIssNoTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::CardIssNo *) x));
}
static void *_p_FIX__OpenCloseSettleFlagTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::OpenCloseSettleFlag *) x));
}
static void *_p_FIX__ClearingFirmTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::ClearingFirm *) x));
}
static void *_p_FIX__SecuritySettlAgentCodeTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::SecuritySettlAgentCode *) x));
}
static void *_p_FIX__CashSettlAgentCodeTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::CashSettlAgentCode *) x));
}
static void *_p_FIX__FutSettDateTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::FutSettDate *) x));
}
static void *_p_FIX__LegFutSettDateTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::LegFutSettDate *) x));
}
static void *_p_FIX__RelatdSymTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::RelatdSym *) x));
}
static void *_p_FIX__ClearingAccountTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::ClearingAccount *) x));
}
static void *_p_FIX__SettlDepositoryCodeTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::SettlDepositoryCode *) x));
}
static void *_p_FIX__IDSourceTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::IDSource *) x));
}
static void *_p_FIX__SecuritySettlAgentAcctNameTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::SecuritySettlAgentAcctName *) x));
}
static void *_p_FIX__SecuritySettlAgentContactNameTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::SecuritySettlAgentContactName *) x));
}
static void *_p_FIX__CashSettlAgentAcctNameTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::CashSettlAgentAcctName *) x));
}
static void *_p_FIX__CashSettlAgentContactNameTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::CashSettlAgentContactName *) x));
}
static void *_p_FIX__MaturityDayTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::MaturityDay *) x));
}
static void *_p_FIX__UnderlyingIDSourceTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::UnderlyingIDSource *) x));
}
static void *_p_FIX__UnderlyingMaturityDayTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::UnderlyingMaturityDay *) x));
}
static void *_p_FIX__ClientIDTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::ClientID *) x));
}
static void *_p_FIX__SecuritySettlAgentContactPhoneTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::SecuritySettlAgentContactPhone *) x));
}
static void *_p_FIX__CashSettlAgentContactPhoneTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::CashSettlAgentContactPhone *) x));
}
static void *_p_FIX__FutSettDate2To_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::FutSettDate2 *) x));
}
static void *_p_FIX__SecuritySettlAgentAcctNumTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::SecuritySettlAgentAcctNum *) x));
}
static void *_p_FIX__SettlInstCodeTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::SettlInstCode *) x));
}
static void *_p_FIX__IOISharesTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::IOIShares *) x));
}
static void *_p_FIX__CashSettlAgentAcctNumTo_p_FIX__StringField(void *x, int *newmemory) {
    return (void *)((FIX::StringField *)  ((FIX::CashSettlAgentAcctNum *) x));
}
static void *_p_FIX__MemoryStoreTo_p_FIX__MessageStore(void *x, int *newmemory) {
    return (void *)((FIX::MessageStore *)  ((FIX::MemoryStore *) x));
}
static void *_p_FIX__FileStoreTo_p_FIX__MessageStore(void *x, int *newmemory) {
    return (void *)((FIX::MessageStore *)  ((FIX::FileStore *) x));
}
static void *_p_FIX__SpreadToBenchmarkTo_p_FIX__DoubleField(void *x, int *newmemory) {
    return (void *)((FIX::DoubleField *)  ((FIX::SpreadToBenchmark *) x));
}
static void *_p_FIX__RatioQtyTo_p_FIX__DoubleField(void *x, int *newmemory) {
    return (void *)((FIX::DoubleField *)  ((FIX::RatioQty *) x));
}
static void *_p_FIX__DiscretionOffsetTo_p_FIX__DoubleField(void *x, int *newmemory) {
    return (void *)((FIX::DoubleField *)  ((FIX::DiscretionOffset *) x));
}
static void *_p_FIX__LastSharesTo_p_FIX__DoubleField(void *x, int *newmemory) {
    return (void *)((FIX::DoubleField *)  ((FIX::LastShares *) x));
}
static void *_p_FIX__SharesTo_p_FIX__DoubleField(void *x, int *newmemory) {
    return (void *)((FIX::DoubleField *)  ((FIX::Shares *) x));
}
static void *_p_FIX__PegDifferenceTo_p_FIX__DoubleField(void *x, int *newmemory) {
    return (void *)((FIX::DoubleField *)  ((FIX::PegDifference *) x));
}
static void *_p_FIX__TotalVolumeTradedDateTo_p_FIX__UtcDateField(void *x, int *newmemory) {
    return (void *)((FIX::UtcDateField *)  ((FIX::TotalVolumeTradedDate *) x));
}
static void *_p_FIX__SocketInitiatorTo_p_FIX__Initiator(void *x, int *newmemory) {
    return (void *)((FIX::Initiator *)  ((FIX::SocketInitiator *) x));
}
static void *_p_FIX__GroupTo_p_FIX__FieldMap(void *x, int *newmemory) {
    return (void *)((FIX::FieldMap *)  ((FIX::Group *) x));
}
static void *_p_FIX__MessageTo_p_FIX__FieldMap(void *x, int *newmemory) {
    return (void *)((FIX::FieldMap *)  ((FIX::Message *) x));
}
static void *_p_FIX__InitiatorTo_p_FIX__Log(void *x, int *newmemory) {
    return (void *)((FIX::Log *)  ((FIX::Initiator *) x));
}
static void *_p_FIX__SocketInitiatorTo_p_FIX__Log(void *x, int *newmemory) {
    return (void *)((FIX::Log *) (FIX::Initiator *) ((FIX::SocketInitiator *) x));
}
static void *_p_FIX__AcceptorTo_p_FIX__Log(void *x, int *newmemory) {
    return (void *)((FIX::Log *)  ((FIX::Acceptor *) x));
}
static void *_p_FIX__SocketAcceptorTo_p_FIX__Log(void *x, int *newmemory) {
    return (void *)((FIX::Log *) (FIX::Acceptor *) ((FIX::SocketAcceptor *) x));
}
static void *_p_FIX__FileLogTo_p_FIX__Log(void *x, int *newmemory) {
    return (void *)((FIX::Log *)  ((FIX::FileLog *) x));
}
static void *_p_FIX__ScreenLogTo_p_FIX__Log(void *x, int *newmemory) {
    return (void *)((FIX::Log *)  ((FIX::ScreenLog *) x));
}
static void *_p_FIX__CustomerOrFirmTo_p_FIX__IntField(void *x, int *newmemory) {
    return (void *)((FIX::IntField *)  ((FIX::CustomerOrFirm *) x));
}
static void *_p_FIX__QuoteAckStatusTo_p_FIX__IntField(void *x, int *newmemory) {
    return (void *)((FIX::IntField *)  ((FIX::QuoteAckStatus *) x));
}
static void *_p_FIX__AvgPrxPrecisionTo_p_FIX__IntField(void *x, int *newmemory) {
    return (void *)((FIX::IntField *)  ((FIX::AvgPrxPrecision *) x));
}
static void *_p_FIX__AllocSharesTo_p_FIX__IntField(void *x, int *newmemory) {
    return (void *)((FIX::IntField *)  ((FIX::AllocShares *) x));
}
static void *_p_FIX__TotQuoteEntriesTo_p_FIX__IntField(void *x, int *newmemory) {
    return (void *)((FIX::IntField *)  ((FIX::TotQuoteEntries *) x));
}
static void *_p_FIX__TotalNumSecurityTypesTo_p_FIX__IntField(void *x, int *newmemory) {
    return (void *)((FIX::IntField *)  ((FIX::TotalNumSecurityTypes *) x));
}
static void *_p_FIX__PutOrCallTo_p_FIX__IntField(void *x, int *newmemory) {
    return (void *)((FIX::IntField *)  ((FIX::PutOrCall *) x));
}
static void *_p_FIX__UnderlyingPutOrCallTo_p_FIX__IntField(void *x, int *newmemory) {
    return (void *)((FIX::IntField *)  ((FIX::UnderlyingPutOrCall *) x));
}
static void *_p_FIX__TotalNumSecuritiesTo_p_FIX__IntField(void *x, int *newmemory) {
    return (void *)((FIX::IntField *)  ((FIX::TotalNumSecurities *) x));
}
static void *_p_FIX__RequiredTagMissingTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::RequiredTagMissing *) x));
}
static void *_p_FIX__SocketSendFailedTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *) (FIX::SocketException *) ((FIX::SocketSendFailed *) x));
}
static void *_p_FIX__SocketRecvFailedTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *) (FIX::SocketException *) ((FIX::SocketRecvFailed *) x));
}
static void *_p_FIX__InvalidTagNumberTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::InvalidTagNumber *) x));
}
static void *_p_FIX__RejectLogonTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::RejectLogon *) x));
}
static void *_p_FIX__IncorrectDataFormatTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::IncorrectDataFormat *) x));
}
static void *_p_FIX__TagNotDefinedForMessageTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::TagNotDefinedForMessage *) x));
}
static void *_p_FIX__InvalidMessageTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::InvalidMessage *) x));
}
static void *_p_FIX__DuplicateFieldNumberTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::DuplicateFieldNumber *) x));
}
static void *_p_FIX__RuntimeErrorTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::RuntimeError *) x));
}
static void *_p_FIX__MessageParseErrorTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::MessageParseError *) x));
}
static void *_p_FIX__DoNotSendTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::DoNotSend *) x));
}
static void *_p_FIX__FieldNotFoundTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::FieldNotFound *) x));
}
static void *_p_FIX__SessionNotFoundTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::SessionNotFound *) x));
}
static void *_p_FIX__IOExceptionTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::IOException *) x));
}
static void *_p_FIX__SocketExceptionTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::SocketException *) x));
}
static void *_p_FIX__ConfigErrorTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::ConfigError *) x));
}
static void *_p_FIX__InvalidMessageTypeTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::InvalidMessageType *) x));
}
static void *_p_FIX__UnsupportedMessageTypeTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::UnsupportedMessageType *) x));
}
static void *_p_FIX__UnsupportedVersionTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::UnsupportedVersion *) x));
}
static void *_p_FIX__IncorrectTagValueTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::IncorrectTagValue *) x));
}
static void *_p_FIX__NoTagValueTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::NoTagValue *) x));
}
static void *_p_FIX__TagOutOfOrderTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::TagOutOfOrder *) x));
}
static void *_p_FIX__RepeatedTagTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::RepeatedTag *) x));
}
static void *_p_FIX__SocketCloseFailedTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *) (FIX::SocketException *) ((FIX::SocketCloseFailed *) x));
}
static void *_p_FIX__FieldConvertErrorTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::FieldConvertError *) x));
}
static void *_p_FIX__IncorrectMessageStructureTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::IncorrectMessageStructure *) x));
}
static void *_p_FIX__RepeatingGroupCountMismatchTo_p_FIX__Exception(void *x, int *newmemory) {
    return (void *)((FIX::Exception *)  ((FIX::RepeatingGroupCountMismatch *) x));
}
static void *_p_FIX__SocketSendFailedTo_p_FIX__SocketException(void *x, int *newmemory) {
    return (void *)((FIX::SocketException *)  ((FIX::SocketSendFailed *) x));
}
static void *_p_FIX__SocketRecvFailedTo_p_FIX__SocketException(void *x, int *newmemory) {
    return (void *)((FIX::SocketException *)  ((FIX::SocketRecvFailed *) x));
}
static void *_p_FIX__SocketCloseFailedTo_p_FIX__SocketException(void *x, int *newmemory) {
    return (void *)((FIX::SocketException *)  ((FIX::SocketCloseFailed *) x));
}
static void *_p_FIX__Rule80ATo_p_FIX__CharField(void *x, int *newmemory) {
    return (void *)((FIX::CharField *)  ((FIX::Rule80A *) x));
}
static void *_p_FIX__BenchmarkTo_p_FIX__CharField(void *x, int *newmemory) {
    return (void *)((FIX::CharField *)  ((FIX::Benchmark *) x));
}
static void *_p_FIX__SettlmntTypTo_p_FIX__CharField(void *x, int *newmemory) {
    return (void *)((FIX::CharField *)  ((FIX::SettlmntTyp *) x));
}
static void *_p_FIX__LegSettlmntTypTo_p_FIX__CharField(void *x, int *newmemory) {
    return (void *)((FIX::CharField *)  ((FIX::LegSettlmntTyp *) x));
}
static void *_p_FIX__OpenCloseTo_p_FIX__CharField(void *x, int *newmemory) {
    return (void *)((FIX::CharField *)  ((FIX::OpenClose *) x));
}
static void *_p_FIX__CxlTypeTo_p_FIX__CharField(void *x, int *newmemory) {
    return (void *)((FIX::CharField *)  ((FIX::CxlType *) x));
}
static void *_p_FIX__ExecTransTypeTo_p_FIX__CharField(void *x, int *newmemory) {
    return (void *)((FIX::CharField *)  ((FIX::ExecTransType *) x));
}
static void *_p_FIX__DlvyInstTo_p_FIX__CharField(void *x, int *newmemory) {
    return (void *)((FIX::CharField *)  ((FIX::DlvyInst *) x));
}
static void *_p_FIX__IOIOthSvcTo_p_FIX__CharField(void *x, int *newmemory) {
    return (void *)((FIX::CharField *)  ((FIX::IOIOthSvc *) x));
}
static void *_p_FIX__TradeTypeTo_p_FIX__CharField(void *x, int *newmemory) {
    return (void *)((FIX::CharField *)  ((FIX::TradeType *) x));
}
static void *_p_FIX__TotalVolumeTradedTimeTo_p_FIX__UtcTimeOnlyField(void *x, int *newmemory) {
    return (void *)((FIX::UtcTimeOnlyField *)  ((FIX::TotalVolumeTradedTime *) x));
}
static void *_p_FIX__QuoteAckStatusTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::IntField *) ((FIX::QuoteAckStatus *) x));
}
static void *_p_FIX__OpenCloseSettleFlagTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::OpenCloseSettleFlag *) x));
}
static void *_p_FIX__DoubleFieldTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *)  ((FIX::DoubleField *) x));
}
static void *_p_FIX__UtcDateFieldTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *)  ((FIX::UtcDateField *) x));
}
static void *_p_FIX__SecuritySettlAgentNameTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SecuritySettlAgentName *) x));
}
static void *_p_FIX__CashSettlAgentNameTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::CashSettlAgentName *) x));
}
static void *_p_FIX__TotalVolumeTradedDateTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::UtcDateField *) ((FIX::TotalVolumeTradedDate *) x));
}
static void *_p_FIX__CheckSumFieldTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *)  ((FIX::CheckSumField *) x));
}
static void *_p_FIX__TotalNumSecurityTypesTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::IntField *) ((FIX::TotalNumSecurityTypes *) x));
}
static void *_p_FIX__AllocSharesTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::IntField *) ((FIX::AllocShares *) x));
}
static void *_p_FIX__IOISharesTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::IOIShares *) x));
}
static void *_p_FIX__SecuritySettlAgentAcctNameTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SecuritySettlAgentAcctName *) x));
}
static void *_p_FIX__SecuritySettlAgentContactNameTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SecuritySettlAgentContactName *) x));
}
static void *_p_FIX__CashSettlAgentAcctNameTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::CashSettlAgentAcctName *) x));
}
static void *_p_FIX__CashSettlAgentContactNameTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::CashSettlAgentContactName *) x));
}
static void *_p_FIX__RelatdSymTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::RelatdSym *) x));
}
static void *_p_FIX__FutSettDateTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::FutSettDate *) x));
}
static void *_p_FIX__StringFieldTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *)  ((FIX::StringField *) x));
}
static void *_p_FIX__FutSettDate2To_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::FutSettDate2 *) x));
}
static void *_p_FIX__PegDifferenceTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::DoubleField *) ((FIX::PegDifference *) x));
}
static void *_p_FIX__RegistDetlsTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::RegistDetls *) x));
}
static void *_p_FIX__LegFutSettDateTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::LegFutSettDate *) x));
}
static void *_p_FIX__IntFieldTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *)  ((FIX::IntField *) x));
}
static void *_p_FIX__SettlLocationTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SettlLocation *) x));
}
static void *_p_FIX__CardIssNoTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::CardIssNo *) x));
}
static void *_p_FIX__ClearingAccountTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::ClearingAccount *) x));
}
static void *_p_FIX__PutOrCallTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::IntField *) ((FIX::PutOrCall *) x));
}
static void *_p_FIX__TotQuoteEntriesTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::IntField *) ((FIX::TotQuoteEntries *) x));
}
static void *_p_FIX__UnderlyingPutOrCallTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::IntField *) ((FIX::UnderlyingPutOrCall *) x));
}
static void *_p_FIX__IOIOthSvcTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::CharField *) ((FIX::IOIOthSvc *) x));
}
static void *_p_FIX__TotalVolumeTradedTimeTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::UtcTimeOnlyField *) ((FIX::TotalVolumeTradedTime *) x));
}
static void *_p_FIX__IDSourceTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::IDSource *) x));
}
static void *_p_FIX__UnderlyingIDSourceTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::UnderlyingIDSource *) x));
}
static void *_p_FIX__DlvyInstTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::CharField *) ((FIX::DlvyInst *) x));
}
static void *_p_FIX__ClearingFirmTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::ClearingFirm *) x));
}
static void *_p_FIX__SpreadToBenchmarkTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::DoubleField *) ((FIX::SpreadToBenchmark *) x));
}
static void *_p_FIX__BenchmarkTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::CharField *) ((FIX::Benchmark *) x));
}
static void *_p_FIX__SettlDepositoryCodeTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SettlDepositoryCode *) x));
}
static void *_p_FIX__BoolFieldTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *)  ((FIX::BoolField *) x));
}
static void *_p_FIX__BrokerOfCreditTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::BrokerOfCredit *) x));
}
static void *_p_FIX__OnBehalfOfSendingTimeTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::UtcTimeStampField *) ((FIX::OnBehalfOfSendingTime *) x));
}
static void *_p_FIX__OpenCloseTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::CharField *) ((FIX::OpenClose *) x));
}
static void *_p_FIX__AvgPrxPrecisionTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::IntField *) ((FIX::AvgPrxPrecision *) x));
}
static void *_p_FIX__SecuritySettlAgentContactPhoneTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SecuritySettlAgentContactPhone *) x));
}
static void *_p_FIX__CashSettlAgentContactPhoneTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::CashSettlAgentContactPhone *) x));
}
static void *_p_FIX__DiscretionOffsetTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::DoubleField *) ((FIX::DiscretionOffset *) x));
}
static void *_p_FIX__ExecTransTypeTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::CharField *) ((FIX::ExecTransType *) x));
}
static void *_p_FIX__UtcTimeStampFieldTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *)  ((FIX::UtcTimeStampField *) x));
}
static void *_p_FIX__CharFieldTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *)  ((FIX::CharField *) x));
}
static void *_p_FIX__SettlBrkrCodeTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SettlBrkrCode *) x));
}
static void *_p_FIX__ExecBrokerTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::ExecBroker *) x));
}
static void *_p_FIX__CustomerOrFirmTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::IntField *) ((FIX::CustomerOrFirm *) x));
}
static void *_p_FIX__RatioQtyTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::DoubleField *) ((FIX::RatioQty *) x));
}
static void *_p_FIX__SharesTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::DoubleField *) ((FIX::Shares *) x));
}
static void *_p_FIX__LastSharesTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::DoubleField *) ((FIX::LastShares *) x));
}
static void *_p_FIX__TradeTypeTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::CharField *) ((FIX::TradeType *) x));
}
static void *_p_FIX__SecuritySettlAgentAcctNumTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SecuritySettlAgentAcctNum *) x));
}
static void *_p_FIX__Rule80ATo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::CharField *) ((FIX::Rule80A *) x));
}
static void *_p_FIX__CxlTypeTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::CharField *) ((FIX::CxlType *) x));
}
static void *_p_FIX__UtcTimeOnlyFieldTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *)  ((FIX::UtcTimeOnlyField *) x));
}
static void *_p_FIX__CashSettlAgentAcctNumTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::CashSettlAgentAcctNum *) x));
}
static void *_p_FIX__SettlInstCodeTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SettlInstCode *) x));
}
static void *_p_FIX__SecuritySettlAgentCodeTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::SecuritySettlAgentCode *) x));
}
static void *_p_FIX__CashSettlAgentCodeTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::CashSettlAgentCode *) x));
}
static void *_p_FIX__TotalNumSecuritiesTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::IntField *) ((FIX::TotalNumSecurities *) x));
}
static void *_p_FIX__MaturityDayTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::MaturityDay *) x));
}
static void *_p_FIX__UnderlyingMaturityDayTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::UnderlyingMaturityDay *) x));
}
static void *_p_FIX__ClientIDTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::StringField *) ((FIX::ClientID *) x));
}
static void *_p_FIX__SettlmntTypTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::CharField *) ((FIX::SettlmntTyp *) x));
}
static void *_p_FIX__LegSettlmntTypTo_p_FIX__FieldBase(void *x, int *newmemory) {
    return (void *)((FIX::FieldBase *) (FIX::CharField *) ((FIX::LegSettlmntTyp *) x));
}
static void *_p_FIX__ScreenLogFactoryTo_p_FIX__LogFactory(void *x, int *newmemory) {
    return (void *)((FIX::LogFactory *)  ((FIX::ScreenLogFactory *) x));
}
static void *_p_FIX__FileLogFactoryTo_p_FIX__LogFactory(void *x, int *newmemory) {
    return (void *)((FIX::LogFactory *)  ((FIX::FileLogFactory *) x));
}
static void *_p_FIX__MemoryStoreFactoryTo_p_FIX__MessageStoreFactory(void *x, int *newmemory) {
    return (void *)((FIX::MessageStoreFactory *)  ((FIX::MemoryStoreFactory *) x));
}
static void *_p_FIX__FileStoreFactoryTo_p_FIX__MessageStoreFactory(void *x, int *newmemory) {
    return (void *)((FIX::MessageStoreFactory *)  ((FIX::FileStoreFactory *) x));
}
static void *_p_FIX__OnBehalfOfSendingTimeTo_p_FIX__UtcTimeStampField(void *x, int *newmemory) {
    return (void *)((FIX::UtcTimeStampField *)  ((FIX::OnBehalfOfSendingTime *) x));
}
static swig_type_info _swigt__p_Application = {"_p_Application", "Application *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_BeginString = {"_p_BeginString", "BeginString *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DOMDocumentPtr = {"_p_DOMDocumentPtr", "DOMDocumentPtr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Data = {"_p_Data", "Data *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DataDictionary = {"_p_DataDictionary", "DataDictionary *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Dictionaries = {"_p_Dictionaries", "Dictionaries *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DoubleField = {"_p_DoubleField", "DoubleField *|QtyField *|PriceField *|PercentageField *|AmtField *|FloatField *|PriceOffsetField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIELD__Field = {"_p_FIELD__Field", "FIELD::Field *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX_CHAR = {"_p_FIX_CHAR", "FIX_CHAR *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX_DAYOFMONTH = {"_p_FIX_DAYOFMONTH", "FIX_DAYOFMONTH *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX_INT = {"_p_FIX_INT", "FIX_INT *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX_LOCALMKTDATE = {"_p_FIX_LOCALMKTDATE", "FIX_LOCALMKTDATE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX_PRICEOFFSET = {"_p_FIX_PRICEOFFSET", "FIX_PRICEOFFSET *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX_QTY = {"_p_FIX_QTY", "FIX_QTY *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX_STRING = {"_p_FIX_STRING", "FIX_STRING *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX_UTCDATE = {"_p_FIX_UTCDATE", "FIX_UTCDATE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX_UTCTIMEONLY = {"_p_FIX_UTCTIMEONLY", "FIX_UTCTIMEONLY *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX_UTCTIMESTAMP = {"_p_FIX_UTCTIMESTAMP", "FIX_UTCTIMESTAMP *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Acceptor = {"_p_FIX__Acceptor", "FIX::Acceptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__AllocShares = {"_p_FIX__AllocShares", "FIX::AllocShares *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Application = {"_p_FIX__Application", "FIX::Application *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__AvgPrxPrecision = {"_p_FIX__AvgPrxPrecision", "FIX::AvgPrxPrecision *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Benchmark = {"_p_FIX__Benchmark", "FIX::Benchmark *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__BoolField = {"_p_FIX__BoolField", "FIX::BoolField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__BrokerOfCredit = {"_p_FIX__BrokerOfCredit", "FIX::BrokerOfCredit *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CardIssNo = {"_p_FIX__CardIssNo", "FIX::CardIssNo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CashSettlAgentAcctName = {"_p_FIX__CashSettlAgentAcctName", "FIX::CashSettlAgentAcctName *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CashSettlAgentAcctNum = {"_p_FIX__CashSettlAgentAcctNum", "FIX::CashSettlAgentAcctNum *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CashSettlAgentCode = {"_p_FIX__CashSettlAgentCode", "FIX::CashSettlAgentCode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CashSettlAgentContactName = {"_p_FIX__CashSettlAgentContactName", "FIX::CashSettlAgentContactName *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CashSettlAgentContactPhone = {"_p_FIX__CashSettlAgentContactPhone", "FIX::CashSettlAgentContactPhone *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CashSettlAgentName = {"_p_FIX__CashSettlAgentName", "FIX::CashSettlAgentName *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CharField = {"_p_FIX__CharField", "FIX::CharField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CheckSumField = {"_p_FIX__CheckSumField", "FIX::CheckSumField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ClearingAccount = {"_p_FIX__ClearingAccount", "FIX::ClearingAccount *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ClearingFirm = {"_p_FIX__ClearingFirm", "FIX::ClearingFirm *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ClientID = {"_p_FIX__ClientID", "FIX::ClientID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ConfigError = {"_p_FIX__ConfigError", "FIX::ConfigError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CustomerOrFirm = {"_p_FIX__CustomerOrFirm", "FIX::CustomerOrFirm *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__CxlType = {"_p_FIX__CxlType", "FIX::CxlType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DataDictionary = {"_p_FIX__DataDictionary", "FIX::DataDictionary *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Dictionary = {"_p_FIX__Dictionary", "FIX::Dictionary *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Dictionary__Data__const_iterator = {"_p_FIX__Dictionary__Data__const_iterator", "FIX::Dictionary::Data::const_iterator *|FIX::Dictionary::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DiscretionOffset = {"_p_FIX__DiscretionOffset", "FIX::DiscretionOffset *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DlvyInst = {"_p_FIX__DlvyInst", "FIX::DlvyInst *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DoNotSend = {"_p_FIX__DoNotSend", "FIX::DoNotSend *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DoubleField = {"_p_FIX__DoubleField", "FIX::DoubleField *|FIX::QtyField *|FIX::PriceField *|FIX::PercentageField *|FIX::AmtField *|FIX::FloatField *|FIX::PriceOffsetField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__DuplicateFieldNumber = {"_p_FIX__DuplicateFieldNumber", "FIX::DuplicateFieldNumber *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Exception = {"_p_FIX__Exception", "FIX::Exception *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ExecBroker = {"_p_FIX__ExecBroker", "FIX::ExecBroker *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ExecTransType = {"_p_FIX__ExecTransType", "FIX::ExecTransType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FieldBase = {"_p_FIX__FieldBase", "FIX::FieldBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FieldConvertError = {"_p_FIX__FieldConvertError", "FIX::FieldConvertError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FieldMap = {"_p_FIX__FieldMap", "FIX::FieldMap *|FIX::Trailer *|FIX::Header *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FieldMap__Fields__const_iterator = {"_p_FIX__FieldMap__Fields__const_iterator", "FIX::FieldMap::Fields::const_iterator *|FIX::FieldMap::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FieldMap__Groups__const_iterator = {"_p_FIX__FieldMap__Groups__const_iterator", "FIX::FieldMap::Groups::const_iterator *|FIX::FieldMap::g_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FieldNotFound = {"_p_FIX__FieldNotFound", "FIX::FieldNotFound *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FileLog = {"_p_FIX__FileLog", "FIX::FileLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FileLogFactory = {"_p_FIX__FileLogFactory", "FIX::FileLogFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FileStore = {"_p_FIX__FileStore", "FIX::FileStore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FileStoreFactory = {"_p_FIX__FileStoreFactory", "FIX::FileStoreFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FutSettDate = {"_p_FIX__FutSettDate", "FIX::FutSettDate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__FutSettDate2 = {"_p_FIX__FutSettDate2", "FIX::FutSettDate2 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Group = {"_p_FIX__Group", "FIX::Group *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IDSource = {"_p_FIX__IDSource", "FIX::IDSource *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IOException = {"_p_FIX__IOException", "FIX::IOException *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IOIOthSvc = {"_p_FIX__IOIOthSvc", "FIX::IOIOthSvc *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IOIShares = {"_p_FIX__IOIShares", "FIX::IOIShares *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IncorrectDataFormat = {"_p_FIX__IncorrectDataFormat", "FIX::IncorrectDataFormat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IncorrectMessageStructure = {"_p_FIX__IncorrectMessageStructure", "FIX::IncorrectMessageStructure *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IncorrectTagValue = {"_p_FIX__IncorrectTagValue", "FIX::IncorrectTagValue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Initiator = {"_p_FIX__Initiator", "FIX::Initiator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__IntField = {"_p_FIX__IntField", "FIX::IntField *|FIX::LengthField *|FIX::NumInGroupField *|FIX::SeqNumField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__InvalidMessage = {"_p_FIX__InvalidMessage", "FIX::InvalidMessage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__InvalidMessageType = {"_p_FIX__InvalidMessageType", "FIX::InvalidMessageType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__InvalidTagNumber = {"_p_FIX__InvalidTagNumber", "FIX::InvalidTagNumber *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__LastShares = {"_p_FIX__LastShares", "FIX::LastShares *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__LegFutSettDate = {"_p_FIX__LegFutSettDate", "FIX::LegFutSettDate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__LegSettlmntTyp = {"_p_FIX__LegSettlmntTyp", "FIX::LegSettlmntTyp *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Log = {"_p_FIX__Log", "FIX::Log *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__LogFactory = {"_p_FIX__LogFactory", "FIX::LogFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MaturityDay = {"_p_FIX__MaturityDay", "FIX::MaturityDay *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MemoryStore = {"_p_FIX__MemoryStore", "FIX::MemoryStore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MemoryStoreFactory = {"_p_FIX__MemoryStoreFactory", "FIX::MemoryStoreFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Message = {"_p_FIX__Message", "FIX::Message *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MessageParseError = {"_p_FIX__MessageParseError", "FIX::MessageParseError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MessageStore = {"_p_FIX__MessageStore", "FIX::MessageStore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MessageStoreExceptionWrapper = {"_p_FIX__MessageStoreExceptionWrapper", "FIX::MessageStoreExceptionWrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MessageStoreFactory = {"_p_FIX__MessageStoreFactory", "FIX::MessageStoreFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__MessageStoreFactoryExceptionWrapper = {"_p_FIX__MessageStoreFactoryExceptionWrapper", "FIX::MessageStoreFactoryExceptionWrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__NoTagValue = {"_p_FIX__NoTagValue", "FIX::NoTagValue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__NullApplication = {"_p_FIX__NullApplication", "FIX::NullApplication *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__OnBehalfOfSendingTime = {"_p_FIX__OnBehalfOfSendingTime", "FIX::OnBehalfOfSendingTime *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__OpenClose = {"_p_FIX__OpenClose", "FIX::OpenClose *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__OpenCloseSettleFlag = {"_p_FIX__OpenCloseSettleFlag", "FIX::OpenCloseSettleFlag *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__PegDifference = {"_p_FIX__PegDifference", "FIX::PegDifference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__PutOrCall = {"_p_FIX__PutOrCall", "FIX::PutOrCall *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__QuoteAckStatus = {"_p_FIX__QuoteAckStatus", "FIX::QuoteAckStatus *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RatioQty = {"_p_FIX__RatioQty", "FIX::RatioQty *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RegistDetls = {"_p_FIX__RegistDetls", "FIX::RegistDetls *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RejectLogon = {"_p_FIX__RejectLogon", "FIX::RejectLogon *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RelatdSym = {"_p_FIX__RelatdSym", "FIX::RelatdSym *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RepeatedTag = {"_p_FIX__RepeatedTag", "FIX::RepeatedTag *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RepeatingGroupCountMismatch = {"_p_FIX__RepeatingGroupCountMismatch", "FIX::RepeatingGroupCountMismatch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RequiredTagMissing = {"_p_FIX__RequiredTagMissing", "FIX::RequiredTagMissing *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Rule80A = {"_p_FIX__Rule80A", "FIX::Rule80A *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__RuntimeError = {"_p_FIX__RuntimeError", "FIX::RuntimeError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ScreenLog = {"_p_FIX__ScreenLog", "FIX::ScreenLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__ScreenLogFactory = {"_p_FIX__ScreenLogFactory", "FIX::ScreenLogFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SecuritySettlAgentAcctName = {"_p_FIX__SecuritySettlAgentAcctName", "FIX::SecuritySettlAgentAcctName *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SecuritySettlAgentAcctNum = {"_p_FIX__SecuritySettlAgentAcctNum", "FIX::SecuritySettlAgentAcctNum *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SecuritySettlAgentCode = {"_p_FIX__SecuritySettlAgentCode", "FIX::SecuritySettlAgentCode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SecuritySettlAgentContactName = {"_p_FIX__SecuritySettlAgentContactName", "FIX::SecuritySettlAgentContactName *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SecuritySettlAgentContactPhone = {"_p_FIX__SecuritySettlAgentContactPhone", "FIX::SecuritySettlAgentContactPhone *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SecuritySettlAgentName = {"_p_FIX__SecuritySettlAgentName", "FIX::SecuritySettlAgentName *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Session = {"_p_FIX__Session", "FIX::Session *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SessionID = {"_p_FIX__SessionID", "FIX::SessionID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SessionNotFound = {"_p_FIX__SessionNotFound", "FIX::SessionNotFound *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SessionSettings = {"_p_FIX__SessionSettings", "FIX::SessionSettings *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SettlBrkrCode = {"_p_FIX__SettlBrkrCode", "FIX::SettlBrkrCode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SettlDepositoryCode = {"_p_FIX__SettlDepositoryCode", "FIX::SettlDepositoryCode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SettlInstCode = {"_p_FIX__SettlInstCode", "FIX::SettlInstCode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SettlLocation = {"_p_FIX__SettlLocation", "FIX::SettlLocation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SettlmntTyp = {"_p_FIX__SettlmntTyp", "FIX::SettlmntTyp *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__Shares = {"_p_FIX__Shares", "FIX::Shares *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketAcceptor = {"_p_FIX__SocketAcceptor", "FIX::SocketAcceptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketCloseFailed = {"_p_FIX__SocketCloseFailed", "FIX::SocketCloseFailed *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketException = {"_p_FIX__SocketException", "FIX::SocketException *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketInitiator = {"_p_FIX__SocketInitiator", "FIX::SocketInitiator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketRecvFailed = {"_p_FIX__SocketRecvFailed", "FIX::SocketRecvFailed *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SocketSendFailed = {"_p_FIX__SocketSendFailed", "FIX::SocketSendFailed *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SpreadToBenchmark = {"_p_FIX__SpreadToBenchmark", "FIX::SpreadToBenchmark *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__StringField = {"_p_FIX__StringField", "FIX::StringField *|FIX::CurrencyField *|FIX::MultipleValueStringField *|FIX::MonthYearField *|FIX::CountryField *|FIX::ExchangeField *|FIX::DataField *|FIX::MonthField *|FIX::DayOfMonthField *|FIX::LocalMktDateField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__SynchronizedApplication = {"_p_FIX__SynchronizedApplication", "FIX::SynchronizedApplication *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TagNotDefinedForMessage = {"_p_FIX__TagNotDefinedForMessage", "FIX::TagNotDefinedForMessage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TagOutOfOrder = {"_p_FIX__TagOutOfOrder", "FIX::TagOutOfOrder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TotQuoteEntries = {"_p_FIX__TotQuoteEntries", "FIX::TotQuoteEntries *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TotalNumSecurities = {"_p_FIX__TotalNumSecurities", "FIX::TotalNumSecurities *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TotalNumSecurityTypes = {"_p_FIX__TotalNumSecurityTypes", "FIX::TotalNumSecurityTypes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TotalVolumeTradedDate = {"_p_FIX__TotalVolumeTradedDate", "FIX::TotalVolumeTradedDate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TotalVolumeTradedTime = {"_p_FIX__TotalVolumeTradedTime", "FIX::TotalVolumeTradedTime *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__TradeType = {"_p_FIX__TradeType", "FIX::TradeType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UnderlyingIDSource = {"_p_FIX__UnderlyingIDSource", "FIX::UnderlyingIDSource *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UnderlyingMaturityDay = {"_p_FIX__UnderlyingMaturityDay", "FIX::UnderlyingMaturityDay *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UnderlyingPutOrCall = {"_p_FIX__UnderlyingPutOrCall", "FIX::UnderlyingPutOrCall *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UnsupportedMessageType = {"_p_FIX__UnsupportedMessageType", "FIX::UnsupportedMessageType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UnsupportedVersion = {"_p_FIX__UnsupportedVersion", "FIX::UnsupportedVersion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UtcDateField = {"_p_FIX__UtcDateField", "FIX::UtcDateField *|FIX::UtcDateOnlyField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UtcTimeOnlyField = {"_p_FIX__UtcTimeOnlyField", "FIX::UtcTimeOnlyField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FIX__UtcTimeStampField = {"_p_FIX__UtcTimeStampField", "FIX::UtcTimeStampField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Fields = {"_p_Fields", "Fields *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Group = {"_p_Group", "Group *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Groups = {"_p_Groups", "Groups *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IntArray = {"_p_IntArray", "IntArray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IntField = {"_p_IntField", "IntField *|LengthField *|NumInGroupField *|SeqNumField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Log = {"_p_Log", "Log *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LogFactory = {"_p_LogFactory", "LogFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MessageStore = {"_p_MessageStore", "MessageStore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MessageStoreFactory = {"_p_MessageStoreFactory", "MessageStoreFactory *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MsgType = {"_p_MsgType", "MsgType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Mutex = {"_p_Mutex", "Mutex *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Responder = {"_p_Responder", "Responder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SenderCompID = {"_p_SenderCompID", "SenderCompID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SessionID = {"_p_SessionID", "SessionID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SessionTime = {"_p_SessionTime", "SessionTime *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_StringField = {"_p_StringField", "StringField *|CurrencyField *|MultipleValueStringField *|MonthYearField *|CountryField *|ExchangeField *|DataField *|MonthField *|DayOfMonthField *|LocalMktDateField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TYPE__Type = {"_p_TYPE__Type", "TYPE::Type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TargetCompID = {"_p_TargetCompID", "TargetCompID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UtcDate = {"_p_UtcDate", "UtcDate *|UTCDATE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UtcDateField = {"_p_UtcDateField", "UtcDateField *|UtcDateOnlyField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UtcDateOnly = {"_p_UtcDateOnly", "UtcDateOnly *|UTCDATEONLY *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UtcTimeOnly = {"_p_UtcTimeOnly", "UtcTimeOnly *|UTCTIMEONLY *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UtcTimeStamp = {"_p_UtcTimeStamp", "UtcTimeStamp *|UTCTIMESTAMP *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_bool = {"_p_bool", "bool *|BOOLEAN *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "CHAR *|char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_iterator = {"_p_const_iterator", "const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "PERCENTAGE *|QTY *|FLOAT *|PRICEOFFSET *|AMT *|PRICE *|double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_g_const_iterator = {"_p_g_const_iterator", "g_const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_g_iterator = {"_p_g_iterator", "g_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "SEQNUM *|int *|INT *|LENGTH *|NUMINGROUP *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_iterator = {"_p_iterator", "iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_message_order = {"_p_message_order", "message_order *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_FIX__DataDictionary = {"_p_p_FIX__DataDictionary", "FIX::DataDictionary **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__istream = {"_p_std__istream", "std::istream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ostream = {"_p_std__ostream", "std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__setT_FIX__SessionID_t = {"_p_std__setT_FIX__SessionID_t", "std::set< FIX::SessionID > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "EXCHANGE *|DATA *|CURRENCY *|LOCALMKTDATE *|MONTHYEAR *|STRING *|COUNTRY *|MULTIPLEVALUESTRING *|std::string *|DAYOFMONTH *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string__size_type = {"_p_std__string__size_type", "std::string::size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__string_t = {"_p_std__vectorT_std__string_t", "std::vector< std::string > *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Application,
  &_swigt__p_BeginString,
  &_swigt__p_DOMDocumentPtr,
  &_swigt__p_Data,
  &_swigt__p_DataDictionary,
  &_swigt__p_Dictionaries,
  &_swigt__p_DoubleField,
  &_swigt__p_FIELD__Field,
  &_swigt__p_FIX_CHAR,
  &_swigt__p_FIX_DAYOFMONTH,
  &_swigt__p_FIX_INT,
  &_swigt__p_FIX_LOCALMKTDATE,
  &_swigt__p_FIX_PRICEOFFSET,
  &_swigt__p_FIX_QTY,
  &_swigt__p_FIX_STRING,
  &_swigt__p_FIX_UTCDATE,
  &_swigt__p_FIX_UTCTIMEONLY,
  &_swigt__p_FIX_UTCTIMESTAMP,
  &_swigt__p_FIX__Acceptor,
  &_swigt__p_FIX__AllocShares,
  &_swigt__p_FIX__Application,
  &_swigt__p_FIX__AvgPrxPrecision,
  &_swigt__p_FIX__Benchmark,
  &_swigt__p_FIX__BoolField,
  &_swigt__p_FIX__BrokerOfCredit,
  &_swigt__p_FIX__CardIssNo,
  &_swigt__p_FIX__CashSettlAgentAcctName,
  &_swigt__p_FIX__CashSettlAgentAcctNum,
  &_swigt__p_FIX__CashSettlAgentCode,
  &_swigt__p_FIX__CashSettlAgentContactName,
  &_swigt__p_FIX__CashSettlAgentContactPhone,
  &_swigt__p_FIX__CashSettlAgentName,
  &_swigt__p_FIX__CharField,
  &_swigt__p_FIX__CheckSumField,
  &_swigt__p_FIX__ClearingAccount,
  &_swigt__p_FIX__ClearingFirm,
  &_swigt__p_FIX__ClientID,
  &_swigt__p_FIX__ConfigError,
  &_swigt__p_FIX__CustomerOrFirm,
  &_swigt__p_FIX__CxlType,
  &_swigt__p_FIX__DataDictionary,
  &_swigt__p_FIX__Dictionary,
  &_swigt__p_FIX__Dictionary__Data__const_iterator,
  &_swigt__p_FIX__DiscretionOffset,
  &_swigt__p_FIX__DlvyInst,
  &_swigt__p_FIX__DoNotSend,
  &_swigt__p_FIX__DoubleField,
  &_swigt__p_FIX__DuplicateFieldNumber,
  &_swigt__p_FIX__Exception,
  &_swigt__p_FIX__ExecBroker,
  &_swigt__p_FIX__ExecTransType,
  &_swigt__p_FIX__FieldBase,
  &_swigt__p_FIX__FieldConvertError,
  &_swigt__p_FIX__FieldMap,
  &_swigt__p_FIX__FieldMap__Fields__const_iterator,
  &_swigt__p_FIX__FieldMap__Groups__const_iterator,
  &_swigt__p_FIX__FieldNotFound,
  &_swigt__p_FIX__FileLog,
  &_swigt__p_FIX__FileLogFactory,
  &_swigt__p_FIX__FileStore,
  &_swigt__p_FIX__FileStoreFactory,
  &_swigt__p_FIX__FutSettDate,
  &_swigt__p_FIX__FutSettDate2,
  &_swigt__p_FIX__Group,
  &_swigt__p_FIX__IDSource,
  &_swigt__p_FIX__IOException,
  &_swigt__p_FIX__IOIOthSvc,
  &_swigt__p_FIX__IOIShares,
  &_swigt__p_FIX__IncorrectDataFormat,
  &_swigt__p_FIX__IncorrectMessageStructure,
  &_swigt__p_FIX__IncorrectTagValue,
  &_swigt__p_FIX__Initiator,
  &_swigt__p_FIX__IntField,
  &_swigt__p_FIX__InvalidMessage,
  &_swigt__p_FIX__InvalidMessageType,
  &_swigt__p_FIX__InvalidTagNumber,
  &_swigt__p_FIX__LastShares,
  &_swigt__p_FIX__LegFutSettDate,
  &_swigt__p_FIX__LegSettlmntTyp,
  &_swigt__p_FIX__Log,
  &_swigt__p_FIX__LogFactory,
  &_swigt__p_FIX__MaturityDay,
  &_swigt__p_FIX__MemoryStore,
  &_swigt__p_FIX__MemoryStoreFactory,
  &_swigt__p_FIX__Message,
  &_swigt__p_FIX__MessageParseError,
  &_swigt__p_FIX__MessageStore,
  &_swigt__p_FIX__MessageStoreExceptionWrapper,
  &_swigt__p_FIX__MessageStoreFactory,
  &_swigt__p_FIX__MessageStoreFactoryExceptionWrapper,
  &_swigt__p_FIX__NoTagValue,
  &_swigt__p_FIX__NullApplication,
  &_swigt__p_FIX__OnBehalfOfSendingTime,
  &_swigt__p_FIX__OpenClose,
  &_swigt__p_FIX__OpenCloseSettleFlag,
  &_swigt__p_FIX__PegDifference,
  &_swigt__p_FIX__PutOrCall,
  &_swigt__p_FIX__QuoteAckStatus,
  &_swigt__p_FIX__RatioQty,
  &_swigt__p_FIX__RegistDetls,
  &_swigt__p_FIX__RejectLogon,
  &_swigt__p_FIX__RelatdSym,
  &_swigt__p_FIX__RepeatedTag,
  &_swigt__p_FIX__RepeatingGroupCountMismatch,
  &_swigt__p_FIX__RequiredTagMissing,
  &_swigt__p_FIX__Rule80A,
  &_swigt__p_FIX__RuntimeError,
  &_swigt__p_FIX__ScreenLog,
  &_swigt__p_FIX__ScreenLogFactory,
  &_swigt__p_FIX__SecuritySettlAgentAcctName,
  &_swigt__p_FIX__SecuritySettlAgentAcctNum,
  &_swigt__p_FIX__SecuritySettlAgentCode,
  &_swigt__p_FIX__SecuritySettlAgentContactName,
  &_swigt__p_FIX__SecuritySettlAgentContactPhone,
  &_swigt__p_FIX__SecuritySettlAgentName,
  &_swigt__p_FIX__Session,
  &_swigt__p_FIX__SessionID,
  &_swigt__p_FIX__SessionNotFound,
  &_swigt__p_FIX__SessionSettings,
  &_swigt__p_FIX__SettlBrkrCode,
  &_swigt__p_FIX__SettlDepositoryCode,
  &_swigt__p_FIX__SettlInstCode,
  &_swigt__p_FIX__SettlLocation,
  &_swigt__p_FIX__SettlmntTyp,
  &_swigt__p_FIX__Shares,
  &_swigt__p_FIX__SocketAcceptor,
  &_swigt__p_FIX__SocketCloseFailed,
  &_swigt__p_FIX__SocketException,
  &_swigt__p_FIX__SocketInitiator,
  &_swigt__p_FIX__SocketRecvFailed,
  &_swigt__p_FIX__SocketSendFailed,
  &_swigt__p_FIX__SpreadToBenchmark,
  &_swigt__p_FIX__StringField,
  &_swigt__p_FIX__SynchronizedApplication,
  &_swigt__p_FIX__TagNotDefinedForMessage,
  &_swigt__p_FIX__TagOutOfOrder,
  &_swigt__p_FIX__TotQuoteEntries,
  &_swigt__p_FIX__TotalNumSecurities,
  &_swigt__p_FIX__TotalNumSecurityTypes,
  &_swigt__p_FIX__TotalVolumeTradedDate,
  &_swigt__p_FIX__TotalVolumeTradedTime,
  &_swigt__p_FIX__TradeType,
  &_swigt__p_FIX__UnderlyingIDSource,
  &_swigt__p_FIX__UnderlyingMaturityDay,
  &_swigt__p_FIX__UnderlyingPutOrCall,
  &_swigt__p_FIX__UnsupportedMessageType,
  &_swigt__p_FIX__UnsupportedVersion,
  &_swigt__p_FIX__UtcDateField,
  &_swigt__p_FIX__UtcTimeOnlyField,
  &_swigt__p_FIX__UtcTimeStampField,
  &_swigt__p_Fields,
  &_swigt__p_Group,
  &_swigt__p_Groups,
  &_swigt__p_IntArray,
  &_swigt__p_IntField,
  &_swigt__p_Log,
  &_swigt__p_LogFactory,
  &_swigt__p_MessageStore,
  &_swigt__p_MessageStoreFactory,
  &_swigt__p_MsgType,
  &_swigt__p_Mutex,
  &_swigt__p_Responder,
  &_swigt__p_SenderCompID,
  &_swigt__p_SessionID,
  &_swigt__p_SessionTime,
  &_swigt__p_StringField,
  &_swigt__p_TYPE__Type,
  &_swigt__p_TargetCompID,
  &_swigt__p_UtcDate,
  &_swigt__p_UtcDateField,
  &_swigt__p_UtcDateOnly,
  &_swigt__p_UtcTimeOnly,
  &_swigt__p_UtcTimeStamp,
  &_swigt__p_bool,
  &_swigt__p_char,
  &_swigt__p_const_iterator,
  &_swigt__p_double,
  &_swigt__p_g_const_iterator,
  &_swigt__p_g_iterator,
  &_swigt__p_int,
  &_swigt__p_iterator,
  &_swigt__p_message_order,
  &_swigt__p_p_FIX__DataDictionary,
  &_swigt__p_std__istream,
  &_swigt__p_std__ostream,
  &_swigt__p_std__setT_FIX__SessionID_t,
  &_swigt__p_std__string,
  &_swigt__p_std__string__size_type,
  &_swigt__p_std__vectorT_std__string_t,
};

static swig_cast_info _swigc__p_Application[] = {  {&_swigt__p_Application, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BeginString[] = {  {&_swigt__p_BeginString, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DOMDocumentPtr[] = {  {&_swigt__p_DOMDocumentPtr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Data[] = {  {&_swigt__p_Data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DataDictionary[] = {  {&_swigt__p_DataDictionary, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Dictionaries[] = {  {&_swigt__p_Dictionaries, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DoubleField[] = {  {&_swigt__p_DoubleField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIELD__Field[] = {  {&_swigt__p_FIELD__Field, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX_CHAR[] = {  {&_swigt__p_FIX_CHAR, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX_DAYOFMONTH[] = {  {&_swigt__p_FIX_DAYOFMONTH, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX_INT[] = {  {&_swigt__p_FIX_INT, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX_LOCALMKTDATE[] = {  {&_swigt__p_FIX_LOCALMKTDATE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX_PRICEOFFSET[] = {  {&_swigt__p_FIX_PRICEOFFSET, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX_QTY[] = {  {&_swigt__p_FIX_QTY, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX_STRING[] = {  {&_swigt__p_FIX_STRING, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX_UTCDATE[] = {  {&_swigt__p_FIX_UTCDATE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX_UTCTIMEONLY[] = {  {&_swigt__p_FIX_UTCTIMEONLY, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX_UTCTIMESTAMP[] = {  {&_swigt__p_FIX_UTCTIMESTAMP, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Acceptor[] = {  {&_swigt__p_FIX__Acceptor, 0, 0, 0},  {&_swigt__p_FIX__SocketAcceptor, _p_FIX__SocketAcceptorTo_p_FIX__Acceptor, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__AllocShares[] = {  {&_swigt__p_FIX__AllocShares, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Application[] = {  {&_swigt__p_FIX__Application, 0, 0, 0},  {&_swigt__p_FIX__SynchronizedApplication, _p_FIX__SynchronizedApplicationTo_p_FIX__Application, 0, 0},  {&_swigt__p_FIX__NullApplication, _p_FIX__NullApplicationTo_p_FIX__Application, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__AvgPrxPrecision[] = {  {&_swigt__p_FIX__AvgPrxPrecision, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Benchmark[] = {  {&_swigt__p_FIX__Benchmark, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__BoolField[] = {  {&_swigt__p_FIX__BoolField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__BrokerOfCredit[] = {  {&_swigt__p_FIX__BrokerOfCredit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CardIssNo[] = {  {&_swigt__p_FIX__CardIssNo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CashSettlAgentAcctName[] = {  {&_swigt__p_FIX__CashSettlAgentAcctName, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CashSettlAgentAcctNum[] = {  {&_swigt__p_FIX__CashSettlAgentAcctNum, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CashSettlAgentCode[] = {  {&_swigt__p_FIX__CashSettlAgentCode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CashSettlAgentContactName[] = {  {&_swigt__p_FIX__CashSettlAgentContactName, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CashSettlAgentContactPhone[] = {  {&_swigt__p_FIX__CashSettlAgentContactPhone, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CashSettlAgentName[] = {  {&_swigt__p_FIX__CashSettlAgentName, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CharField[] = {  {&_swigt__p_FIX__CharField, 0, 0, 0},  {&_swigt__p_FIX__Rule80A, _p_FIX__Rule80ATo_p_FIX__CharField, 0, 0},  {&_swigt__p_FIX__Benchmark, _p_FIX__BenchmarkTo_p_FIX__CharField, 0, 0},  {&_swigt__p_FIX__SettlmntTyp, _p_FIX__SettlmntTypTo_p_FIX__CharField, 0, 0},  {&_swigt__p_FIX__LegSettlmntTyp, _p_FIX__LegSettlmntTypTo_p_FIX__CharField, 0, 0},  {&_swigt__p_FIX__OpenClose, _p_FIX__OpenCloseTo_p_FIX__CharField, 0, 0},  {&_swigt__p_FIX__CxlType, _p_FIX__CxlTypeTo_p_FIX__CharField, 0, 0},  {&_swigt__p_FIX__ExecTransType, _p_FIX__ExecTransTypeTo_p_FIX__CharField, 0, 0},  {&_swigt__p_FIX__DlvyInst, _p_FIX__DlvyInstTo_p_FIX__CharField, 0, 0},  {&_swigt__p_FIX__IOIOthSvc, _p_FIX__IOIOthSvcTo_p_FIX__CharField, 0, 0},  {&_swigt__p_FIX__TradeType, _p_FIX__TradeTypeTo_p_FIX__CharField, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CheckSumField[] = {  {&_swigt__p_FIX__CheckSumField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ClearingAccount[] = {  {&_swigt__p_FIX__ClearingAccount, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ClearingFirm[] = {  {&_swigt__p_FIX__ClearingFirm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ClientID[] = {  {&_swigt__p_FIX__ClientID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ConfigError[] = {  {&_swigt__p_FIX__ConfigError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CustomerOrFirm[] = {  {&_swigt__p_FIX__CustomerOrFirm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__CxlType[] = {  {&_swigt__p_FIX__CxlType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DataDictionary[] = {  {&_swigt__p_FIX__DataDictionary, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Dictionary[] = {  {&_swigt__p_FIX__Dictionary, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Dictionary__Data__const_iterator[] = {  {&_swigt__p_FIX__Dictionary__Data__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DiscretionOffset[] = {  {&_swigt__p_FIX__DiscretionOffset, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DlvyInst[] = {  {&_swigt__p_FIX__DlvyInst, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DoNotSend[] = {  {&_swigt__p_FIX__DoNotSend, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DoubleField[] = {  {&_swigt__p_FIX__SpreadToBenchmark, _p_FIX__SpreadToBenchmarkTo_p_FIX__DoubleField, 0, 0},  {&_swigt__p_FIX__RatioQty, _p_FIX__RatioQtyTo_p_FIX__DoubleField, 0, 0},  {&_swigt__p_FIX__DiscretionOffset, _p_FIX__DiscretionOffsetTo_p_FIX__DoubleField, 0, 0},  {&_swigt__p_FIX__DoubleField, 0, 0, 0},  {&_swigt__p_FIX__LastShares, _p_FIX__LastSharesTo_p_FIX__DoubleField, 0, 0},  {&_swigt__p_FIX__Shares, _p_FIX__SharesTo_p_FIX__DoubleField, 0, 0},  {&_swigt__p_FIX__PegDifference, _p_FIX__PegDifferenceTo_p_FIX__DoubleField, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__DuplicateFieldNumber[] = {  {&_swigt__p_FIX__DuplicateFieldNumber, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Exception[] = {  {&_swigt__p_FIX__RequiredTagMissing, _p_FIX__RequiredTagMissingTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__SocketSendFailed, _p_FIX__SocketSendFailedTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__SocketRecvFailed, _p_FIX__SocketRecvFailedTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__InvalidTagNumber, _p_FIX__InvalidTagNumberTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__RejectLogon, _p_FIX__RejectLogonTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__IncorrectDataFormat, _p_FIX__IncorrectDataFormatTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__TagNotDefinedForMessage, _p_FIX__TagNotDefinedForMessageTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__InvalidMessage, _p_FIX__InvalidMessageTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__DoNotSend, _p_FIX__DoNotSendTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__DuplicateFieldNumber, _p_FIX__DuplicateFieldNumberTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__RuntimeError, _p_FIX__RuntimeErrorTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__MessageParseError, _p_FIX__MessageParseErrorTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__FieldNotFound, _p_FIX__FieldNotFoundTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__SessionNotFound, _p_FIX__SessionNotFoundTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__Exception, 0, 0, 0},  {&_swigt__p_FIX__IOException, _p_FIX__IOExceptionTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__SocketException, _p_FIX__SocketExceptionTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__ConfigError, _p_FIX__ConfigErrorTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__InvalidMessageType, _p_FIX__InvalidMessageTypeTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__UnsupportedMessageType, _p_FIX__UnsupportedMessageTypeTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__UnsupportedVersion, _p_FIX__UnsupportedVersionTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__IncorrectTagValue, _p_FIX__IncorrectTagValueTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__NoTagValue, _p_FIX__NoTagValueTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__SocketCloseFailed, _p_FIX__SocketCloseFailedTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__TagOutOfOrder, _p_FIX__TagOutOfOrderTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__RepeatedTag, _p_FIX__RepeatedTagTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__FieldConvertError, _p_FIX__FieldConvertErrorTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__IncorrectMessageStructure, _p_FIX__IncorrectMessageStructureTo_p_FIX__Exception, 0, 0},  {&_swigt__p_FIX__RepeatingGroupCountMismatch, _p_FIX__RepeatingGroupCountMismatchTo_p_FIX__Exception, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ExecBroker[] = {  {&_swigt__p_FIX__ExecBroker, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ExecTransType[] = {  {&_swigt__p_FIX__ExecTransType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FieldBase[] = {  {&_swigt__p_FIX__QuoteAckStatus, _p_FIX__QuoteAckStatusTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__OpenCloseSettleFlag, _p_FIX__OpenCloseSettleFlagTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__DoubleField, _p_FIX__DoubleFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__UtcDateField, _p_FIX__UtcDateFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__TotalVolumeTradedDate, _p_FIX__TotalVolumeTradedDateTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentName, _p_FIX__SecuritySettlAgentNameTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CashSettlAgentName, _p_FIX__CashSettlAgentNameTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CheckSumField, _p_FIX__CheckSumFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__TotalNumSecurityTypes, _p_FIX__TotalNumSecurityTypesTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__IOIShares, _p_FIX__IOISharesTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__AllocShares, _p_FIX__AllocSharesTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__Shares, _p_FIX__SharesTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentContactName, _p_FIX__SecuritySettlAgentContactNameTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentAcctName, _p_FIX__SecuritySettlAgentAcctNameTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CashSettlAgentAcctName, _p_FIX__CashSettlAgentAcctNameTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CashSettlAgentContactName, _p_FIX__CashSettlAgentContactNameTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__FutSettDate2, _p_FIX__FutSettDate2To_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__RelatdSym, _p_FIX__RelatdSymTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__FutSettDate, _p_FIX__FutSettDateTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__LegFutSettDate, _p_FIX__LegFutSettDateTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__PegDifference, _p_FIX__PegDifferenceTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__RegistDetls, _p_FIX__RegistDetlsTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__StringField, _p_FIX__StringFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SettlLocation, _p_FIX__SettlLocationTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__IntField, _p_FIX__IntFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CardIssNo, _p_FIX__CardIssNoTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__ClearingAccount, _p_FIX__ClearingAccountTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__TotQuoteEntries, _p_FIX__TotQuoteEntriesTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__PutOrCall, _p_FIX__PutOrCallTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__UnderlyingPutOrCall, _p_FIX__UnderlyingPutOrCallTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__IOIOthSvc, _p_FIX__IOIOthSvcTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__TotalVolumeTradedTime, _p_FIX__TotalVolumeTradedTimeTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__IDSource, _p_FIX__IDSourceTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__UnderlyingIDSource, _p_FIX__UnderlyingIDSourceTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__DlvyInst, _p_FIX__DlvyInstTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__FieldBase, 0, 0, 0},  {&_swigt__p_FIX__ClearingFirm, _p_FIX__ClearingFirmTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SpreadToBenchmark, _p_FIX__SpreadToBenchmarkTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__Benchmark, _p_FIX__BenchmarkTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SettlDepositoryCode, _p_FIX__SettlDepositoryCodeTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__BoolField, _p_FIX__BoolFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__BrokerOfCredit, _p_FIX__BrokerOfCreditTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__OnBehalfOfSendingTime, _p_FIX__OnBehalfOfSendingTimeTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__OpenClose, _p_FIX__OpenCloseTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__DiscretionOffset, _p_FIX__DiscretionOffsetTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CashSettlAgentContactPhone, _p_FIX__CashSettlAgentContactPhoneTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentContactPhone, _p_FIX__SecuritySettlAgentContactPhoneTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__AvgPrxPrecision, _p_FIX__AvgPrxPrecisionTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__ExecTransType, _p_FIX__ExecTransTypeTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__UtcTimeStampField, _p_FIX__UtcTimeStampFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__RatioQty, _p_FIX__RatioQtyTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SettlBrkrCode, _p_FIX__SettlBrkrCodeTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__ExecBroker, _p_FIX__ExecBrokerTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CustomerOrFirm, _p_FIX__CustomerOrFirmTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CharField, _p_FIX__CharFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__LastShares, _p_FIX__LastSharesTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__TradeType, _p_FIX__TradeTypeTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CashSettlAgentAcctNum, _p_FIX__CashSettlAgentAcctNumTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentAcctNum, _p_FIX__SecuritySettlAgentAcctNumTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__Rule80A, _p_FIX__Rule80ATo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CxlType, _p_FIX__CxlTypeTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__UtcTimeOnlyField, _p_FIX__UtcTimeOnlyFieldTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SettlInstCode, _p_FIX__SettlInstCodeTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentCode, _p_FIX__SecuritySettlAgentCodeTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__CashSettlAgentCode, _p_FIX__CashSettlAgentCodeTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__TotalNumSecurities, _p_FIX__TotalNumSecuritiesTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__UnderlyingMaturityDay, _p_FIX__UnderlyingMaturityDayTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__MaturityDay, _p_FIX__MaturityDayTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__ClientID, _p_FIX__ClientIDTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__SettlmntTyp, _p_FIX__SettlmntTypTo_p_FIX__FieldBase, 0, 0},  {&_swigt__p_FIX__LegSettlmntTyp, _p_FIX__LegSettlmntTypTo_p_FIX__FieldBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FieldConvertError[] = {  {&_swigt__p_FIX__FieldConvertError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FieldMap[] = {  {&_swigt__p_FIX__Group, _p_FIX__GroupTo_p_FIX__FieldMap, 0, 0},  {&_swigt__p_FIX__Message, _p_FIX__MessageTo_p_FIX__FieldMap, 0, 0},  {&_swigt__p_FIX__FieldMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FieldMap__Fields__const_iterator[] = {  {&_swigt__p_FIX__FieldMap__Fields__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FieldMap__Groups__const_iterator[] = {  {&_swigt__p_FIX__FieldMap__Groups__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FieldNotFound[] = {  {&_swigt__p_FIX__FieldNotFound, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FileLog[] = {  {&_swigt__p_FIX__FileLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FileLogFactory[] = {  {&_swigt__p_FIX__FileLogFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FileStore[] = {  {&_swigt__p_FIX__FileStore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FileStoreFactory[] = {  {&_swigt__p_FIX__FileStoreFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FutSettDate[] = {  {&_swigt__p_FIX__FutSettDate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__FutSettDate2[] = {  {&_swigt__p_FIX__FutSettDate2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Group[] = {  {&_swigt__p_FIX__Group, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IDSource[] = {  {&_swigt__p_FIX__IDSource, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IOException[] = {  {&_swigt__p_FIX__IOException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IOIOthSvc[] = {  {&_swigt__p_FIX__IOIOthSvc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IOIShares[] = {  {&_swigt__p_FIX__IOIShares, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IncorrectDataFormat[] = {  {&_swigt__p_FIX__IncorrectDataFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IncorrectMessageStructure[] = {  {&_swigt__p_FIX__IncorrectMessageStructure, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IncorrectTagValue[] = {  {&_swigt__p_FIX__IncorrectTagValue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Initiator[] = {  {&_swigt__p_FIX__Initiator, 0, 0, 0},  {&_swigt__p_FIX__SocketInitiator, _p_FIX__SocketInitiatorTo_p_FIX__Initiator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__IntField[] = {  {&_swigt__p_FIX__CustomerOrFirm, _p_FIX__CustomerOrFirmTo_p_FIX__IntField, 0, 0},  {&_swigt__p_FIX__QuoteAckStatus, _p_FIX__QuoteAckStatusTo_p_FIX__IntField, 0, 0},  {&_swigt__p_FIX__AvgPrxPrecision, _p_FIX__AvgPrxPrecisionTo_p_FIX__IntField, 0, 0},  {&_swigt__p_FIX__AllocShares, _p_FIX__AllocSharesTo_p_FIX__IntField, 0, 0},  {&_swigt__p_FIX__IntField, 0, 0, 0},  {&_swigt__p_FIX__TotQuoteEntries, _p_FIX__TotQuoteEntriesTo_p_FIX__IntField, 0, 0},  {&_swigt__p_FIX__TotalNumSecurityTypes, _p_FIX__TotalNumSecurityTypesTo_p_FIX__IntField, 0, 0},  {&_swigt__p_FIX__PutOrCall, _p_FIX__PutOrCallTo_p_FIX__IntField, 0, 0},  {&_swigt__p_FIX__UnderlyingPutOrCall, _p_FIX__UnderlyingPutOrCallTo_p_FIX__IntField, 0, 0},  {&_swigt__p_FIX__TotalNumSecurities, _p_FIX__TotalNumSecuritiesTo_p_FIX__IntField, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__InvalidMessage[] = {  {&_swigt__p_FIX__InvalidMessage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__InvalidMessageType[] = {  {&_swigt__p_FIX__InvalidMessageType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__InvalidTagNumber[] = {  {&_swigt__p_FIX__InvalidTagNumber, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__LastShares[] = {  {&_swigt__p_FIX__LastShares, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__LegFutSettDate[] = {  {&_swigt__p_FIX__LegFutSettDate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__LegSettlmntTyp[] = {  {&_swigt__p_FIX__LegSettlmntTyp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Log[] = {  {&_swigt__p_FIX__Initiator, _p_FIX__InitiatorTo_p_FIX__Log, 0, 0},  {&_swigt__p_FIX__SocketInitiator, _p_FIX__SocketInitiatorTo_p_FIX__Log, 0, 0},  {&_swigt__p_FIX__Acceptor, _p_FIX__AcceptorTo_p_FIX__Log, 0, 0},  {&_swigt__p_FIX__SocketAcceptor, _p_FIX__SocketAcceptorTo_p_FIX__Log, 0, 0},  {&_swigt__p_FIX__Log, 0, 0, 0},  {&_swigt__p_FIX__FileLog, _p_FIX__FileLogTo_p_FIX__Log, 0, 0},  {&_swigt__p_FIX__ScreenLog, _p_FIX__ScreenLogTo_p_FIX__Log, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__LogFactory[] = {  {&_swigt__p_FIX__LogFactory, 0, 0, 0},  {&_swigt__p_FIX__ScreenLogFactory, _p_FIX__ScreenLogFactoryTo_p_FIX__LogFactory, 0, 0},  {&_swigt__p_FIX__FileLogFactory, _p_FIX__FileLogFactoryTo_p_FIX__LogFactory, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MaturityDay[] = {  {&_swigt__p_FIX__MaturityDay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MemoryStore[] = {  {&_swigt__p_FIX__MemoryStore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MemoryStoreFactory[] = {  {&_swigt__p_FIX__MemoryStoreFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Message[] = {  {&_swigt__p_FIX__Message, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MessageParseError[] = {  {&_swigt__p_FIX__MessageParseError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MessageStore[] = {  {&_swigt__p_FIX__MemoryStore, _p_FIX__MemoryStoreTo_p_FIX__MessageStore, 0, 0},  {&_swigt__p_FIX__MessageStore, 0, 0, 0},  {&_swigt__p_FIX__FileStore, _p_FIX__FileStoreTo_p_FIX__MessageStore, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MessageStoreExceptionWrapper[] = {  {&_swigt__p_FIX__MessageStoreExceptionWrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MessageStoreFactory[] = {  {&_swigt__p_FIX__MessageStoreFactory, 0, 0, 0},  {&_swigt__p_FIX__MemoryStoreFactory, _p_FIX__MemoryStoreFactoryTo_p_FIX__MessageStoreFactory, 0, 0},  {&_swigt__p_FIX__FileStoreFactory, _p_FIX__FileStoreFactoryTo_p_FIX__MessageStoreFactory, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__MessageStoreFactoryExceptionWrapper[] = {  {&_swigt__p_FIX__MessageStoreFactoryExceptionWrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__NoTagValue[] = {  {&_swigt__p_FIX__NoTagValue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__NullApplication[] = {  {&_swigt__p_FIX__NullApplication, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__OnBehalfOfSendingTime[] = {  {&_swigt__p_FIX__OnBehalfOfSendingTime, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__OpenClose[] = {  {&_swigt__p_FIX__OpenClose, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__OpenCloseSettleFlag[] = {  {&_swigt__p_FIX__OpenCloseSettleFlag, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__PegDifference[] = {  {&_swigt__p_FIX__PegDifference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__PutOrCall[] = {  {&_swigt__p_FIX__PutOrCall, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__QuoteAckStatus[] = {  {&_swigt__p_FIX__QuoteAckStatus, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RatioQty[] = {  {&_swigt__p_FIX__RatioQty, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RegistDetls[] = {  {&_swigt__p_FIX__RegistDetls, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RejectLogon[] = {  {&_swigt__p_FIX__RejectLogon, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RelatdSym[] = {  {&_swigt__p_FIX__RelatdSym, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RepeatedTag[] = {  {&_swigt__p_FIX__RepeatedTag, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RepeatingGroupCountMismatch[] = {  {&_swigt__p_FIX__RepeatingGroupCountMismatch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RequiredTagMissing[] = {  {&_swigt__p_FIX__RequiredTagMissing, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Rule80A[] = {  {&_swigt__p_FIX__Rule80A, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__RuntimeError[] = {  {&_swigt__p_FIX__RuntimeError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ScreenLog[] = {  {&_swigt__p_FIX__ScreenLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__ScreenLogFactory[] = {  {&_swigt__p_FIX__ScreenLogFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SecuritySettlAgentAcctName[] = {  {&_swigt__p_FIX__SecuritySettlAgentAcctName, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SecuritySettlAgentAcctNum[] = {  {&_swigt__p_FIX__SecuritySettlAgentAcctNum, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SecuritySettlAgentCode[] = {  {&_swigt__p_FIX__SecuritySettlAgentCode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SecuritySettlAgentContactName[] = {  {&_swigt__p_FIX__SecuritySettlAgentContactName, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SecuritySettlAgentContactPhone[] = {  {&_swigt__p_FIX__SecuritySettlAgentContactPhone, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SecuritySettlAgentName[] = {  {&_swigt__p_FIX__SecuritySettlAgentName, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Session[] = {  {&_swigt__p_FIX__Session, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SessionID[] = {  {&_swigt__p_FIX__SessionID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SessionNotFound[] = {  {&_swigt__p_FIX__SessionNotFound, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SessionSettings[] = {  {&_swigt__p_FIX__SessionSettings, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SettlBrkrCode[] = {  {&_swigt__p_FIX__SettlBrkrCode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SettlDepositoryCode[] = {  {&_swigt__p_FIX__SettlDepositoryCode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SettlInstCode[] = {  {&_swigt__p_FIX__SettlInstCode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SettlLocation[] = {  {&_swigt__p_FIX__SettlLocation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SettlmntTyp[] = {  {&_swigt__p_FIX__SettlmntTyp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__Shares[] = {  {&_swigt__p_FIX__Shares, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketAcceptor[] = {  {&_swigt__p_FIX__SocketAcceptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketCloseFailed[] = {  {&_swigt__p_FIX__SocketCloseFailed, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketException[] = {  {&_swigt__p_FIX__SocketSendFailed, _p_FIX__SocketSendFailedTo_p_FIX__SocketException, 0, 0},  {&_swigt__p_FIX__SocketRecvFailed, _p_FIX__SocketRecvFailedTo_p_FIX__SocketException, 0, 0},  {&_swigt__p_FIX__SocketException, 0, 0, 0},  {&_swigt__p_FIX__SocketCloseFailed, _p_FIX__SocketCloseFailedTo_p_FIX__SocketException, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketInitiator[] = {  {&_swigt__p_FIX__SocketInitiator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketRecvFailed[] = {  {&_swigt__p_FIX__SocketRecvFailed, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SocketSendFailed[] = {  {&_swigt__p_FIX__SocketSendFailed, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SpreadToBenchmark[] = {  {&_swigt__p_FIX__SpreadToBenchmark, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__StringField[] = {  {&_swigt__p_FIX__OpenCloseSettleFlag, _p_FIX__OpenCloseSettleFlagTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentName, _p_FIX__SecuritySettlAgentNameTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__CashSettlAgentName, _p_FIX__CashSettlAgentNameTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__IOIShares, _p_FIX__IOISharesTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__CashSettlAgentContactName, _p_FIX__CashSettlAgentContactNameTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__CashSettlAgentAcctName, _p_FIX__CashSettlAgentAcctNameTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentContactName, _p_FIX__SecuritySettlAgentContactNameTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentAcctName, _p_FIX__SecuritySettlAgentAcctNameTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__FutSettDate2, _p_FIX__FutSettDate2To_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__RelatdSym, _p_FIX__RelatdSymTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__LegFutSettDate, _p_FIX__LegFutSettDateTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__FutSettDate, _p_FIX__FutSettDateTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__RegistDetls, _p_FIX__RegistDetlsTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__StringField, 0, 0, 0},  {&_swigt__p_FIX__SettlLocation, _p_FIX__SettlLocationTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__CardIssNo, _p_FIX__CardIssNoTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__ClearingAccount, _p_FIX__ClearingAccountTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__IDSource, _p_FIX__IDSourceTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__UnderlyingIDSource, _p_FIX__UnderlyingIDSourceTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__ClearingFirm, _p_FIX__ClearingFirmTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__SettlDepositoryCode, _p_FIX__SettlDepositoryCodeTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__BrokerOfCredit, _p_FIX__BrokerOfCreditTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentContactPhone, _p_FIX__SecuritySettlAgentContactPhoneTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__CashSettlAgentContactPhone, _p_FIX__CashSettlAgentContactPhoneTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__SettlBrkrCode, _p_FIX__SettlBrkrCodeTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__ExecBroker, _p_FIX__ExecBrokerTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentAcctNum, _p_FIX__SecuritySettlAgentAcctNumTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__CashSettlAgentAcctNum, _p_FIX__CashSettlAgentAcctNumTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__SettlInstCode, _p_FIX__SettlInstCodeTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__CashSettlAgentCode, _p_FIX__CashSettlAgentCodeTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__SecuritySettlAgentCode, _p_FIX__SecuritySettlAgentCodeTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__MaturityDay, _p_FIX__MaturityDayTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__UnderlyingMaturityDay, _p_FIX__UnderlyingMaturityDayTo_p_FIX__StringField, 0, 0},  {&_swigt__p_FIX__ClientID, _p_FIX__ClientIDTo_p_FIX__StringField, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__SynchronizedApplication[] = {  {&_swigt__p_FIX__SynchronizedApplication, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TagNotDefinedForMessage[] = {  {&_swigt__p_FIX__TagNotDefinedForMessage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TagOutOfOrder[] = {  {&_swigt__p_FIX__TagOutOfOrder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TotQuoteEntries[] = {  {&_swigt__p_FIX__TotQuoteEntries, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TotalNumSecurities[] = {  {&_swigt__p_FIX__TotalNumSecurities, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TotalNumSecurityTypes[] = {  {&_swigt__p_FIX__TotalNumSecurityTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TotalVolumeTradedDate[] = {  {&_swigt__p_FIX__TotalVolumeTradedDate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TotalVolumeTradedTime[] = {  {&_swigt__p_FIX__TotalVolumeTradedTime, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__TradeType[] = {  {&_swigt__p_FIX__TradeType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UnderlyingIDSource[] = {  {&_swigt__p_FIX__UnderlyingIDSource, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UnderlyingMaturityDay[] = {  {&_swigt__p_FIX__UnderlyingMaturityDay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UnderlyingPutOrCall[] = {  {&_swigt__p_FIX__UnderlyingPutOrCall, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UnsupportedMessageType[] = {  {&_swigt__p_FIX__UnsupportedMessageType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UnsupportedVersion[] = {  {&_swigt__p_FIX__UnsupportedVersion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UtcDateField[] = {  {&_swigt__p_FIX__UtcDateField, 0, 0, 0},  {&_swigt__p_FIX__TotalVolumeTradedDate, _p_FIX__TotalVolumeTradedDateTo_p_FIX__UtcDateField, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UtcTimeOnlyField[] = {  {&_swigt__p_FIX__UtcTimeOnlyField, 0, 0, 0},  {&_swigt__p_FIX__TotalVolumeTradedTime, _p_FIX__TotalVolumeTradedTimeTo_p_FIX__UtcTimeOnlyField, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FIX__UtcTimeStampField[] = {  {&_swigt__p_FIX__UtcTimeStampField, 0, 0, 0},  {&_swigt__p_FIX__OnBehalfOfSendingTime, _p_FIX__OnBehalfOfSendingTimeTo_p_FIX__UtcTimeStampField, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Fields[] = {  {&_swigt__p_Fields, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Group[] = {  {&_swigt__p_Group, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Groups[] = {  {&_swigt__p_Groups, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IntArray[] = {  {&_swigt__p_IntArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IntField[] = {  {&_swigt__p_IntField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Log[] = {  {&_swigt__p_Log, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LogFactory[] = {  {&_swigt__p_LogFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MessageStore[] = {  {&_swigt__p_MessageStore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MessageStoreFactory[] = {  {&_swigt__p_MessageStoreFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MsgType[] = {  {&_swigt__p_MsgType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Mutex[] = {  {&_swigt__p_Mutex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Responder[] = {  {&_swigt__p_Responder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SenderCompID[] = {  {&_swigt__p_SenderCompID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SessionID[] = {  {&_swigt__p_SessionID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SessionTime[] = {  {&_swigt__p_SessionTime, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_StringField[] = {  {&_swigt__p_StringField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TYPE__Type[] = {  {&_swigt__p_TYPE__Type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TargetCompID[] = {  {&_swigt__p_TargetCompID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UtcDate[] = {  {&_swigt__p_UtcDate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UtcDateField[] = {  {&_swigt__p_UtcDateField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UtcDateOnly[] = {  {&_swigt__p_UtcDateOnly, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UtcTimeOnly[] = {  {&_swigt__p_UtcTimeOnly, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UtcTimeStamp[] = {  {&_swigt__p_UtcTimeStamp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bool[] = {  {&_swigt__p_bool, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_iterator[] = {  {&_swigt__p_const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_g_const_iterator[] = {  {&_swigt__p_g_const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_g_iterator[] = {  {&_swigt__p_g_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_IntArray, _p_IntArrayTo_p_int, 0, 0},  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_iterator[] = {  {&_swigt__p_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_message_order[] = {  {&_swigt__p_message_order, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_FIX__DataDictionary[] = {  {&_swigt__p_p_FIX__DataDictionary, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__istream[] = {  {&_swigt__p_std__istream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostream[] = {  {&_swigt__p_std__ostream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__setT_FIX__SessionID_t[] = {  {&_swigt__p_std__setT_FIX__SessionID_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string__size_type[] = {  {&_swigt__p_std__string__size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__string_t[] = {  {&_swigt__p_std__vectorT_std__string_t, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Application,
  _swigc__p_BeginString,
  _swigc__p_DOMDocumentPtr,
  _swigc__p_Data,
  _swigc__p_DataDictionary,
  _swigc__p_Dictionaries,
  _swigc__p_DoubleField,
  _swigc__p_FIELD__Field,
  _swigc__p_FIX_CHAR,
  _swigc__p_FIX_DAYOFMONTH,
  _swigc__p_FIX_INT,
  _swigc__p_FIX_LOCALMKTDATE,
  _swigc__p_FIX_PRICEOFFSET,
  _swigc__p_FIX_QTY,
  _swigc__p_FIX_STRING,
  _swigc__p_FIX_UTCDATE,
  _swigc__p_FIX_UTCTIMEONLY,
  _swigc__p_FIX_UTCTIMESTAMP,
  _swigc__p_FIX__Acceptor,
  _swigc__p_FIX__AllocShares,
  _swigc__p_FIX__Application,
  _swigc__p_FIX__AvgPrxPrecision,
  _swigc__p_FIX__Benchmark,
  _swigc__p_FIX__BoolField,
  _swigc__p_FIX__BrokerOfCredit,
  _swigc__p_FIX__CardIssNo,
  _swigc__p_FIX__CashSettlAgentAcctName,
  _swigc__p_FIX__CashSettlAgentAcctNum,
  _swigc__p_FIX__CashSettlAgentCode,
  _swigc__p_FIX__CashSettlAgentContactName,
  _swigc__p_FIX__CashSettlAgentContactPhone,
  _swigc__p_FIX__CashSettlAgentName,
  _swigc__p_FIX__CharField,
  _swigc__p_FIX__CheckSumField,
  _swigc__p_FIX__ClearingAccount,
  _swigc__p_FIX__ClearingFirm,
  _swigc__p_FIX__ClientID,
  _swigc__p_FIX__ConfigError,
  _swigc__p_FIX__CustomerOrFirm,
  _swigc__p_FIX__CxlType,
  _swigc__p_FIX__DataDictionary,
  _swigc__p_FIX__Dictionary,
  _swigc__p_FIX__Dictionary__Data__const_iterator,
  _swigc__p_FIX__DiscretionOffset,
  _swigc__p_FIX__DlvyInst,
  _swigc__p_FIX__DoNotSend,
  _swigc__p_FIX__DoubleField,
  _swigc__p_FIX__DuplicateFieldNumber,
  _swigc__p_FIX__Exception,
  _swigc__p_FIX__ExecBroker,
  _swigc__p_FIX__ExecTransType,
  _swigc__p_FIX__FieldBase,
  _swigc__p_FIX__FieldConvertError,
  _swigc__p_FIX__FieldMap,
  _swigc__p_FIX__FieldMap__Fields__const_iterator,
  _swigc__p_FIX__FieldMap__Groups__const_iterator,
  _swigc__p_FIX__FieldNotFound,
  _swigc__p_FIX__FileLog,
  _swigc__p_FIX__FileLogFactory,
  _swigc__p_FIX__FileStore,
  _swigc__p_FIX__FileStoreFactory,
  _swigc__p_FIX__FutSettDate,
  _swigc__p_FIX__FutSettDate2,
  _swigc__p_FIX__Group,
  _swigc__p_FIX__IDSource,
  _swigc__p_FIX__IOException,
  _swigc__p_FIX__IOIOthSvc,
  _swigc__p_FIX__IOIShares,
  _swigc__p_FIX__IncorrectDataFormat,
  _swigc__p_FIX__IncorrectMessageStructure,
  _swigc__p_FIX__IncorrectTagValue,
  _swigc__p_FIX__Initiator,
  _swigc__p_FIX__IntField,
  _swigc__p_FIX__InvalidMessage,
  _swigc__p_FIX__InvalidMessageType,
  _swigc__p_FIX__InvalidTagNumber,
  _swigc__p_FIX__LastShares,
  _swigc__p_FIX__LegFutSettDate,
  _swigc__p_FIX__LegSettlmntTyp,
  _swigc__p_FIX__Log,
  _swigc__p_FIX__LogFactory,
  _swigc__p_FIX__MaturityDay,
  _swigc__p_FIX__MemoryStore,
  _swigc__p_FIX__MemoryStoreFactory,
  _swigc__p_FIX__Message,
  _swigc__p_FIX__MessageParseError,
  _swigc__p_FIX__MessageStore,
  _swigc__p_FIX__MessageStoreExceptionWrapper,
  _swigc__p_FIX__MessageStoreFactory,
  _swigc__p_FIX__MessageStoreFactoryExceptionWrapper,
  _swigc__p_FIX__NoTagValue,
  _swigc__p_FIX__NullApplication,
  _swigc__p_FIX__OnBehalfOfSendingTime,
  _swigc__p_FIX__OpenClose,
  _swigc__p_FIX__OpenCloseSettleFlag,
  _swigc__p_FIX__PegDifference,
  _swigc__p_FIX__PutOrCall,
  _swigc__p_FIX__QuoteAckStatus,
  _swigc__p_FIX__RatioQty,
  _swigc__p_FIX__RegistDetls,
  _swigc__p_FIX__RejectLogon,
  _swigc__p_FIX__RelatdSym,
  _swigc__p_FIX__RepeatedTag,
  _swigc__p_FIX__RepeatingGroupCountMismatch,
  _swigc__p_FIX__RequiredTagMissing,
  _swigc__p_FIX__Rule80A,
  _swigc__p_FIX__RuntimeError,
  _swigc__p_FIX__ScreenLog,
  _swigc__p_FIX__ScreenLogFactory,
  _swigc__p_FIX__SecuritySettlAgentAcctName,
  _swigc__p_FIX__SecuritySettlAgentAcctNum,
  _swigc__p_FIX__SecuritySettlAgentCode,
  _swigc__p_FIX__SecuritySettlAgentContactName,
  _swigc__p_FIX__SecuritySettlAgentContactPhone,
  _swigc__p_FIX__SecuritySettlAgentName,
  _swigc__p_FIX__Session,
  _swigc__p_FIX__SessionID,
  _swigc__p_FIX__SessionNotFound,
  _swigc__p_FIX__SessionSettings,
  _swigc__p_FIX__SettlBrkrCode,
  _swigc__p_FIX__SettlDepositoryCode,
  _swigc__p_FIX__SettlInstCode,
  _swigc__p_FIX__SettlLocation,
  _swigc__p_FIX__SettlmntTyp,
  _swigc__p_FIX__Shares,
  _swigc__p_FIX__SocketAcceptor,
  _swigc__p_FIX__SocketCloseFailed,
  _swigc__p_FIX__SocketException,
  _swigc__p_FIX__SocketInitiator,
  _swigc__p_FIX__SocketRecvFailed,
  _swigc__p_FIX__SocketSendFailed,
  _swigc__p_FIX__SpreadToBenchmark,
  _swigc__p_FIX__StringField,
  _swigc__p_FIX__SynchronizedApplication,
  _swigc__p_FIX__TagNotDefinedForMessage,
  _swigc__p_FIX__TagOutOfOrder,
  _swigc__p_FIX__TotQuoteEntries,
  _swigc__p_FIX__TotalNumSecurities,
  _swigc__p_FIX__TotalNumSecurityTypes,
  _swigc__p_FIX__TotalVolumeTradedDate,
  _swigc__p_FIX__TotalVolumeTradedTime,
  _swigc__p_FIX__TradeType,
  _swigc__p_FIX__UnderlyingIDSource,
  _swigc__p_FIX__UnderlyingMaturityDay,
  _swigc__p_FIX__UnderlyingPutOrCall,
  _swigc__p_FIX__UnsupportedMessageType,
  _swigc__p_FIX__UnsupportedVersion,
  _swigc__p_FIX__UtcDateField,
  _swigc__p_FIX__UtcTimeOnlyField,
  _swigc__p_FIX__UtcTimeStampField,
  _swigc__p_Fields,
  _swigc__p_Group,
  _swigc__p_Groups,
  _swigc__p_IntArray,
  _swigc__p_IntField,
  _swigc__p_Log,
  _swigc__p_LogFactory,
  _swigc__p_MessageStore,
  _swigc__p_MessageStoreFactory,
  _swigc__p_MsgType,
  _swigc__p_Mutex,
  _swigc__p_Responder,
  _swigc__p_SenderCompID,
  _swigc__p_SessionID,
  _swigc__p_SessionTime,
  _swigc__p_StringField,
  _swigc__p_TYPE__Type,
  _swigc__p_TargetCompID,
  _swigc__p_UtcDate,
  _swigc__p_UtcDateField,
  _swigc__p_UtcDateOnly,
  _swigc__p_UtcTimeOnly,
  _swigc__p_UtcTimeStamp,
  _swigc__p_bool,
  _swigc__p_char,
  _swigc__p_const_iterator,
  _swigc__p_double,
  _swigc__p_g_const_iterator,
  _swigc__p_g_iterator,
  _swigc__p_int,
  _swigc__p_iterator,
  _swigc__p_message_order,
  _swigc__p_p_FIX__DataDictionary,
  _swigc__p_std__istream,
  _swigc__p_std__ostream,
  _swigc__p_std__setT_FIX__SessionID_t,
  _swigc__p_std__string,
  _swigc__p_std__string__size_type,
  _swigc__p_std__vectorT_std__string_t,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpeters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif

/*

*/
#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_quickfix(void) {
  size_t i;
  
  SWIG_InitRuntime();
  mQuickfix = rb_define_module("Quickfix");
  
  SWIG_InitializeModule(0);
  for (i = 0; i < swig_module.size; i++) {
    SWIG_define_class(swig_module.types[i]);
  }
  
  SWIG_RubyInitializeTrackings();
  
  cIntArray.klass = rb_define_class_under(mQuickfix, "IntArray", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_IntArray, (void *) &cIntArray);
  rb_define_alloc_func(cIntArray.klass, _wrap_IntArray_allocate);
  rb_define_method(cIntArray.klass, "initialize", VALUEFUNC(_wrap_new_IntArray), -1);
  rb_define_method(cIntArray.klass, "[]", VALUEFUNC(_wrap_IntArray___getitem__), -1);
  rb_define_method(cIntArray.klass, "[]=", VALUEFUNC(_wrap_IntArray___setitem__), -1);
  rb_define_method(cIntArray.klass, "cast", VALUEFUNC(_wrap_IntArray_cast), -1);
  rb_define_singleton_method(cIntArray.klass, "frompointer", VALUEFUNC(_wrap_IntArray_frompointer), -1);
  cIntArray.mark = 0;
  cIntArray.destroy = (void (*)(void *)) free_IntArray;
  cIntArray.trackObjects = 0;
  
#ifndef _MSC_VER
  struct sigaction new_action, old_action;
  new_action.sa_handler = SIG_DFL;
  sigemptyset( &new_action.sa_mask );
  new_action.sa_flags = 0;
  sigaction( SIGINT, &new_action, &old_action );
#endif
  
  
  cException.klass = rb_define_class_under(mQuickfix, "Exception", rb_eRuntimeError);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Exception, (void *) &cException);
  rb_define_alloc_func(cException.klass, _wrap_Exception_allocate);
  rb_define_method(cException.klass, "initialize", VALUEFUNC(_wrap_new_Exception), -1);
  rb_define_method(cException.klass, "type=", VALUEFUNC(_wrap_Exception_type_set), -1);
  rb_define_method(cException.klass, "type", VALUEFUNC(_wrap_Exception_type_get), -1);
  rb_define_method(cException.klass, "detail=", VALUEFUNC(_wrap_Exception_detail_set), -1);
  rb_define_method(cException.klass, "detail", VALUEFUNC(_wrap_Exception_detail_get), -1);
  rb_define_method(cException.klass, "to_s", VALUEFUNC(_wrap_Exception___str__), -1);
  cException.mark = 0;
  cException.destroy = (void (*)(void *)) free_FIX_Exception;
  cException.trackObjects = 0;
  
  cFieldNotFound.klass = rb_define_class_under(mQuickfix, "FieldNotFound", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FieldNotFound, (void *) &cFieldNotFound);
  rb_define_alloc_func(cFieldNotFound.klass, _wrap_FieldNotFound_allocate);
  rb_define_method(cFieldNotFound.klass, "initialize", VALUEFUNC(_wrap_new_FieldNotFound), -1);
  rb_define_method(cFieldNotFound.klass, "field=", VALUEFUNC(_wrap_FieldNotFound_field_set), -1);
  rb_define_method(cFieldNotFound.klass, "field", VALUEFUNC(_wrap_FieldNotFound_field_get), -1);
  cFieldNotFound.mark = 0;
  cFieldNotFound.destroy = (void (*)(void *)) free_FIX_FieldNotFound;
  cFieldNotFound.trackObjects = 0;
  
  cFieldConvertError.klass = rb_define_class_under(mQuickfix, "FieldConvertError", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FieldConvertError, (void *) &cFieldConvertError);
  rb_define_alloc_func(cFieldConvertError.klass, _wrap_FieldConvertError_allocate);
  rb_define_method(cFieldConvertError.klass, "initialize", VALUEFUNC(_wrap_new_FieldConvertError), -1);
  cFieldConvertError.mark = 0;
  cFieldConvertError.destroy = (void (*)(void *)) free_FIX_FieldConvertError;
  cFieldConvertError.trackObjects = 0;
  
  cMessageParseError.klass = rb_define_class_under(mQuickfix, "MessageParseError", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MessageParseError, (void *) &cMessageParseError);
  rb_define_alloc_func(cMessageParseError.klass, _wrap_MessageParseError_allocate);
  rb_define_method(cMessageParseError.klass, "initialize", VALUEFUNC(_wrap_new_MessageParseError), -1);
  cMessageParseError.mark = 0;
  cMessageParseError.destroy = (void (*)(void *)) free_FIX_MessageParseError;
  cMessageParseError.trackObjects = 0;
  
  cInvalidMessage.klass = rb_define_class_under(mQuickfix, "InvalidMessage", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__InvalidMessage, (void *) &cInvalidMessage);
  rb_define_alloc_func(cInvalidMessage.klass, _wrap_InvalidMessage_allocate);
  rb_define_method(cInvalidMessage.klass, "initialize", VALUEFUNC(_wrap_new_InvalidMessage), -1);
  cInvalidMessage.mark = 0;
  cInvalidMessage.destroy = (void (*)(void *)) free_FIX_InvalidMessage;
  cInvalidMessage.trackObjects = 0;
  
  cConfigError.klass = rb_define_class_under(mQuickfix, "ConfigError", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ConfigError, (void *) &cConfigError);
  rb_define_alloc_func(cConfigError.klass, _wrap_ConfigError_allocate);
  rb_define_method(cConfigError.klass, "initialize", VALUEFUNC(_wrap_new_ConfigError), -1);
  cConfigError.mark = 0;
  cConfigError.destroy = (void (*)(void *)) free_FIX_ConfigError;
  cConfigError.trackObjects = 0;
  
  cRuntimeError.klass = rb_define_class_under(mQuickfix, "RuntimeError", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RuntimeError, (void *) &cRuntimeError);
  rb_define_alloc_func(cRuntimeError.klass, _wrap_RuntimeError_allocate);
  rb_define_method(cRuntimeError.klass, "initialize", VALUEFUNC(_wrap_new_RuntimeError), -1);
  cRuntimeError.mark = 0;
  cRuntimeError.destroy = (void (*)(void *)) free_FIX_RuntimeError;
  cRuntimeError.trackObjects = 0;
  
  cInvalidTagNumber.klass = rb_define_class_under(mQuickfix, "InvalidTagNumber", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__InvalidTagNumber, (void *) &cInvalidTagNumber);
  rb_define_alloc_func(cInvalidTagNumber.klass, _wrap_InvalidTagNumber_allocate);
  rb_define_method(cInvalidTagNumber.klass, "initialize", VALUEFUNC(_wrap_new_InvalidTagNumber), -1);
  rb_define_method(cInvalidTagNumber.klass, "field=", VALUEFUNC(_wrap_InvalidTagNumber_field_set), -1);
  rb_define_method(cInvalidTagNumber.klass, "field", VALUEFUNC(_wrap_InvalidTagNumber_field_get), -1);
  cInvalidTagNumber.mark = 0;
  cInvalidTagNumber.destroy = (void (*)(void *)) free_FIX_InvalidTagNumber;
  cInvalidTagNumber.trackObjects = 0;
  
  cRequiredTagMissing.klass = rb_define_class_under(mQuickfix, "RequiredTagMissing", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RequiredTagMissing, (void *) &cRequiredTagMissing);
  rb_define_alloc_func(cRequiredTagMissing.klass, _wrap_RequiredTagMissing_allocate);
  rb_define_method(cRequiredTagMissing.klass, "initialize", VALUEFUNC(_wrap_new_RequiredTagMissing), -1);
  rb_define_method(cRequiredTagMissing.klass, "field=", VALUEFUNC(_wrap_RequiredTagMissing_field_set), -1);
  rb_define_method(cRequiredTagMissing.klass, "field", VALUEFUNC(_wrap_RequiredTagMissing_field_get), -1);
  cRequiredTagMissing.mark = 0;
  cRequiredTagMissing.destroy = (void (*)(void *)) free_FIX_RequiredTagMissing;
  cRequiredTagMissing.trackObjects = 0;
  
  cTagNotDefinedForMessage.klass = rb_define_class_under(mQuickfix, "TagNotDefinedForMessage", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TagNotDefinedForMessage, (void *) &cTagNotDefinedForMessage);
  rb_define_alloc_func(cTagNotDefinedForMessage.klass, _wrap_TagNotDefinedForMessage_allocate);
  rb_define_method(cTagNotDefinedForMessage.klass, "initialize", VALUEFUNC(_wrap_new_TagNotDefinedForMessage), -1);
  rb_define_method(cTagNotDefinedForMessage.klass, "field=", VALUEFUNC(_wrap_TagNotDefinedForMessage_field_set), -1);
  rb_define_method(cTagNotDefinedForMessage.klass, "field", VALUEFUNC(_wrap_TagNotDefinedForMessage_field_get), -1);
  cTagNotDefinedForMessage.mark = 0;
  cTagNotDefinedForMessage.destroy = (void (*)(void *)) free_FIX_TagNotDefinedForMessage;
  cTagNotDefinedForMessage.trackObjects = 0;
  
  cNoTagValue.klass = rb_define_class_under(mQuickfix, "NoTagValue", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__NoTagValue, (void *) &cNoTagValue);
  rb_define_alloc_func(cNoTagValue.klass, _wrap_NoTagValue_allocate);
  rb_define_method(cNoTagValue.klass, "initialize", VALUEFUNC(_wrap_new_NoTagValue), -1);
  rb_define_method(cNoTagValue.klass, "field=", VALUEFUNC(_wrap_NoTagValue_field_set), -1);
  rb_define_method(cNoTagValue.klass, "field", VALUEFUNC(_wrap_NoTagValue_field_get), -1);
  cNoTagValue.mark = 0;
  cNoTagValue.destroy = (void (*)(void *)) free_FIX_NoTagValue;
  cNoTagValue.trackObjects = 0;
  
  cIncorrectTagValue.klass = rb_define_class_under(mQuickfix, "IncorrectTagValue", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IncorrectTagValue, (void *) &cIncorrectTagValue);
  rb_define_alloc_func(cIncorrectTagValue.klass, _wrap_IncorrectTagValue_allocate);
  rb_define_method(cIncorrectTagValue.klass, "initialize", VALUEFUNC(_wrap_new_IncorrectTagValue), -1);
  rb_define_method(cIncorrectTagValue.klass, "field=", VALUEFUNC(_wrap_IncorrectTagValue_field_set), -1);
  rb_define_method(cIncorrectTagValue.klass, "field", VALUEFUNC(_wrap_IncorrectTagValue_field_get), -1);
  cIncorrectTagValue.mark = 0;
  cIncorrectTagValue.destroy = (void (*)(void *)) free_FIX_IncorrectTagValue;
  cIncorrectTagValue.trackObjects = 0;
  
  cIncorrectDataFormat.klass = rb_define_class_under(mQuickfix, "IncorrectDataFormat", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IncorrectDataFormat, (void *) &cIncorrectDataFormat);
  rb_define_alloc_func(cIncorrectDataFormat.klass, _wrap_IncorrectDataFormat_allocate);
  rb_define_method(cIncorrectDataFormat.klass, "initialize", VALUEFUNC(_wrap_new_IncorrectDataFormat), -1);
  rb_define_method(cIncorrectDataFormat.klass, "field=", VALUEFUNC(_wrap_IncorrectDataFormat_field_set), -1);
  rb_define_method(cIncorrectDataFormat.klass, "field", VALUEFUNC(_wrap_IncorrectDataFormat_field_get), -1);
  cIncorrectDataFormat.mark = 0;
  cIncorrectDataFormat.destroy = (void (*)(void *)) free_FIX_IncorrectDataFormat;
  cIncorrectDataFormat.trackObjects = 0;
  
  cIncorrectMessageStructure.klass = rb_define_class_under(mQuickfix, "IncorrectMessageStructure", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IncorrectMessageStructure, (void *) &cIncorrectMessageStructure);
  rb_define_alloc_func(cIncorrectMessageStructure.klass, _wrap_IncorrectMessageStructure_allocate);
  rb_define_method(cIncorrectMessageStructure.klass, "initialize", VALUEFUNC(_wrap_new_IncorrectMessageStructure), -1);
  cIncorrectMessageStructure.mark = 0;
  cIncorrectMessageStructure.destroy = (void (*)(void *)) free_FIX_IncorrectMessageStructure;
  cIncorrectMessageStructure.trackObjects = 0;
  
  cDuplicateFieldNumber.klass = rb_define_class_under(mQuickfix, "DuplicateFieldNumber", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DuplicateFieldNumber, (void *) &cDuplicateFieldNumber);
  rb_define_alloc_func(cDuplicateFieldNumber.klass, _wrap_DuplicateFieldNumber_allocate);
  rb_define_method(cDuplicateFieldNumber.klass, "initialize", VALUEFUNC(_wrap_new_DuplicateFieldNumber), -1);
  cDuplicateFieldNumber.mark = 0;
  cDuplicateFieldNumber.destroy = (void (*)(void *)) free_FIX_DuplicateFieldNumber;
  cDuplicateFieldNumber.trackObjects = 0;
  
  cInvalidMessageType.klass = rb_define_class_under(mQuickfix, "InvalidMessageType", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__InvalidMessageType, (void *) &cInvalidMessageType);
  rb_define_alloc_func(cInvalidMessageType.klass, _wrap_InvalidMessageType_allocate);
  rb_define_method(cInvalidMessageType.klass, "initialize", VALUEFUNC(_wrap_new_InvalidMessageType), -1);
  cInvalidMessageType.mark = 0;
  cInvalidMessageType.destroy = (void (*)(void *)) free_FIX_InvalidMessageType;
  cInvalidMessageType.trackObjects = 0;
  
  cUnsupportedMessageType.klass = rb_define_class_under(mQuickfix, "UnsupportedMessageType", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UnsupportedMessageType, (void *) &cUnsupportedMessageType);
  rb_define_alloc_func(cUnsupportedMessageType.klass, _wrap_UnsupportedMessageType_allocate);
  rb_define_method(cUnsupportedMessageType.klass, "initialize", VALUEFUNC(_wrap_new_UnsupportedMessageType), -1);
  cUnsupportedMessageType.mark = 0;
  cUnsupportedMessageType.destroy = (void (*)(void *)) free_FIX_UnsupportedMessageType;
  cUnsupportedMessageType.trackObjects = 0;
  
  cUnsupportedVersion.klass = rb_define_class_under(mQuickfix, "UnsupportedVersion", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UnsupportedVersion, (void *) &cUnsupportedVersion);
  rb_define_alloc_func(cUnsupportedVersion.klass, _wrap_UnsupportedVersion_allocate);
  rb_define_method(cUnsupportedVersion.klass, "initialize", VALUEFUNC(_wrap_new_UnsupportedVersion), -1);
  cUnsupportedVersion.mark = 0;
  cUnsupportedVersion.destroy = (void (*)(void *)) free_FIX_UnsupportedVersion;
  cUnsupportedVersion.trackObjects = 0;
  
  cTagOutOfOrder.klass = rb_define_class_under(mQuickfix, "TagOutOfOrder", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TagOutOfOrder, (void *) &cTagOutOfOrder);
  rb_define_alloc_func(cTagOutOfOrder.klass, _wrap_TagOutOfOrder_allocate);
  rb_define_method(cTagOutOfOrder.klass, "initialize", VALUEFUNC(_wrap_new_TagOutOfOrder), -1);
  rb_define_method(cTagOutOfOrder.klass, "field=", VALUEFUNC(_wrap_TagOutOfOrder_field_set), -1);
  rb_define_method(cTagOutOfOrder.klass, "field", VALUEFUNC(_wrap_TagOutOfOrder_field_get), -1);
  cTagOutOfOrder.mark = 0;
  cTagOutOfOrder.destroy = (void (*)(void *)) free_FIX_TagOutOfOrder;
  cTagOutOfOrder.trackObjects = 0;
  
  cRepeatedTag.klass = rb_define_class_under(mQuickfix, "RepeatedTag", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RepeatedTag, (void *) &cRepeatedTag);
  rb_define_alloc_func(cRepeatedTag.klass, _wrap_RepeatedTag_allocate);
  rb_define_method(cRepeatedTag.klass, "initialize", VALUEFUNC(_wrap_new_RepeatedTag), -1);
  rb_define_method(cRepeatedTag.klass, "field=", VALUEFUNC(_wrap_RepeatedTag_field_set), -1);
  rb_define_method(cRepeatedTag.klass, "field", VALUEFUNC(_wrap_RepeatedTag_field_get), -1);
  cRepeatedTag.mark = 0;
  cRepeatedTag.destroy = (void (*)(void *)) free_FIX_RepeatedTag;
  cRepeatedTag.trackObjects = 0;
  
  cRepeatingGroupCountMismatch.klass = rb_define_class_under(mQuickfix, "RepeatingGroupCountMismatch", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RepeatingGroupCountMismatch, (void *) &cRepeatingGroupCountMismatch);
  rb_define_alloc_func(cRepeatingGroupCountMismatch.klass, _wrap_RepeatingGroupCountMismatch_allocate);
  rb_define_method(cRepeatingGroupCountMismatch.klass, "initialize", VALUEFUNC(_wrap_new_RepeatingGroupCountMismatch), -1);
  rb_define_method(cRepeatingGroupCountMismatch.klass, "field=", VALUEFUNC(_wrap_RepeatingGroupCountMismatch_field_set), -1);
  rb_define_method(cRepeatingGroupCountMismatch.klass, "field", VALUEFUNC(_wrap_RepeatingGroupCountMismatch_field_get), -1);
  cRepeatingGroupCountMismatch.mark = 0;
  cRepeatingGroupCountMismatch.destroy = (void (*)(void *)) free_FIX_RepeatingGroupCountMismatch;
  cRepeatingGroupCountMismatch.trackObjects = 0;
  
  cDoNotSend.klass = rb_define_class_under(mQuickfix, "DoNotSend", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DoNotSend, (void *) &cDoNotSend);
  rb_define_alloc_func(cDoNotSend.klass, _wrap_DoNotSend_allocate);
  rb_define_method(cDoNotSend.klass, "initialize", VALUEFUNC(_wrap_new_DoNotSend), -1);
  cDoNotSend.mark = 0;
  cDoNotSend.destroy = (void (*)(void *)) free_FIX_DoNotSend;
  cDoNotSend.trackObjects = 0;
  
  cRejectLogon.klass = rb_define_class_under(mQuickfix, "RejectLogon", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RejectLogon, (void *) &cRejectLogon);
  rb_define_alloc_func(cRejectLogon.klass, _wrap_RejectLogon_allocate);
  rb_define_method(cRejectLogon.klass, "initialize", VALUEFUNC(_wrap_new_RejectLogon), -1);
  cRejectLogon.mark = 0;
  cRejectLogon.destroy = (void (*)(void *)) free_FIX_RejectLogon;
  cRejectLogon.trackObjects = 0;
  
  cSessionNotFound.klass = rb_define_class_under(mQuickfix, "SessionNotFound", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SessionNotFound, (void *) &cSessionNotFound);
  rb_define_alloc_func(cSessionNotFound.klass, _wrap_SessionNotFound_allocate);
  rb_define_method(cSessionNotFound.klass, "initialize", VALUEFUNC(_wrap_new_SessionNotFound), -1);
  cSessionNotFound.mark = 0;
  cSessionNotFound.destroy = (void (*)(void *)) free_FIX_SessionNotFound;
  cSessionNotFound.trackObjects = 0;
  
  cIOException.klass = rb_define_class_under(mQuickfix, "IOException", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IOException, (void *) &cIOException);
  rb_define_alloc_func(cIOException.klass, _wrap_IOException_allocate);
  rb_define_method(cIOException.klass, "initialize", VALUEFUNC(_wrap_new_IOException), -1);
  cIOException.mark = 0;
  cIOException.destroy = (void (*)(void *)) free_FIX_IOException;
  cIOException.trackObjects = 0;
  
  cSocketException.klass = rb_define_class_under(mQuickfix, "SocketException", ((swig_class *) SWIGTYPE_p_FIX__Exception->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketException, (void *) &cSocketException);
  rb_define_alloc_func(cSocketException.klass, _wrap_SocketException_allocate);
  rb_define_method(cSocketException.klass, "initialize", VALUEFUNC(_wrap_new_SocketException), -1);
  rb_define_method(cSocketException.klass, "errorToWhat", VALUEFUNC(_wrap_SocketException_errorToWhat), -1);
  rb_define_method(cSocketException.klass, "error=", VALUEFUNC(_wrap_SocketException_error_set), -1);
  rb_define_method(cSocketException.klass, "error", VALUEFUNC(_wrap_SocketException_error_get), -1);
  cSocketException.mark = 0;
  cSocketException.destroy = (void (*)(void *)) free_FIX_SocketException;
  cSocketException.trackObjects = 0;
  
  cSocketSendFailed.klass = rb_define_class_under(mQuickfix, "SocketSendFailed", ((swig_class *) SWIGTYPE_p_FIX__SocketException->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketSendFailed, (void *) &cSocketSendFailed);
  rb_define_alloc_func(cSocketSendFailed.klass, _wrap_SocketSendFailed_allocate);
  rb_define_method(cSocketSendFailed.klass, "initialize", VALUEFUNC(_wrap_new_SocketSendFailed), -1);
  cSocketSendFailed.mark = 0;
  cSocketSendFailed.destroy = (void (*)(void *)) free_FIX_SocketSendFailed;
  cSocketSendFailed.trackObjects = 0;
  
  cSocketRecvFailed.klass = rb_define_class_under(mQuickfix, "SocketRecvFailed", ((swig_class *) SWIGTYPE_p_FIX__SocketException->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketRecvFailed, (void *) &cSocketRecvFailed);
  rb_define_alloc_func(cSocketRecvFailed.klass, _wrap_SocketRecvFailed_allocate);
  rb_define_method(cSocketRecvFailed.klass, "initialize", VALUEFUNC(_wrap_new_SocketRecvFailed), -1);
  cSocketRecvFailed.mark = 0;
  cSocketRecvFailed.destroy = (void (*)(void *)) free_FIX_SocketRecvFailed;
  cSocketRecvFailed.trackObjects = 0;
  
  cSocketCloseFailed.klass = rb_define_class_under(mQuickfix, "SocketCloseFailed", ((swig_class *) SWIGTYPE_p_FIX__SocketException->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketCloseFailed, (void *) &cSocketCloseFailed);
  rb_define_alloc_func(cSocketCloseFailed.klass, _wrap_SocketCloseFailed_allocate);
  rb_define_method(cSocketCloseFailed.klass, "initialize", VALUEFUNC(_wrap_new_SocketCloseFailed), -1);
  cSocketCloseFailed.mark = 0;
  cSocketCloseFailed.destroy = (void (*)(void *)) free_FIX_SocketCloseFailed;
  cSocketCloseFailed.trackObjects = 0;
  
  cFieldBase.klass = rb_define_class_under(mQuickfix, "FieldBase", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FieldBase, (void *) &cFieldBase);
  rb_define_alloc_func(cFieldBase.klass, _wrap_FieldBase_allocate);
  rb_define_method(cFieldBase.klass, "initialize", VALUEFUNC(_wrap_new_FieldBase), -1);
  rb_define_method(cFieldBase.klass, "setField", VALUEFUNC(_wrap_FieldBase_setField), -1);
  rb_define_method(cFieldBase.klass, "setString", VALUEFUNC(_wrap_FieldBase_setString), -1);
  rb_define_method(cFieldBase.klass, "getField", VALUEFUNC(_wrap_FieldBase_getField), -1);
  rb_define_method(cFieldBase.klass, "getString", VALUEFUNC(_wrap_FieldBase_getString), -1);
  rb_define_method(cFieldBase.klass, "getValue", VALUEFUNC(_wrap_FieldBase_getValue), -1);
  rb_define_method(cFieldBase.klass, "getLength", VALUEFUNC(_wrap_FieldBase_getLength), -1);
  rb_define_method(cFieldBase.klass, "getTotal", VALUEFUNC(_wrap_FieldBase_getTotal), -1);
  rb_define_method(cFieldBase.klass, "<", VALUEFUNC(_wrap_FieldBase___lt__), -1);
  rb_define_method(cFieldBase.klass, "to_s", VALUEFUNC(_wrap_FieldBase___str__), -1);
  cFieldBase.mark = 0;
  cFieldBase.destroy = (void (*)(void *)) free_FIX_FieldBase;
  cFieldBase.trackObjects = 0;
  
  cStringField.klass = rb_define_class_under(mQuickfix, "StringField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__StringField, (void *) &cStringField);
  rb_define_alloc_func(cStringField.klass, _wrap_StringField_allocate);
  rb_define_method(cStringField.klass, "initialize", VALUEFUNC(_wrap_new_StringField), -1);
  rb_define_method(cStringField.klass, "setValue", VALUEFUNC(_wrap_StringField_setValue), -1);
  rb_define_method(cStringField.klass, "getValue", VALUEFUNC(_wrap_StringField_getValue), -1);
  rb_define_method(cStringField.klass, "<", VALUEFUNC(_wrap_StringField___lt__), -1);
  rb_define_method(cStringField.klass, ">", VALUEFUNC(_wrap_StringField___gt__), -1);
  rb_define_method(cStringField.klass, "==", VALUEFUNC(_wrap_StringField___eq__), -1);
  rb_define_method(cStringField.klass, "<=", VALUEFUNC(_wrap_StringField___le__), -1);
  rb_define_method(cStringField.klass, ">=", VALUEFUNC(_wrap_StringField___ge__), -1);
  cStringField.mark = 0;
  cStringField.destroy = (void (*)(void *)) free_FIX_StringField;
  cStringField.trackObjects = 0;
  rb_define_module_function(mQuickfix, ">", VALUEFUNC(_wrap___gt__), -1);
  rb_define_module_function(mQuickfix, "<=", VALUEFUNC(_wrap___le__), -1);
  rb_define_module_function(mQuickfix, ">=", VALUEFUNC(_wrap___ge__), -1);
  
  cCharField.klass = rb_define_class_under(mQuickfix, "CharField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CharField, (void *) &cCharField);
  rb_define_alloc_func(cCharField.klass, _wrap_CharField_allocate);
  rb_define_method(cCharField.klass, "initialize", VALUEFUNC(_wrap_new_CharField), -1);
  rb_define_method(cCharField.klass, "setValue", VALUEFUNC(_wrap_CharField_setValue), -1);
  rb_define_method(cCharField.klass, "getValue", VALUEFUNC(_wrap_CharField_getValue), -1);
  cCharField.mark = 0;
  cCharField.destroy = (void (*)(void *)) free_FIX_CharField;
  cCharField.trackObjects = 0;
  
  cDoubleField.klass = rb_define_class_under(mQuickfix, "DoubleField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DoubleField, (void *) &cDoubleField);
  rb_define_alloc_func(cDoubleField.klass, _wrap_DoubleField_allocate);
  rb_define_method(cDoubleField.klass, "initialize", VALUEFUNC(_wrap_new_DoubleField), -1);
  rb_define_method(cDoubleField.klass, "setValue", VALUEFUNC(_wrap_DoubleField_setValue), -1);
  rb_define_method(cDoubleField.klass, "getValue", VALUEFUNC(_wrap_DoubleField_getValue), -1);
  cDoubleField.mark = 0;
  cDoubleField.destroy = (void (*)(void *)) free_FIX_DoubleField;
  cDoubleField.trackObjects = 0;
  
  cIntField.klass = rb_define_class_under(mQuickfix, "IntField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IntField, (void *) &cIntField);
  rb_define_alloc_func(cIntField.klass, _wrap_IntField_allocate);
  rb_define_method(cIntField.klass, "initialize", VALUEFUNC(_wrap_new_IntField), -1);
  rb_define_method(cIntField.klass, "setValue", VALUEFUNC(_wrap_IntField_setValue), -1);
  rb_define_method(cIntField.klass, "getValue", VALUEFUNC(_wrap_IntField_getValue), -1);
  cIntField.mark = 0;
  cIntField.destroy = (void (*)(void *)) free_FIX_IntField;
  cIntField.trackObjects = 0;
  
  cBoolField.klass = rb_define_class_under(mQuickfix, "BoolField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__BoolField, (void *) &cBoolField);
  rb_define_alloc_func(cBoolField.klass, _wrap_BoolField_allocate);
  rb_define_method(cBoolField.klass, "initialize", VALUEFUNC(_wrap_new_BoolField), -1);
  rb_define_method(cBoolField.klass, "setValue", VALUEFUNC(_wrap_BoolField_setValue), -1);
  rb_define_method(cBoolField.klass, "getValue", VALUEFUNC(_wrap_BoolField_getValue), -1);
  cBoolField.mark = 0;
  cBoolField.destroy = (void (*)(void *)) free_FIX_BoolField;
  cBoolField.trackObjects = 0;
  
  cUtcTimeStampField.klass = rb_define_class_under(mQuickfix, "UtcTimeStampField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UtcTimeStampField, (void *) &cUtcTimeStampField);
  rb_define_alloc_func(cUtcTimeStampField.klass, _wrap_UtcTimeStampField_allocate);
  rb_define_method(cUtcTimeStampField.klass, "initialize", VALUEFUNC(_wrap_new_UtcTimeStampField), -1);
  rb_define_method(cUtcTimeStampField.klass, "setValue", VALUEFUNC(_wrap_UtcTimeStampField_setValue), -1);
  rb_define_method(cUtcTimeStampField.klass, "getValue", VALUEFUNC(_wrap_UtcTimeStampField_getValue), -1);
  rb_define_method(cUtcTimeStampField.klass, "<", VALUEFUNC(_wrap_UtcTimeStampField___lt__), -1);
  rb_define_method(cUtcTimeStampField.klass, "==", VALUEFUNC(_wrap_UtcTimeStampField___eq__), -1);
  cUtcTimeStampField.mark = 0;
  cUtcTimeStampField.destroy = (void (*)(void *)) free_FIX_UtcTimeStampField;
  cUtcTimeStampField.trackObjects = 0;
  
  cUtcDateField.klass = rb_define_class_under(mQuickfix, "UtcDateField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UtcDateField, (void *) &cUtcDateField);
  rb_define_alloc_func(cUtcDateField.klass, _wrap_UtcDateField_allocate);
  rb_define_method(cUtcDateField.klass, "initialize", VALUEFUNC(_wrap_new_UtcDateField), -1);
  rb_define_method(cUtcDateField.klass, "setValue", VALUEFUNC(_wrap_UtcDateField_setValue), -1);
  rb_define_method(cUtcDateField.klass, "getValue", VALUEFUNC(_wrap_UtcDateField_getValue), -1);
  rb_define_method(cUtcDateField.klass, "<", VALUEFUNC(_wrap_UtcDateField___lt__), -1);
  rb_define_method(cUtcDateField.klass, "==", VALUEFUNC(_wrap_UtcDateField___eq__), -1);
  cUtcDateField.mark = 0;
  cUtcDateField.destroy = (void (*)(void *)) free_FIX_UtcDateField;
  cUtcDateField.trackObjects = 0;
  
  cUtcTimeOnlyField.klass = rb_define_class_under(mQuickfix, "UtcTimeOnlyField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UtcTimeOnlyField, (void *) &cUtcTimeOnlyField);
  rb_define_alloc_func(cUtcTimeOnlyField.klass, _wrap_UtcTimeOnlyField_allocate);
  rb_define_method(cUtcTimeOnlyField.klass, "initialize", VALUEFUNC(_wrap_new_UtcTimeOnlyField), -1);
  rb_define_method(cUtcTimeOnlyField.klass, "setValue", VALUEFUNC(_wrap_UtcTimeOnlyField_setValue), -1);
  rb_define_method(cUtcTimeOnlyField.klass, "getValue", VALUEFUNC(_wrap_UtcTimeOnlyField_getValue), -1);
  rb_define_method(cUtcTimeOnlyField.klass, "<", VALUEFUNC(_wrap_UtcTimeOnlyField___lt__), -1);
  rb_define_method(cUtcTimeOnlyField.klass, "==", VALUEFUNC(_wrap_UtcTimeOnlyField___eq__), -1);
  cUtcTimeOnlyField.mark = 0;
  cUtcTimeOnlyField.destroy = (void (*)(void *)) free_FIX_UtcTimeOnlyField;
  cUtcTimeOnlyField.trackObjects = 0;
  
  cCheckSumField.klass = rb_define_class_under(mQuickfix, "CheckSumField", ((swig_class *) SWIGTYPE_p_FIX__FieldBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CheckSumField, (void *) &cCheckSumField);
  rb_define_alloc_func(cCheckSumField.klass, _wrap_CheckSumField_allocate);
  rb_define_method(cCheckSumField.klass, "initialize", VALUEFUNC(_wrap_new_CheckSumField), -1);
  rb_define_method(cCheckSumField.klass, "setValue", VALUEFUNC(_wrap_CheckSumField_setValue), -1);
  rb_define_method(cCheckSumField.klass, "getValue", VALUEFUNC(_wrap_CheckSumField_getValue), -1);
  cCheckSumField.mark = 0;
  cCheckSumField.destroy = (void (*)(void *)) free_FIX_CheckSumField;
  cCheckSumField.trackObjects = 0;
  
  cFieldMap.klass = rb_define_class_under(mQuickfix, "FieldMap", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FieldMap, (void *) &cFieldMap);
  rb_define_alloc_func(cFieldMap.klass, _wrap_FieldMap_allocate);
  rb_define_method(cFieldMap.klass, "initialize", VALUEFUNC(_wrap_new_FieldMap), -1);
  rb_define_method(cFieldMap.klass, "setField", VALUEFUNC(_wrap_FieldMap_setField), -1);
  rb_define_method(cFieldMap.klass, "getField", VALUEFUNC(_wrap_FieldMap_getField), -1);
  rb_define_method(cFieldMap.klass, "getFieldRef", VALUEFUNC(_wrap_FieldMap_getFieldRef), -1);
  rb_define_method(cFieldMap.klass, "getFieldPtr", VALUEFUNC(_wrap_FieldMap_getFieldPtr), -1);
  rb_define_method(cFieldMap.klass, "isSetField", VALUEFUNC(_wrap_FieldMap_isSetField), -1);
  rb_define_method(cFieldMap.klass, "removeField", VALUEFUNC(_wrap_FieldMap_removeField), -1);
  rb_define_method(cFieldMap.klass, "addGroup", VALUEFUNC(_wrap_FieldMap_addGroup), -1);
  rb_define_method(cFieldMap.klass, "replaceGroup", VALUEFUNC(_wrap_FieldMap_replaceGroup), -1);
  rb_define_method(cFieldMap.klass, "getGroup", VALUEFUNC(_wrap_FieldMap_getGroup), -1);
  rb_define_method(cFieldMap.klass, "removeGroup", VALUEFUNC(_wrap_FieldMap_removeGroup), -1);
  rb_define_method(cFieldMap.klass, "hasGroup", VALUEFUNC(_wrap_FieldMap_hasGroup), -1);
  rb_define_method(cFieldMap.klass, "groupCount", VALUEFUNC(_wrap_FieldMap_groupCount), -1);
  rb_define_method(cFieldMap.klass, "clear", VALUEFUNC(_wrap_FieldMap_clear), -1);
  rb_define_method(cFieldMap.klass, "isEmpty", VALUEFUNC(_wrap_FieldMap_isEmpty), -1);
  rb_define_method(cFieldMap.klass, "totalFields", VALUEFUNC(_wrap_FieldMap_totalFields), -1);
  rb_define_method(cFieldMap.klass, "calculateString", VALUEFUNC(_wrap_FieldMap_calculateString), -1);
  rb_define_method(cFieldMap.klass, "calculateLength", VALUEFUNC(_wrap_FieldMap_calculateLength), -1);
  rb_define_method(cFieldMap.klass, "calculateTotal", VALUEFUNC(_wrap_FieldMap_calculateTotal), -1);
  rb_define_method(cFieldMap.klass, "begin", VALUEFUNC(_wrap_FieldMap_begin), -1);
  rb_define_method(cFieldMap.klass, "end", VALUEFUNC(_wrap_FieldMap_end), -1);
  rb_define_method(cFieldMap.klass, "g_begin", VALUEFUNC(_wrap_FieldMap_g_begin), -1);
  rb_define_method(cFieldMap.klass, "g_end", VALUEFUNC(_wrap_FieldMap_g_end), -1);
  cFieldMap.mark = 0;
  cFieldMap.destroy = (void (*)(void *)) free_FIX_FieldMap;
  cFieldMap.trackObjects = 0;
  rb_define_singleton_method(mQuickfix, "headerOrder", VALUEFUNC(_wrap_headerOrder_get), 0);
  
  cMessage.klass = rb_define_class_under(mQuickfix, "Message", ((swig_class *) SWIGTYPE_p_FIX__FieldMap->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Message, (void *) &cMessage);
  rb_define_alloc_func(cMessage.klass, _wrap_Message_allocate);
  rb_define_method(cMessage.klass, "initialize", VALUEFUNC(_wrap_new_Message), -1);
  rb_define_singleton_method(cMessage.klass, "InitializeXML", VALUEFUNC(_wrap_Message_InitializeXML), -1);
  rb_define_method(cMessage.klass, "addGroup", VALUEFUNC(_wrap_Message_addGroup), -1);
  rb_define_method(cMessage.klass, "replaceGroup", VALUEFUNC(_wrap_Message_replaceGroup), -1);
  rb_define_method(cMessage.klass, "getGroup", VALUEFUNC(_wrap_Message_getGroup), -1);
  rb_define_method(cMessage.klass, "removeGroup", VALUEFUNC(_wrap_Message_removeGroup), -1);
  rb_define_method(cMessage.klass, "hasGroup", VALUEFUNC(_wrap_Message_hasGroup), -1);
  rb_define_method(cMessage.klass, "toString", VALUEFUNC(_wrap_Message_toString), -1);
  rb_define_method(cMessage.klass, "toXML", VALUEFUNC(_wrap_Message_toXML), -1);
  rb_define_method(cMessage.klass, "reverseRoute", VALUEFUNC(_wrap_Message_reverseRoute), -1);
  rb_define_method(cMessage.klass, "setString", VALUEFUNC(_wrap_Message_setString), -1);
  rb_define_method(cMessage.klass, "setGroup", VALUEFUNC(_wrap_Message_setGroup), -1);
  rb_define_method(cMessage.klass, "setStringHeader", VALUEFUNC(_wrap_Message_setStringHeader), -1);
  rb_define_method(cMessage.klass, "getHeader", VALUEFUNC(_wrap_Message_getHeader), -1);
  rb_define_method(cMessage.klass, "getTrailer", VALUEFUNC(_wrap_Message_getTrailer), -1);
  rb_define_method(cMessage.klass, "hasValidStructure", VALUEFUNC(_wrap_Message_hasValidStructure), -1);
  rb_define_method(cMessage.klass, "bodyLength", VALUEFUNC(_wrap_Message_bodyLength), -1);
  rb_define_method(cMessage.klass, "checkSum", VALUEFUNC(_wrap_Message_checkSum), -1);
  rb_define_method(cMessage.klass, "isAdmin", VALUEFUNC(_wrap_Message_isAdmin), -1);
  rb_define_method(cMessage.klass, "isApp", VALUEFUNC(_wrap_Message_isApp), -1);
  rb_define_method(cMessage.klass, "isEmpty", VALUEFUNC(_wrap_Message_isEmpty), -1);
  rb_define_method(cMessage.klass, "clear", VALUEFUNC(_wrap_Message_clear), -1);
  rb_define_singleton_method(cMessage.klass, "isAdminMsgType", VALUEFUNC(_wrap_Message_isAdminMsgType), -1);
  rb_define_singleton_method(cMessage.klass, "isHeaderField", VALUEFUNC(_wrap_Message_isHeaderField), -1);
  rb_define_singleton_method(cMessage.klass, "isTrailerField", VALUEFUNC(_wrap_Message_isTrailerField), -1);
  rb_define_method(cMessage.klass, "getSessionID", VALUEFUNC(_wrap_Message_getSessionID), -1);
  rb_define_method(cMessage.klass, "setSessionID", VALUEFUNC(_wrap_Message_setSessionID), -1);
  rb_define_method(cMessage.klass, "to_s", VALUEFUNC(_wrap_Message___str__), -1);
  cMessage.mark = 0;
  cMessage.destroy = (void (*)(void *)) free_FIX_Message;
  cMessage.trackObjects = 0;
  rb_define_module_function(mQuickfix, "identifyType", VALUEFUNC(_wrap_identifyType), -1);
  
  cGroup.klass = rb_define_class_under(mQuickfix, "Group", ((swig_class *) SWIGTYPE_p_FIX__FieldMap->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Group, (void *) &cGroup);
  rb_define_alloc_func(cGroup.klass, _wrap_Group_allocate);
  rb_define_method(cGroup.klass, "initialize", VALUEFUNC(_wrap_new_Group), -1);
  rb_define_method(cGroup.klass, "field", VALUEFUNC(_wrap_Group_field), -1);
  rb_define_method(cGroup.klass, "delim", VALUEFUNC(_wrap_Group_delim), -1);
  rb_define_method(cGroup.klass, "addGroup", VALUEFUNC(_wrap_Group_addGroup), -1);
  rb_define_method(cGroup.klass, "replaceGroup", VALUEFUNC(_wrap_Group_replaceGroup), -1);
  rb_define_method(cGroup.klass, "getGroup", VALUEFUNC(_wrap_Group_getGroup), -1);
  rb_define_method(cGroup.klass, "removeGroup", VALUEFUNC(_wrap_Group_removeGroup), -1);
  rb_define_method(cGroup.klass, "hasGroup", VALUEFUNC(_wrap_Group_hasGroup), -1);
  cGroup.mark = 0;
  cGroup.destroy = (void (*)(void *)) free_FIX_Group;
  cGroup.trackObjects = 0;
  
  cExecTransType.klass = rb_define_class_under(mQuickfix, "ExecTransType", ((swig_class *) SWIGTYPE_p_FIX__CharField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ExecTransType, (void *) &cExecTransType);
  rb_define_alloc_func(cExecTransType.klass, _wrap_ExecTransType_allocate);
  rb_define_method(cExecTransType.klass, "initialize", VALUEFUNC(_wrap_new_ExecTransType), -1);
  cExecTransType.mark = 0;
  cExecTransType.destroy = (void (*)(void *)) free_FIX_ExecTransType;
  cExecTransType.trackObjects = 0;
  
  cIDSource.klass = rb_define_class_under(mQuickfix, "IDSource", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IDSource, (void *) &cIDSource);
  rb_define_alloc_func(cIDSource.klass, _wrap_IDSource_allocate);
  rb_define_method(cIDSource.klass, "initialize", VALUEFUNC(_wrap_new_IDSource), -1);
  cIDSource.mark = 0;
  cIDSource.destroy = (void (*)(void *)) free_FIX_IDSource;
  cIDSource.trackObjects = 0;
  
  cIOIOthSvc.klass = rb_define_class_under(mQuickfix, "IOIOthSvc", ((swig_class *) SWIGTYPE_p_FIX__CharField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IOIOthSvc, (void *) &cIOIOthSvc);
  rb_define_alloc_func(cIOIOthSvc.klass, _wrap_IOIOthSvc_allocate);
  rb_define_method(cIOIOthSvc.klass, "initialize", VALUEFUNC(_wrap_new_IOIOthSvc), -1);
  cIOIOthSvc.mark = 0;
  cIOIOthSvc.destroy = (void (*)(void *)) free_FIX_IOIOthSvc;
  cIOIOthSvc.trackObjects = 0;
  
  cIOIShares.klass = rb_define_class_under(mQuickfix, "IOIShares", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__IOIShares, (void *) &cIOIShares);
  rb_define_alloc_func(cIOIShares.klass, _wrap_IOIShares_allocate);
  rb_define_method(cIOIShares.klass, "initialize", VALUEFUNC(_wrap_new_IOIShares), -1);
  cIOIShares.mark = 0;
  cIOIShares.destroy = (void (*)(void *)) free_FIX_IOIShares;
  cIOIShares.trackObjects = 0;
  
  cLastShares.klass = rb_define_class_under(mQuickfix, "LastShares", ((swig_class *) SWIGTYPE_p_FIX__DoubleField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__LastShares, (void *) &cLastShares);
  rb_define_alloc_func(cLastShares.klass, _wrap_LastShares_allocate);
  rb_define_method(cLastShares.klass, "initialize", VALUEFUNC(_wrap_new_LastShares), -1);
  cLastShares.mark = 0;
  cLastShares.destroy = (void (*)(void *)) free_FIX_LastShares;
  cLastShares.trackObjects = 0;
  
  cRelatdSym.klass = rb_define_class_under(mQuickfix, "RelatdSym", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RelatdSym, (void *) &cRelatdSym);
  rb_define_alloc_func(cRelatdSym.klass, _wrap_RelatdSym_allocate);
  rb_define_method(cRelatdSym.klass, "initialize", VALUEFUNC(_wrap_new_RelatdSym), -1);
  cRelatdSym.mark = 0;
  cRelatdSym.destroy = (void (*)(void *)) free_FIX_RelatdSym;
  cRelatdSym.trackObjects = 0;
  
  cRule80A.klass = rb_define_class_under(mQuickfix, "Rule80A", ((swig_class *) SWIGTYPE_p_FIX__CharField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Rule80A, (void *) &cRule80A);
  rb_define_alloc_func(cRule80A.klass, _wrap_Rule80A_allocate);
  rb_define_method(cRule80A.klass, "initialize", VALUEFUNC(_wrap_new_Rule80A), -1);
  cRule80A.mark = 0;
  cRule80A.destroy = (void (*)(void *)) free_FIX_Rule80A;
  cRule80A.trackObjects = 0;
  
  cShares.klass = rb_define_class_under(mQuickfix, "Shares", ((swig_class *) SWIGTYPE_p_FIX__DoubleField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Shares, (void *) &cShares);
  rb_define_alloc_func(cShares.klass, _wrap_Shares_allocate);
  rb_define_method(cShares.klass, "initialize", VALUEFUNC(_wrap_new_Shares), -1);
  cShares.mark = 0;
  cShares.destroy = (void (*)(void *)) free_FIX_Shares;
  cShares.trackObjects = 0;
  
  cSettlmntTyp.klass = rb_define_class_under(mQuickfix, "SettlmntTyp", ((swig_class *) SWIGTYPE_p_FIX__CharField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SettlmntTyp, (void *) &cSettlmntTyp);
  rb_define_alloc_func(cSettlmntTyp.klass, _wrap_SettlmntTyp_allocate);
  rb_define_method(cSettlmntTyp.klass, "initialize", VALUEFUNC(_wrap_new_SettlmntTyp), -1);
  cSettlmntTyp.mark = 0;
  cSettlmntTyp.destroy = (void (*)(void *)) free_FIX_SettlmntTyp;
  cSettlmntTyp.trackObjects = 0;
  
  cFutSettDate.klass = rb_define_class_under(mQuickfix, "FutSettDate", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FutSettDate, (void *) &cFutSettDate);
  rb_define_alloc_func(cFutSettDate.klass, _wrap_FutSettDate_allocate);
  rb_define_method(cFutSettDate.klass, "initialize", VALUEFUNC(_wrap_new_FutSettDate), -1);
  cFutSettDate.mark = 0;
  cFutSettDate.destroy = (void (*)(void *)) free_FIX_FutSettDate;
  cFutSettDate.trackObjects = 0;
  
  cAvgPrxPrecision.klass = rb_define_class_under(mQuickfix, "AvgPrxPrecision", ((swig_class *) SWIGTYPE_p_FIX__IntField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__AvgPrxPrecision, (void *) &cAvgPrxPrecision);
  rb_define_alloc_func(cAvgPrxPrecision.klass, _wrap_AvgPrxPrecision_allocate);
  rb_define_method(cAvgPrxPrecision.klass, "initialize", VALUEFUNC(_wrap_new_AvgPrxPrecision), -1);
  cAvgPrxPrecision.mark = 0;
  cAvgPrxPrecision.destroy = (void (*)(void *)) free_FIX_AvgPrxPrecision;
  cAvgPrxPrecision.trackObjects = 0;
  
  cExecBroker.klass = rb_define_class_under(mQuickfix, "ExecBroker", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ExecBroker, (void *) &cExecBroker);
  rb_define_alloc_func(cExecBroker.klass, _wrap_ExecBroker_allocate);
  rb_define_method(cExecBroker.klass, "initialize", VALUEFUNC(_wrap_new_ExecBroker), -1);
  cExecBroker.mark = 0;
  cExecBroker.destroy = (void (*)(void *)) free_FIX_ExecBroker;
  cExecBroker.trackObjects = 0;
  
  cOpenClose.klass = rb_define_class_under(mQuickfix, "OpenClose", ((swig_class *) SWIGTYPE_p_FIX__CharField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__OpenClose, (void *) &cOpenClose);
  rb_define_alloc_func(cOpenClose.klass, _wrap_OpenClose_allocate);
  rb_define_method(cOpenClose.klass, "initialize", VALUEFUNC(_wrap_new_OpenClose), -1);
  cOpenClose.mark = 0;
  cOpenClose.destroy = (void (*)(void *)) free_FIX_OpenClose;
  cOpenClose.trackObjects = 0;
  
  cAllocShares.klass = rb_define_class_under(mQuickfix, "AllocShares", ((swig_class *) SWIGTYPE_p_FIX__IntField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__AllocShares, (void *) &cAllocShares);
  rb_define_alloc_func(cAllocShares.klass, _wrap_AllocShares_allocate);
  rb_define_method(cAllocShares.klass, "initialize", VALUEFUNC(_wrap_new_AllocShares), -1);
  cAllocShares.mark = 0;
  cAllocShares.destroy = (void (*)(void *)) free_FIX_AllocShares;
  cAllocShares.trackObjects = 0;
  
  cDlvyInst.klass = rb_define_class_under(mQuickfix, "DlvyInst", ((swig_class *) SWIGTYPE_p_FIX__CharField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DlvyInst, (void *) &cDlvyInst);
  rb_define_alloc_func(cDlvyInst.klass, _wrap_DlvyInst_allocate);
  rb_define_method(cDlvyInst.klass, "initialize", VALUEFUNC(_wrap_new_DlvyInst), -1);
  cDlvyInst.mark = 0;
  cDlvyInst.destroy = (void (*)(void *)) free_FIX_DlvyInst;
  cDlvyInst.trackObjects = 0;
  
  cBrokerOfCredit.klass = rb_define_class_under(mQuickfix, "BrokerOfCredit", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__BrokerOfCredit, (void *) &cBrokerOfCredit);
  rb_define_alloc_func(cBrokerOfCredit.klass, _wrap_BrokerOfCredit_allocate);
  rb_define_method(cBrokerOfCredit.klass, "initialize", VALUEFUNC(_wrap_new_BrokerOfCredit), -1);
  cBrokerOfCredit.mark = 0;
  cBrokerOfCredit.destroy = (void (*)(void *)) free_FIX_BrokerOfCredit;
  cBrokerOfCredit.trackObjects = 0;
  
  cClientID.klass = rb_define_class_under(mQuickfix, "ClientID", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ClientID, (void *) &cClientID);
  rb_define_alloc_func(cClientID.klass, _wrap_ClientID_allocate);
  rb_define_method(cClientID.klass, "initialize", VALUEFUNC(_wrap_new_ClientID), -1);
  cClientID.mark = 0;
  cClientID.destroy = (void (*)(void *)) free_FIX_ClientID;
  cClientID.trackObjects = 0;
  
  cCxlType.klass = rb_define_class_under(mQuickfix, "CxlType", ((swig_class *) SWIGTYPE_p_FIX__CharField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CxlType, (void *) &cCxlType);
  rb_define_alloc_func(cCxlType.klass, _wrap_CxlType_allocate);
  rb_define_method(cCxlType.klass, "initialize", VALUEFUNC(_wrap_new_CxlType), -1);
  cCxlType.mark = 0;
  cCxlType.destroy = (void (*)(void *)) free_FIX_CxlType;
  cCxlType.trackObjects = 0;
  
  cSettlLocation.klass = rb_define_class_under(mQuickfix, "SettlLocation", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SettlLocation, (void *) &cSettlLocation);
  rb_define_alloc_func(cSettlLocation.klass, _wrap_SettlLocation_allocate);
  rb_define_method(cSettlLocation.klass, "initialize", VALUEFUNC(_wrap_new_SettlLocation), -1);
  cSettlLocation.mark = 0;
  cSettlLocation.destroy = (void (*)(void *)) free_FIX_SettlLocation;
  cSettlLocation.trackObjects = 0;
  
  cSettlDepositoryCode.klass = rb_define_class_under(mQuickfix, "SettlDepositoryCode", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SettlDepositoryCode, (void *) &cSettlDepositoryCode);
  rb_define_alloc_func(cSettlDepositoryCode.klass, _wrap_SettlDepositoryCode_allocate);
  rb_define_method(cSettlDepositoryCode.klass, "initialize", VALUEFUNC(_wrap_new_SettlDepositoryCode), -1);
  cSettlDepositoryCode.mark = 0;
  cSettlDepositoryCode.destroy = (void (*)(void *)) free_FIX_SettlDepositoryCode;
  cSettlDepositoryCode.trackObjects = 0;
  
  cSettlBrkrCode.klass = rb_define_class_under(mQuickfix, "SettlBrkrCode", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SettlBrkrCode, (void *) &cSettlBrkrCode);
  rb_define_alloc_func(cSettlBrkrCode.klass, _wrap_SettlBrkrCode_allocate);
  rb_define_method(cSettlBrkrCode.klass, "initialize", VALUEFUNC(_wrap_new_SettlBrkrCode), -1);
  cSettlBrkrCode.mark = 0;
  cSettlBrkrCode.destroy = (void (*)(void *)) free_FIX_SettlBrkrCode;
  cSettlBrkrCode.trackObjects = 0;
  
  cSettlInstCode.klass = rb_define_class_under(mQuickfix, "SettlInstCode", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SettlInstCode, (void *) &cSettlInstCode);
  rb_define_alloc_func(cSettlInstCode.klass, _wrap_SettlInstCode_allocate);
  rb_define_method(cSettlInstCode.klass, "initialize", VALUEFUNC(_wrap_new_SettlInstCode), -1);
  cSettlInstCode.mark = 0;
  cSettlInstCode.destroy = (void (*)(void *)) free_FIX_SettlInstCode;
  cSettlInstCode.trackObjects = 0;
  
  cSecuritySettlAgentName.klass = rb_define_class_under(mQuickfix, "SecuritySettlAgentName", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SecuritySettlAgentName, (void *) &cSecuritySettlAgentName);
  rb_define_alloc_func(cSecuritySettlAgentName.klass, _wrap_SecuritySettlAgentName_allocate);
  rb_define_method(cSecuritySettlAgentName.klass, "initialize", VALUEFUNC(_wrap_new_SecuritySettlAgentName), -1);
  cSecuritySettlAgentName.mark = 0;
  cSecuritySettlAgentName.destroy = (void (*)(void *)) free_FIX_SecuritySettlAgentName;
  cSecuritySettlAgentName.trackObjects = 0;
  
  cSecuritySettlAgentCode.klass = rb_define_class_under(mQuickfix, "SecuritySettlAgentCode", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SecuritySettlAgentCode, (void *) &cSecuritySettlAgentCode);
  rb_define_alloc_func(cSecuritySettlAgentCode.klass, _wrap_SecuritySettlAgentCode_allocate);
  rb_define_method(cSecuritySettlAgentCode.klass, "initialize", VALUEFUNC(_wrap_new_SecuritySettlAgentCode), -1);
  cSecuritySettlAgentCode.mark = 0;
  cSecuritySettlAgentCode.destroy = (void (*)(void *)) free_FIX_SecuritySettlAgentCode;
  cSecuritySettlAgentCode.trackObjects = 0;
  
  cSecuritySettlAgentAcctNum.klass = rb_define_class_under(mQuickfix, "SecuritySettlAgentAcctNum", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SecuritySettlAgentAcctNum, (void *) &cSecuritySettlAgentAcctNum);
  rb_define_alloc_func(cSecuritySettlAgentAcctNum.klass, _wrap_SecuritySettlAgentAcctNum_allocate);
  rb_define_method(cSecuritySettlAgentAcctNum.klass, "initialize", VALUEFUNC(_wrap_new_SecuritySettlAgentAcctNum), -1);
  cSecuritySettlAgentAcctNum.mark = 0;
  cSecuritySettlAgentAcctNum.destroy = (void (*)(void *)) free_FIX_SecuritySettlAgentAcctNum;
  cSecuritySettlAgentAcctNum.trackObjects = 0;
  
  cSecuritySettlAgentAcctName.klass = rb_define_class_under(mQuickfix, "SecuritySettlAgentAcctName", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SecuritySettlAgentAcctName, (void *) &cSecuritySettlAgentAcctName);
  rb_define_alloc_func(cSecuritySettlAgentAcctName.klass, _wrap_SecuritySettlAgentAcctName_allocate);
  rb_define_method(cSecuritySettlAgentAcctName.klass, "initialize", VALUEFUNC(_wrap_new_SecuritySettlAgentAcctName), -1);
  cSecuritySettlAgentAcctName.mark = 0;
  cSecuritySettlAgentAcctName.destroy = (void (*)(void *)) free_FIX_SecuritySettlAgentAcctName;
  cSecuritySettlAgentAcctName.trackObjects = 0;
  
  cSecuritySettlAgentContactName.klass = rb_define_class_under(mQuickfix, "SecuritySettlAgentContactName", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SecuritySettlAgentContactName, (void *) &cSecuritySettlAgentContactName);
  rb_define_alloc_func(cSecuritySettlAgentContactName.klass, _wrap_SecuritySettlAgentContactName_allocate);
  rb_define_method(cSecuritySettlAgentContactName.klass, "initialize", VALUEFUNC(_wrap_new_SecuritySettlAgentContactName), -1);
  cSecuritySettlAgentContactName.mark = 0;
  cSecuritySettlAgentContactName.destroy = (void (*)(void *)) free_FIX_SecuritySettlAgentContactName;
  cSecuritySettlAgentContactName.trackObjects = 0;
  
  cSecuritySettlAgentContactPhone.klass = rb_define_class_under(mQuickfix, "SecuritySettlAgentContactPhone", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SecuritySettlAgentContactPhone, (void *) &cSecuritySettlAgentContactPhone);
  rb_define_alloc_func(cSecuritySettlAgentContactPhone.klass, _wrap_SecuritySettlAgentContactPhone_allocate);
  rb_define_method(cSecuritySettlAgentContactPhone.klass, "initialize", VALUEFUNC(_wrap_new_SecuritySettlAgentContactPhone), -1);
  cSecuritySettlAgentContactPhone.mark = 0;
  cSecuritySettlAgentContactPhone.destroy = (void (*)(void *)) free_FIX_SecuritySettlAgentContactPhone;
  cSecuritySettlAgentContactPhone.trackObjects = 0;
  
  cCashSettlAgentName.klass = rb_define_class_under(mQuickfix, "CashSettlAgentName", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CashSettlAgentName, (void *) &cCashSettlAgentName);
  rb_define_alloc_func(cCashSettlAgentName.klass, _wrap_CashSettlAgentName_allocate);
  rb_define_method(cCashSettlAgentName.klass, "initialize", VALUEFUNC(_wrap_new_CashSettlAgentName), -1);
  cCashSettlAgentName.mark = 0;
  cCashSettlAgentName.destroy = (void (*)(void *)) free_FIX_CashSettlAgentName;
  cCashSettlAgentName.trackObjects = 0;
  
  cCashSettlAgentCode.klass = rb_define_class_under(mQuickfix, "CashSettlAgentCode", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CashSettlAgentCode, (void *) &cCashSettlAgentCode);
  rb_define_alloc_func(cCashSettlAgentCode.klass, _wrap_CashSettlAgentCode_allocate);
  rb_define_method(cCashSettlAgentCode.klass, "initialize", VALUEFUNC(_wrap_new_CashSettlAgentCode), -1);
  cCashSettlAgentCode.mark = 0;
  cCashSettlAgentCode.destroy = (void (*)(void *)) free_FIX_CashSettlAgentCode;
  cCashSettlAgentCode.trackObjects = 0;
  
  cCashSettlAgentAcctNum.klass = rb_define_class_under(mQuickfix, "CashSettlAgentAcctNum", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CashSettlAgentAcctNum, (void *) &cCashSettlAgentAcctNum);
  rb_define_alloc_func(cCashSettlAgentAcctNum.klass, _wrap_CashSettlAgentAcctNum_allocate);
  rb_define_method(cCashSettlAgentAcctNum.klass, "initialize", VALUEFUNC(_wrap_new_CashSettlAgentAcctNum), -1);
  cCashSettlAgentAcctNum.mark = 0;
  cCashSettlAgentAcctNum.destroy = (void (*)(void *)) free_FIX_CashSettlAgentAcctNum;
  cCashSettlAgentAcctNum.trackObjects = 0;
  
  cCashSettlAgentAcctName.klass = rb_define_class_under(mQuickfix, "CashSettlAgentAcctName", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CashSettlAgentAcctName, (void *) &cCashSettlAgentAcctName);
  rb_define_alloc_func(cCashSettlAgentAcctName.klass, _wrap_CashSettlAgentAcctName_allocate);
  rb_define_method(cCashSettlAgentAcctName.klass, "initialize", VALUEFUNC(_wrap_new_CashSettlAgentAcctName), -1);
  cCashSettlAgentAcctName.mark = 0;
  cCashSettlAgentAcctName.destroy = (void (*)(void *)) free_FIX_CashSettlAgentAcctName;
  cCashSettlAgentAcctName.trackObjects = 0;
  
  cCashSettlAgentContactName.klass = rb_define_class_under(mQuickfix, "CashSettlAgentContactName", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CashSettlAgentContactName, (void *) &cCashSettlAgentContactName);
  rb_define_alloc_func(cCashSettlAgentContactName.klass, _wrap_CashSettlAgentContactName_allocate);
  rb_define_method(cCashSettlAgentContactName.klass, "initialize", VALUEFUNC(_wrap_new_CashSettlAgentContactName), -1);
  cCashSettlAgentContactName.mark = 0;
  cCashSettlAgentContactName.destroy = (void (*)(void *)) free_FIX_CashSettlAgentContactName;
  cCashSettlAgentContactName.trackObjects = 0;
  
  cCashSettlAgentContactPhone.klass = rb_define_class_under(mQuickfix, "CashSettlAgentContactPhone", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CashSettlAgentContactPhone, (void *) &cCashSettlAgentContactPhone);
  rb_define_alloc_func(cCashSettlAgentContactPhone.klass, _wrap_CashSettlAgentContactPhone_allocate);
  rb_define_method(cCashSettlAgentContactPhone.klass, "initialize", VALUEFUNC(_wrap_new_CashSettlAgentContactPhone), -1);
  cCashSettlAgentContactPhone.mark = 0;
  cCashSettlAgentContactPhone.destroy = (void (*)(void *)) free_FIX_CashSettlAgentContactPhone;
  cCashSettlAgentContactPhone.trackObjects = 0;
  
  cFutSettDate2.klass = rb_define_class_under(mQuickfix, "FutSettDate2", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FutSettDate2, (void *) &cFutSettDate2);
  rb_define_alloc_func(cFutSettDate2.klass, _wrap_FutSettDate2_allocate);
  rb_define_method(cFutSettDate2.klass, "initialize", VALUEFUNC(_wrap_new_FutSettDate2), -1);
  cFutSettDate2.mark = 0;
  cFutSettDate2.destroy = (void (*)(void *)) free_FIX_FutSettDate2;
  cFutSettDate2.trackObjects = 0;
  
  cPutOrCall.klass = rb_define_class_under(mQuickfix, "PutOrCall", ((swig_class *) SWIGTYPE_p_FIX__IntField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__PutOrCall, (void *) &cPutOrCall);
  rb_define_alloc_func(cPutOrCall.klass, _wrap_PutOrCall_allocate);
  rb_define_method(cPutOrCall.klass, "initialize", VALUEFUNC(_wrap_new_PutOrCall), -1);
  cPutOrCall.mark = 0;
  cPutOrCall.destroy = (void (*)(void *)) free_FIX_PutOrCall;
  cPutOrCall.trackObjects = 0;
  
  cCustomerOrFirm.klass = rb_define_class_under(mQuickfix, "CustomerOrFirm", ((swig_class *) SWIGTYPE_p_FIX__IntField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CustomerOrFirm, (void *) &cCustomerOrFirm);
  rb_define_alloc_func(cCustomerOrFirm.klass, _wrap_CustomerOrFirm_allocate);
  rb_define_method(cCustomerOrFirm.klass, "initialize", VALUEFUNC(_wrap_new_CustomerOrFirm), -1);
  cCustomerOrFirm.mark = 0;
  cCustomerOrFirm.destroy = (void (*)(void *)) free_FIX_CustomerOrFirm;
  cCustomerOrFirm.trackObjects = 0;
  
  cMaturityDay.klass = rb_define_class_under(mQuickfix, "MaturityDay", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MaturityDay, (void *) &cMaturityDay);
  rb_define_alloc_func(cMaturityDay.klass, _wrap_MaturityDay_allocate);
  rb_define_method(cMaturityDay.klass, "initialize", VALUEFUNC(_wrap_new_MaturityDay), -1);
  cMaturityDay.mark = 0;
  cMaturityDay.destroy = (void (*)(void *)) free_FIX_MaturityDay;
  cMaturityDay.trackObjects = 0;
  
  cPegDifference.klass = rb_define_class_under(mQuickfix, "PegDifference", ((swig_class *) SWIGTYPE_p_FIX__DoubleField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__PegDifference, (void *) &cPegDifference);
  rb_define_alloc_func(cPegDifference.klass, _wrap_PegDifference_allocate);
  rb_define_method(cPegDifference.klass, "initialize", VALUEFUNC(_wrap_new_PegDifference), -1);
  cPegDifference.mark = 0;
  cPegDifference.destroy = (void (*)(void *)) free_FIX_PegDifference;
  cPegDifference.trackObjects = 0;
  
  cSpreadToBenchmark.klass = rb_define_class_under(mQuickfix, "SpreadToBenchmark", ((swig_class *) SWIGTYPE_p_FIX__DoubleField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SpreadToBenchmark, (void *) &cSpreadToBenchmark);
  rb_define_alloc_func(cSpreadToBenchmark.klass, _wrap_SpreadToBenchmark_allocate);
  rb_define_method(cSpreadToBenchmark.klass, "initialize", VALUEFUNC(_wrap_new_SpreadToBenchmark), -1);
  cSpreadToBenchmark.mark = 0;
  cSpreadToBenchmark.destroy = (void (*)(void *)) free_FIX_SpreadToBenchmark;
  cSpreadToBenchmark.trackObjects = 0;
  
  cBenchmark.klass = rb_define_class_under(mQuickfix, "Benchmark", ((swig_class *) SWIGTYPE_p_FIX__CharField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Benchmark, (void *) &cBenchmark);
  rb_define_alloc_func(cBenchmark.klass, _wrap_Benchmark_allocate);
  rb_define_method(cBenchmark.klass, "initialize", VALUEFUNC(_wrap_new_Benchmark), -1);
  cBenchmark.mark = 0;
  cBenchmark.destroy = (void (*)(void *)) free_FIX_Benchmark;
  cBenchmark.trackObjects = 0;
  
  cOpenCloseSettleFlag.klass = rb_define_class_under(mQuickfix, "OpenCloseSettleFlag", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__OpenCloseSettleFlag, (void *) &cOpenCloseSettleFlag);
  rb_define_alloc_func(cOpenCloseSettleFlag.klass, _wrap_OpenCloseSettleFlag_allocate);
  rb_define_method(cOpenCloseSettleFlag.klass, "initialize", VALUEFUNC(_wrap_new_OpenCloseSettleFlag), -1);
  cOpenCloseSettleFlag.mark = 0;
  cOpenCloseSettleFlag.destroy = (void (*)(void *)) free_FIX_OpenCloseSettleFlag;
  cOpenCloseSettleFlag.trackObjects = 0;
  
  cUnderlyingIDSource.klass = rb_define_class_under(mQuickfix, "UnderlyingIDSource", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UnderlyingIDSource, (void *) &cUnderlyingIDSource);
  rb_define_alloc_func(cUnderlyingIDSource.klass, _wrap_UnderlyingIDSource_allocate);
  rb_define_method(cUnderlyingIDSource.klass, "initialize", VALUEFUNC(_wrap_new_UnderlyingIDSource), -1);
  cUnderlyingIDSource.mark = 0;
  cUnderlyingIDSource.destroy = (void (*)(void *)) free_FIX_UnderlyingIDSource;
  cUnderlyingIDSource.trackObjects = 0;
  
  cQuoteAckStatus.klass = rb_define_class_under(mQuickfix, "QuoteAckStatus", ((swig_class *) SWIGTYPE_p_FIX__IntField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__QuoteAckStatus, (void *) &cQuoteAckStatus);
  rb_define_alloc_func(cQuoteAckStatus.klass, _wrap_QuoteAckStatus_allocate);
  rb_define_method(cQuoteAckStatus.klass, "initialize", VALUEFUNC(_wrap_new_QuoteAckStatus), -1);
  cQuoteAckStatus.mark = 0;
  cQuoteAckStatus.destroy = (void (*)(void *)) free_FIX_QuoteAckStatus;
  cQuoteAckStatus.trackObjects = 0;
  
  cTotQuoteEntries.klass = rb_define_class_under(mQuickfix, "TotQuoteEntries", ((swig_class *) SWIGTYPE_p_FIX__IntField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TotQuoteEntries, (void *) &cTotQuoteEntries);
  rb_define_alloc_func(cTotQuoteEntries.klass, _wrap_TotQuoteEntries_allocate);
  rb_define_method(cTotQuoteEntries.klass, "initialize", VALUEFUNC(_wrap_new_TotQuoteEntries), -1);
  cTotQuoteEntries.mark = 0;
  cTotQuoteEntries.destroy = (void (*)(void *)) free_FIX_TotQuoteEntries;
  cTotQuoteEntries.trackObjects = 0;
  
  cUnderlyingMaturityDay.klass = rb_define_class_under(mQuickfix, "UnderlyingMaturityDay", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UnderlyingMaturityDay, (void *) &cUnderlyingMaturityDay);
  rb_define_alloc_func(cUnderlyingMaturityDay.klass, _wrap_UnderlyingMaturityDay_allocate);
  rb_define_method(cUnderlyingMaturityDay.klass, "initialize", VALUEFUNC(_wrap_new_UnderlyingMaturityDay), -1);
  cUnderlyingMaturityDay.mark = 0;
  cUnderlyingMaturityDay.destroy = (void (*)(void *)) free_FIX_UnderlyingMaturityDay;
  cUnderlyingMaturityDay.trackObjects = 0;
  
  cUnderlyingPutOrCall.klass = rb_define_class_under(mQuickfix, "UnderlyingPutOrCall", ((swig_class *) SWIGTYPE_p_FIX__IntField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__UnderlyingPutOrCall, (void *) &cUnderlyingPutOrCall);
  rb_define_alloc_func(cUnderlyingPutOrCall.klass, _wrap_UnderlyingPutOrCall_allocate);
  rb_define_method(cUnderlyingPutOrCall.klass, "initialize", VALUEFUNC(_wrap_new_UnderlyingPutOrCall), -1);
  cUnderlyingPutOrCall.mark = 0;
  cUnderlyingPutOrCall.destroy = (void (*)(void *)) free_FIX_UnderlyingPutOrCall;
  cUnderlyingPutOrCall.trackObjects = 0;
  
  cRatioQty.klass = rb_define_class_under(mQuickfix, "RatioQty", ((swig_class *) SWIGTYPE_p_FIX__DoubleField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RatioQty, (void *) &cRatioQty);
  rb_define_alloc_func(cRatioQty.klass, _wrap_RatioQty_allocate);
  rb_define_method(cRatioQty.klass, "initialize", VALUEFUNC(_wrap_new_RatioQty), -1);
  cRatioQty.mark = 0;
  cRatioQty.destroy = (void (*)(void *)) free_FIX_RatioQty;
  cRatioQty.trackObjects = 0;
  
  cOnBehalfOfSendingTime.klass = rb_define_class_under(mQuickfix, "OnBehalfOfSendingTime", ((swig_class *) SWIGTYPE_p_FIX__UtcTimeStampField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__OnBehalfOfSendingTime, (void *) &cOnBehalfOfSendingTime);
  rb_define_alloc_func(cOnBehalfOfSendingTime.klass, _wrap_OnBehalfOfSendingTime_allocate);
  rb_define_method(cOnBehalfOfSendingTime.klass, "initialize", VALUEFUNC(_wrap_new_OnBehalfOfSendingTime), -1);
  cOnBehalfOfSendingTime.mark = 0;
  cOnBehalfOfSendingTime.destroy = (void (*)(void *)) free_FIX_OnBehalfOfSendingTime;
  cOnBehalfOfSendingTime.trackObjects = 0;
  
  cDiscretionOffset.klass = rb_define_class_under(mQuickfix, "DiscretionOffset", ((swig_class *) SWIGTYPE_p_FIX__DoubleField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DiscretionOffset, (void *) &cDiscretionOffset);
  rb_define_alloc_func(cDiscretionOffset.klass, _wrap_DiscretionOffset_allocate);
  rb_define_method(cDiscretionOffset.klass, "initialize", VALUEFUNC(_wrap_new_DiscretionOffset), -1);
  cDiscretionOffset.mark = 0;
  cDiscretionOffset.destroy = (void (*)(void *)) free_FIX_DiscretionOffset;
  cDiscretionOffset.trackObjects = 0;
  
  cTotalNumSecurities.klass = rb_define_class_under(mQuickfix, "TotalNumSecurities", ((swig_class *) SWIGTYPE_p_FIX__IntField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TotalNumSecurities, (void *) &cTotalNumSecurities);
  rb_define_alloc_func(cTotalNumSecurities.klass, _wrap_TotalNumSecurities_allocate);
  rb_define_method(cTotalNumSecurities.klass, "initialize", VALUEFUNC(_wrap_new_TotalNumSecurities), -1);
  cTotalNumSecurities.mark = 0;
  cTotalNumSecurities.destroy = (void (*)(void *)) free_FIX_TotalNumSecurities;
  cTotalNumSecurities.trackObjects = 0;
  
  cTradeType.klass = rb_define_class_under(mQuickfix, "TradeType", ((swig_class *) SWIGTYPE_p_FIX__CharField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TradeType, (void *) &cTradeType);
  rb_define_alloc_func(cTradeType.klass, _wrap_TradeType_allocate);
  rb_define_method(cTradeType.klass, "initialize", VALUEFUNC(_wrap_new_TradeType), -1);
  cTradeType.mark = 0;
  cTradeType.destroy = (void (*)(void *)) free_FIX_TradeType;
  cTradeType.trackObjects = 0;
  
  cClearingFirm.klass = rb_define_class_under(mQuickfix, "ClearingFirm", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ClearingFirm, (void *) &cClearingFirm);
  rb_define_alloc_func(cClearingFirm.klass, _wrap_ClearingFirm_allocate);
  rb_define_method(cClearingFirm.klass, "initialize", VALUEFUNC(_wrap_new_ClearingFirm), -1);
  cClearingFirm.mark = 0;
  cClearingFirm.destroy = (void (*)(void *)) free_FIX_ClearingFirm;
  cClearingFirm.trackObjects = 0;
  
  cClearingAccount.klass = rb_define_class_under(mQuickfix, "ClearingAccount", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ClearingAccount, (void *) &cClearingAccount);
  rb_define_alloc_func(cClearingAccount.klass, _wrap_ClearingAccount_allocate);
  rb_define_method(cClearingAccount.klass, "initialize", VALUEFUNC(_wrap_new_ClearingAccount), -1);
  cClearingAccount.mark = 0;
  cClearingAccount.destroy = (void (*)(void *)) free_FIX_ClearingAccount;
  cClearingAccount.trackObjects = 0;
  
  cTotalVolumeTradedDate.klass = rb_define_class_under(mQuickfix, "TotalVolumeTradedDate", ((swig_class *) SWIGTYPE_p_FIX__UtcDateField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TotalVolumeTradedDate, (void *) &cTotalVolumeTradedDate);
  rb_define_alloc_func(cTotalVolumeTradedDate.klass, _wrap_TotalVolumeTradedDate_allocate);
  rb_define_method(cTotalVolumeTradedDate.klass, "initialize", VALUEFUNC(_wrap_new_TotalVolumeTradedDate), -1);
  cTotalVolumeTradedDate.mark = 0;
  cTotalVolumeTradedDate.destroy = (void (*)(void *)) free_FIX_TotalVolumeTradedDate;
  cTotalVolumeTradedDate.trackObjects = 0;
  
  cTotalVolumeTradedTime.klass = rb_define_class_under(mQuickfix, "TotalVolumeTradedTime", ((swig_class *) SWIGTYPE_p_FIX__UtcTimeOnlyField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TotalVolumeTradedTime, (void *) &cTotalVolumeTradedTime);
  rb_define_alloc_func(cTotalVolumeTradedTime.klass, _wrap_TotalVolumeTradedTime_allocate);
  rb_define_method(cTotalVolumeTradedTime.klass, "initialize", VALUEFUNC(_wrap_new_TotalVolumeTradedTime), -1);
  cTotalVolumeTradedTime.mark = 0;
  cTotalVolumeTradedTime.destroy = (void (*)(void *)) free_FIX_TotalVolumeTradedTime;
  cTotalVolumeTradedTime.trackObjects = 0;
  
  cCardIssNo.klass = rb_define_class_under(mQuickfix, "CardIssNo", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__CardIssNo, (void *) &cCardIssNo);
  rb_define_alloc_func(cCardIssNo.klass, _wrap_CardIssNo_allocate);
  rb_define_method(cCardIssNo.klass, "initialize", VALUEFUNC(_wrap_new_CardIssNo), -1);
  cCardIssNo.mark = 0;
  cCardIssNo.destroy = (void (*)(void *)) free_FIX_CardIssNo;
  cCardIssNo.trackObjects = 0;
  
  cRegistDetls.klass = rb_define_class_under(mQuickfix, "RegistDetls", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__RegistDetls, (void *) &cRegistDetls);
  rb_define_alloc_func(cRegistDetls.klass, _wrap_RegistDetls_allocate);
  rb_define_method(cRegistDetls.klass, "initialize", VALUEFUNC(_wrap_new_RegistDetls), -1);
  cRegistDetls.mark = 0;
  cRegistDetls.destroy = (void (*)(void *)) free_FIX_RegistDetls;
  cRegistDetls.trackObjects = 0;
  
  cTotalNumSecurityTypes.klass = rb_define_class_under(mQuickfix, "TotalNumSecurityTypes", ((swig_class *) SWIGTYPE_p_FIX__IntField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__TotalNumSecurityTypes, (void *) &cTotalNumSecurityTypes);
  rb_define_alloc_func(cTotalNumSecurityTypes.klass, _wrap_TotalNumSecurityTypes_allocate);
  rb_define_method(cTotalNumSecurityTypes.klass, "initialize", VALUEFUNC(_wrap_new_TotalNumSecurityTypes), -1);
  cTotalNumSecurityTypes.mark = 0;
  cTotalNumSecurityTypes.destroy = (void (*)(void *)) free_FIX_TotalNumSecurityTypes;
  cTotalNumSecurityTypes.trackObjects = 0;
  
  cLegSettlmntTyp.klass = rb_define_class_under(mQuickfix, "LegSettlmntTyp", ((swig_class *) SWIGTYPE_p_FIX__CharField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__LegSettlmntTyp, (void *) &cLegSettlmntTyp);
  rb_define_alloc_func(cLegSettlmntTyp.klass, _wrap_LegSettlmntTyp_allocate);
  rb_define_method(cLegSettlmntTyp.klass, "initialize", VALUEFUNC(_wrap_new_LegSettlmntTyp), -1);
  cLegSettlmntTyp.mark = 0;
  cLegSettlmntTyp.destroy = (void (*)(void *)) free_FIX_LegSettlmntTyp;
  cLegSettlmntTyp.trackObjects = 0;
  
  cLegFutSettDate.klass = rb_define_class_under(mQuickfix, "LegFutSettDate", ((swig_class *) SWIGTYPE_p_FIX__StringField->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__LegFutSettDate, (void *) &cLegFutSettDate);
  rb_define_alloc_func(cLegFutSettDate.klass, _wrap_LegFutSettDate_allocate);
  rb_define_method(cLegFutSettDate.klass, "initialize", VALUEFUNC(_wrap_new_LegFutSettDate), -1);
  cLegFutSettDate.mark = 0;
  cLegFutSettDate.destroy = (void (*)(void *)) free_FIX_LegFutSettDate;
  cLegFutSettDate.trackObjects = 0;
  rb_define_singleton_method(mQuickfix, "BeginString_FIX44", VALUEFUNC(_wrap_BeginString_FIX44_get), 0);
  rb_define_singleton_method(mQuickfix, "BeginString_FIX43", VALUEFUNC(_wrap_BeginString_FIX43_get), 0);
  rb_define_singleton_method(mQuickfix, "BeginString_FIX42", VALUEFUNC(_wrap_BeginString_FIX42_get), 0);
  rb_define_singleton_method(mQuickfix, "BeginString_FIX41", VALUEFUNC(_wrap_BeginString_FIX41_get), 0);
  rb_define_singleton_method(mQuickfix, "BeginString_FIX40", VALUEFUNC(_wrap_BeginString_FIX40_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Heartbeat", VALUEFUNC(_wrap_MsgType_Heartbeat_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Logon", VALUEFUNC(_wrap_MsgType_Logon_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TestRequest", VALUEFUNC(_wrap_MsgType_TestRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ResendRequest", VALUEFUNC(_wrap_MsgType_ResendRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Reject", VALUEFUNC(_wrap_MsgType_Reject_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SequenceReset", VALUEFUNC(_wrap_MsgType_SequenceReset_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Logout", VALUEFUNC(_wrap_MsgType_Logout_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_BusinessMessageReject", VALUEFUNC(_wrap_MsgType_BusinessMessageReject_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_UserRequest", VALUEFUNC(_wrap_MsgType_UserRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_UserResponse", VALUEFUNC(_wrap_MsgType_UserResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Advertisement", VALUEFUNC(_wrap_MsgType_Advertisement_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_IndicationOfInterest", VALUEFUNC(_wrap_MsgType_IndicationOfInterest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_News", VALUEFUNC(_wrap_MsgType_News_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Email", VALUEFUNC(_wrap_MsgType_Email_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteRequest", VALUEFUNC(_wrap_MsgType_QuoteRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteResponse", VALUEFUNC(_wrap_MsgType_QuoteResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteRequestReject", VALUEFUNC(_wrap_MsgType_QuoteRequestReject_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RFQRequest", VALUEFUNC(_wrap_MsgType_RFQRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Quote", VALUEFUNC(_wrap_MsgType_Quote_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteCancel", VALUEFUNC(_wrap_MsgType_QuoteCancel_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteStatusRequest", VALUEFUNC(_wrap_MsgType_QuoteStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QuoteStatusReport", VALUEFUNC(_wrap_MsgType_QuoteStatusReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MassQuote", VALUEFUNC(_wrap_MsgType_MassQuote_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MassQuoteAcknowledgement", VALUEFUNC(_wrap_MsgType_MassQuoteAcknowledgement_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataRequest", VALUEFUNC(_wrap_MsgType_MarketDataRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataSnapshotFullRefresh", VALUEFUNC(_wrap_MsgType_MarketDataSnapshotFullRefresh_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataIncrementalRefresh", VALUEFUNC(_wrap_MsgType_MarketDataIncrementalRefresh_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MarketDataRequestReject", VALUEFUNC(_wrap_MsgType_MarketDataRequestReject_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityDefinitionRequest", VALUEFUNC(_wrap_MsgType_SecurityDefinitionRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityDefinition", VALUEFUNC(_wrap_MsgType_SecurityDefinition_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityTypeRequest", VALUEFUNC(_wrap_MsgType_SecurityTypeRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityTypes", VALUEFUNC(_wrap_MsgType_SecurityTypes_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityListRequest", VALUEFUNC(_wrap_MsgType_SecurityListRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityList", VALUEFUNC(_wrap_MsgType_SecurityList_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_DerivativeSecurityListRequest", VALUEFUNC(_wrap_MsgType_DerivativeSecurityListRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_DerivativeSecurityList", VALUEFUNC(_wrap_MsgType_DerivativeSecurityList_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityStatusRequest", VALUEFUNC(_wrap_MsgType_SecurityStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SecurityStatus", VALUEFUNC(_wrap_MsgType_SecurityStatus_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradingSessionStatusRequest", VALUEFUNC(_wrap_MsgType_TradingSessionStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradingSessionStatus", VALUEFUNC(_wrap_MsgType_TradingSessionStatus_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NewOrderSingle", VALUEFUNC(_wrap_MsgType_NewOrderSingle_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ExecutionReport", VALUEFUNC(_wrap_MsgType_ExecutionReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_DontKnowTrade", VALUEFUNC(_wrap_MsgType_DontKnowTrade_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderCancelReplaceRequest", VALUEFUNC(_wrap_MsgType_OrderCancelReplaceRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderCancelRequest", VALUEFUNC(_wrap_MsgType_OrderCancelRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderCancelReject", VALUEFUNC(_wrap_MsgType_OrderCancelReject_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderStatusRequest", VALUEFUNC(_wrap_MsgType_OrderStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderMassCancelRequest", VALUEFUNC(_wrap_MsgType_OrderMassCancelRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderMassCancelReport", VALUEFUNC(_wrap_MsgType_OrderMassCancelReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_OrderMassStatusRequest", VALUEFUNC(_wrap_MsgType_OrderMassStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NewOrderCross", VALUEFUNC(_wrap_MsgType_NewOrderCross_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CrossOrderCancelReplaceRequest", VALUEFUNC(_wrap_MsgType_CrossOrderCancelReplaceRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CrossOrderCancelRequest", VALUEFUNC(_wrap_MsgType_CrossOrderCancelRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NewOrderMultileg", VALUEFUNC(_wrap_MsgType_NewOrderMultileg_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MultilegOrderCancelReplaceRequest", VALUEFUNC(_wrap_MsgType_MultilegOrderCancelReplaceRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_BidRequest", VALUEFUNC(_wrap_MsgType_BidRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_BidResponse", VALUEFUNC(_wrap_MsgType_BidResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NewOrderList", VALUEFUNC(_wrap_MsgType_NewOrderList_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ListStrikePrice", VALUEFUNC(_wrap_MsgType_ListStrikePrice_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ListStatus", VALUEFUNC(_wrap_MsgType_ListStatus_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ListExecute", VALUEFUNC(_wrap_MsgType_ListExecute_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ListCancelRequest", VALUEFUNC(_wrap_MsgType_ListCancelRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ListStatusRequest", VALUEFUNC(_wrap_MsgType_ListStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationInstruction", VALUEFUNC(_wrap_MsgType_AllocationInstruction_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationInstructionAck", VALUEFUNC(_wrap_MsgType_AllocationInstructionAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationReport", VALUEFUNC(_wrap_MsgType_AllocationReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AllocationReportAck", VALUEFUNC(_wrap_MsgType_AllocationReportAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_Confirmation", VALUEFUNC(_wrap_MsgType_Confirmation_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ConfirmationAck", VALUEFUNC(_wrap_MsgType_ConfirmationAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ConfirmationRequest", VALUEFUNC(_wrap_MsgType_ConfirmationRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SettlementInstructions", VALUEFUNC(_wrap_MsgType_SettlementInstructions_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SettlementInstructionRequest", VALUEFUNC(_wrap_MsgType_SettlementInstructionRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeCaptureReportRequest", VALUEFUNC(_wrap_MsgType_TradeCaptureReportRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeCaptureReportRequestAck", VALUEFUNC(_wrap_MsgType_TradeCaptureReportRequestAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeCaptureReport", VALUEFUNC(_wrap_MsgType_TradeCaptureReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TradeCaptureReportAck", VALUEFUNC(_wrap_MsgType_TradeCaptureReportAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RegistrationInstructions", VALUEFUNC(_wrap_MsgType_RegistrationInstructions_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RegistrationInstructionsResponse", VALUEFUNC(_wrap_MsgType_RegistrationInstructionsResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PositionMaintenanceRequest", VALUEFUNC(_wrap_MsgType_PositionMaintenanceRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PositionMaintenanceReport", VALUEFUNC(_wrap_MsgType_PositionMaintenanceReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RequestForPositions", VALUEFUNC(_wrap_MsgType_RequestForPositions_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RequestForPositionsAck", VALUEFUNC(_wrap_MsgType_RequestForPositionsAck_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_PositionReport", VALUEFUNC(_wrap_MsgType_PositionReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_AssignmentReport", VALUEFUNC(_wrap_MsgType_AssignmentReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralRequest", VALUEFUNC(_wrap_MsgType_CollateralRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralAssignment", VALUEFUNC(_wrap_MsgType_CollateralAssignment_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralResponse", VALUEFUNC(_wrap_MsgType_CollateralResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralReport", VALUEFUNC(_wrap_MsgType_CollateralReport_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralInquiry", VALUEFUNC(_wrap_MsgType_CollateralInquiry_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NetworkStatusRequest", VALUEFUNC(_wrap_MsgType_NetworkStatusRequest_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NetworkStatusResponse", VALUEFUNC(_wrap_MsgType_NetworkStatusResponse_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CollateralInquiryAck", VALUEFUNC(_wrap_MsgType_CollateralInquiryAck_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvSide_BUY", VALUEFUNC(_wrap_AdvSide_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvSide_SELL", VALUEFUNC(_wrap_AdvSide_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvSide_CROSS", VALUEFUNC(_wrap_AdvSide_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvSide_TRADE", VALUEFUNC(_wrap_AdvSide_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvTransType_NEW", VALUEFUNC(_wrap_AdvTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvTransType_CANCEL", VALUEFUNC(_wrap_AdvTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "AdvTransType_REPLACE", VALUEFUNC(_wrap_AdvTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_PER_UNIT", VALUEFUNC(_wrap_CommType_PER_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_PERCENTAGE", VALUEFUNC(_wrap_CommType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_ABSOLUTE", VALUEFUNC(_wrap_CommType_ABSOLUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_PERCENTAGE_WAIVED_CASH_DISCOUNT", VALUEFUNC(_wrap_CommType_PERCENTAGE_WAIVED_CASH_DISCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_PERCENTAGE_WAIVED_ENHANCED_UNITS", VALUEFUNC(_wrap_CommType_PERCENTAGE_WAIVED_ENHANCED_UNITS_get), 0);
  rb_define_singleton_method(mQuickfix, "CommType_POINTS_PER_BOND_OR_OR_CONTRACT", VALUEFUNC(_wrap_CommType_POINTS_PER_BOND_OR_OR_CONTRACT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_NOT_HELD", VALUEFUNC(_wrap_ExecInst_NOT_HELD_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_WORK", VALUEFUNC(_wrap_ExecInst_WORK_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_GO_ALONG", VALUEFUNC(_wrap_ExecInst_GO_ALONG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_OVER_THE_DAY", VALUEFUNC(_wrap_ExecInst_OVER_THE_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_HELD", VALUEFUNC(_wrap_ExecInst_HELD_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_PARTICIPATE_DONT_INITIATE", VALUEFUNC(_wrap_ExecInst_PARTICIPATE_DONT_INITIATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_STRICT_SCALE", VALUEFUNC(_wrap_ExecInst_STRICT_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_TRY_TO_SCALE", VALUEFUNC(_wrap_ExecInst_TRY_TO_SCALE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_STAY_ON_BIDSIDE", VALUEFUNC(_wrap_ExecInst_STAY_ON_BIDSIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_STAY_ON_OFFERSIDE", VALUEFUNC(_wrap_ExecInst_STAY_ON_OFFERSIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_NO_CROSS", VALUEFUNC(_wrap_ExecInst_NO_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_OK_TO_CROSS", VALUEFUNC(_wrap_ExecInst_OK_TO_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CALL_FIRST", VALUEFUNC(_wrap_ExecInst_CALL_FIRST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_PERCENT_OF_VOLUME", VALUEFUNC(_wrap_ExecInst_PERCENT_OF_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_DO_NOT_INCREASE", VALUEFUNC(_wrap_ExecInst_DO_NOT_INCREASE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_DO_NOT_REDUCE", VALUEFUNC(_wrap_ExecInst_DO_NOT_REDUCE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_ALL_OR_NONE", VALUEFUNC(_wrap_ExecInst_ALL_OR_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_REINSTATE_ON_SYSTEM_FAILURE", VALUEFUNC(_wrap_ExecInst_REINSTATE_ON_SYSTEM_FAILURE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_INSTITUTIONS_ONLY", VALUEFUNC(_wrap_ExecInst_INSTITUTIONS_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_REINSTATE_ON_TRADING_HALT", VALUEFUNC(_wrap_ExecInst_REINSTATE_ON_TRADING_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CANCEL_ON_TRADING_HALT", VALUEFUNC(_wrap_ExecInst_CANCEL_ON_TRADING_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_LAST_PEG", VALUEFUNC(_wrap_ExecInst_LAST_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_MID_PRICE", VALUEFUNC(_wrap_ExecInst_MID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_NON_NEGOTIABLE", VALUEFUNC(_wrap_ExecInst_NON_NEGOTIABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_OPENING_PEG", VALUEFUNC(_wrap_ExecInst_OPENING_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_MARKET_PEG", VALUEFUNC(_wrap_ExecInst_MARKET_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CANCEL_ON_SYSTEM_FAILURE", VALUEFUNC(_wrap_ExecInst_CANCEL_ON_SYSTEM_FAILURE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_PRIMARY_PEG", VALUEFUNC(_wrap_ExecInst_PRIMARY_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_SUSPEND", VALUEFUNC(_wrap_ExecInst_SUSPEND_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER", VALUEFUNC(_wrap_ExecInst_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CUSTOMER_DISPLAY_INSTRUCTION", VALUEFUNC(_wrap_ExecInst_CUSTOMER_DISPLAY_INSTRUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_NETTING", VALUEFUNC(_wrap_ExecInst_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_PEG_TO_VWAP", VALUEFUNC(_wrap_ExecInst_PEG_TO_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_TRADE_ALONG", VALUEFUNC(_wrap_ExecInst_TRADE_ALONG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_TRY_TO_STOP", VALUEFUNC(_wrap_ExecInst_TRY_TO_STOP_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_CANCEL_IF_NOT_BEST", VALUEFUNC(_wrap_ExecInst_CANCEL_IF_NOT_BEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_TRAILING_STOP_PEG", VALUEFUNC(_wrap_ExecInst_TRAILING_STOP_PEG_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_STRICT_LIMIT", VALUEFUNC(_wrap_ExecInst_STRICT_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_IGNORE_PRICE_VALIDITY_CHECKS", VALUEFUNC(_wrap_ExecInst_IGNORE_PRICE_VALIDITY_CHECKS_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_PEG_TO_LIMIT_PRICE", VALUEFUNC(_wrap_ExecInst_PEG_TO_LIMIT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecInst_WORK_TO_TARGET_STRATEGY", VALUEFUNC(_wrap_ExecInst_WORK_TO_TARGET_STRATEGY_get), 0);
  rb_define_singleton_method(mQuickfix, "HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE", VALUEFUNC(_wrap_HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE_get), 0);
  rb_define_singleton_method(mQuickfix, "HandlInst_AUTOMATED_EXECUTION_ORDER_PUBLIC", VALUEFUNC(_wrap_HandlInst_AUTOMATED_EXECUTION_ORDER_PUBLIC_get), 0);
  rb_define_singleton_method(mQuickfix, "HandlInst_MANUAL_ORDER", VALUEFUNC(_wrap_HandlInst_MANUAL_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_CUSIP", VALUEFUNC(_wrap_SecurityIDSource_CUSIP_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_SEDOL", VALUEFUNC(_wrap_SecurityIDSource_SEDOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_QUIK", VALUEFUNC(_wrap_SecurityIDSource_QUIK_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_ISIN_NUMBER", VALUEFUNC(_wrap_SecurityIDSource_ISIN_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_RIC_CODE", VALUEFUNC(_wrap_SecurityIDSource_RIC_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_ISO_CURRENCY_CODE", VALUEFUNC(_wrap_SecurityIDSource_ISO_CURRENCY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_ISO_COUNTRY_CODE", VALUEFUNC(_wrap_SecurityIDSource_ISO_COUNTRY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_EXCHANGE_SYMBOL", VALUEFUNC(_wrap_SecurityIDSource_EXCHANGE_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_CONSOLIDATED_TAPE_ASSOCIATION", VALUEFUNC(_wrap_SecurityIDSource_CONSOLIDATED_TAPE_ASSOCIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_BLOOMBERG_SYMBOL", VALUEFUNC(_wrap_SecurityIDSource_BLOOMBERG_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_WERTPAPIER", VALUEFUNC(_wrap_SecurityIDSource_WERTPAPIER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_DUTCH", VALUEFUNC(_wrap_SecurityIDSource_DUTCH_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_VALOREN", VALUEFUNC(_wrap_SecurityIDSource_VALOREN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_SICOVAM", VALUEFUNC(_wrap_SecurityIDSource_SICOVAM_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_BELGIAN", VALUEFUNC(_wrap_SecurityIDSource_BELGIAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_COMMON", VALUEFUNC(_wrap_SecurityIDSource_COMMON_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_CLEARING_HOUSE_CLEARING_ORGANIZATION", VALUEFUNC(_wrap_SecurityIDSource_CLEARING_HOUSE_CLEARING_ORGANIZATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_ISDA_FPML_PRODUCT_SPECIFICATION", VALUEFUNC(_wrap_SecurityIDSource_ISDA_FPML_PRODUCT_SPECIFICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityIDSource_OPTIONS_PRICE_REPORTING_AUTHORITY", VALUEFUNC(_wrap_SecurityIDSource_OPTIONS_PRICE_REPORTING_AUTHORITY_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQltyInd_LOW", VALUEFUNC(_wrap_IOIQltyInd_LOW_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQltyInd_MEDIUM", VALUEFUNC(_wrap_IOIQltyInd_MEDIUM_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQltyInd_HIGH", VALUEFUNC(_wrap_IOIQltyInd_HIGH_get), 0);
  rb_define_singleton_method(mQuickfix, "IOITransType_NEW", VALUEFUNC(_wrap_IOITransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "IOITransType_CANCEL", VALUEFUNC(_wrap_IOITransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "IOITransType_REPLACE", VALUEFUNC(_wrap_IOITransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "LastCapacity_AGENT", VALUEFUNC(_wrap_LastCapacity_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "LastCapacity_CROSS_AS_AGENT", VALUEFUNC(_wrap_LastCapacity_CROSS_AS_AGENT_get), 0);
  rb_define_singleton_method(mQuickfix, "LastCapacity_CROSS_AS_PRINCIPAL", VALUEFUNC(_wrap_LastCapacity_CROSS_AS_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "LastCapacity_PRINCIPAL", VALUEFUNC(_wrap_LastCapacity_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_HEARTBEAT", VALUEFUNC(_wrap_MsgType_HEARTBEAT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TEST_REQUEST", VALUEFUNC(_wrap_MsgType_TEST_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RESEND_REQUEST", VALUEFUNC(_wrap_MsgType_RESEND_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_REJECT", VALUEFUNC(_wrap_MsgType_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SEQUENCE_RESET", VALUEFUNC(_wrap_MsgType_SEQUENCE_RESET_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_LOGOUT", VALUEFUNC(_wrap_MsgType_LOGOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_INDICATION_OF_INTEREST", VALUEFUNC(_wrap_MsgType_INDICATION_OF_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ADVERTISEMENT", VALUEFUNC(_wrap_MsgType_ADVERTISEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_EXECUTION_REPORT", VALUEFUNC(_wrap_MsgType_EXECUTION_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ORDER_CANCEL_REJECT", VALUEFUNC(_wrap_MsgType_ORDER_CANCEL_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_LOGON", VALUEFUNC(_wrap_MsgType_LOGON_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NEWS", VALUEFUNC(_wrap_MsgType_NEWS_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_EMAIL", VALUEFUNC(_wrap_MsgType_EMAIL_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ORDER_SINGLE", VALUEFUNC(_wrap_MsgType_ORDER_SINGLE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ORDER_LIST", VALUEFUNC(_wrap_MsgType_ORDER_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ORDER_CANCEL_REQUEST", VALUEFUNC(_wrap_MsgType_ORDER_CANCEL_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ORDER_CANCEL_REPLACE_REQUEST", VALUEFUNC(_wrap_MsgType_ORDER_CANCEL_REPLACE_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ORDER_STATUS_REQUEST", VALUEFUNC(_wrap_MsgType_ORDER_STATUS_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ALLOCATION_INSTRUCTION", VALUEFUNC(_wrap_MsgType_ALLOCATION_INSTRUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_LIST_CANCEL_REQUEST", VALUEFUNC(_wrap_MsgType_LIST_CANCEL_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_LIST_EXECUTE", VALUEFUNC(_wrap_MsgType_LIST_EXECUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_LIST_STATUS_REQUEST", VALUEFUNC(_wrap_MsgType_LIST_STATUS_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_LIST_STATUS", VALUEFUNC(_wrap_MsgType_LIST_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ALLOCATION_INSTRUCTION_ACK", VALUEFUNC(_wrap_MsgType_ALLOCATION_INSTRUCTION_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_DONT_KNOW_TRADE", VALUEFUNC(_wrap_MsgType_DONT_KNOW_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QUOTE_REQUEST", VALUEFUNC(_wrap_MsgType_QUOTE_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QUOTE", VALUEFUNC(_wrap_MsgType_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SETTLEMENT_INSTRUCTIONS", VALUEFUNC(_wrap_MsgType_SETTLEMENT_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MARKET_DATA_REQUEST", VALUEFUNC(_wrap_MsgType_MARKET_DATA_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MARKET_DATA_SNAPSHOT_FULL_REFRESH", VALUEFUNC(_wrap_MsgType_MARKET_DATA_SNAPSHOT_FULL_REFRESH_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MARKET_DATA_INCREMENTAL_REFRESH", VALUEFUNC(_wrap_MsgType_MARKET_DATA_INCREMENTAL_REFRESH_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MARKET_DATA_REQUEST_REJECT", VALUEFUNC(_wrap_MsgType_MARKET_DATA_REQUEST_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QUOTE_CANCEL", VALUEFUNC(_wrap_MsgType_QUOTE_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QUOTE_STATUS_REQUEST", VALUEFUNC(_wrap_MsgType_QUOTE_STATUS_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MASS_QUOTE_ACKNOWLEDGEMENT", VALUEFUNC(_wrap_MsgType_MASS_QUOTE_ACKNOWLEDGEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SECURITY_DEFINITION_REQUEST", VALUEFUNC(_wrap_MsgType_SECURITY_DEFINITION_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SECURITY_DEFINITION", VALUEFUNC(_wrap_MsgType_SECURITY_DEFINITION_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SECURITY_STATUS_REQUEST", VALUEFUNC(_wrap_MsgType_SECURITY_STATUS_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SECURITY_STATUS", VALUEFUNC(_wrap_MsgType_SECURITY_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TRADING_SESSION_STATUS_REQUEST", VALUEFUNC(_wrap_MsgType_TRADING_SESSION_STATUS_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TRADING_SESSION_STATUS", VALUEFUNC(_wrap_MsgType_TRADING_SESSION_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MASS_QUOTE", VALUEFUNC(_wrap_MsgType_MASS_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_BUSINESS_MESSAGE_REJECT", VALUEFUNC(_wrap_MsgType_BUSINESS_MESSAGE_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_BID_REQUEST", VALUEFUNC(_wrap_MsgType_BID_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_BID_RESPONSE", VALUEFUNC(_wrap_MsgType_BID_RESPONSE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_LIST_STRIKE_PRICE", VALUEFUNC(_wrap_MsgType_LIST_STRIKE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_XML_MESSAGE", VALUEFUNC(_wrap_MsgType_XML_MESSAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_REGISTRATION_INSTRUCTIONS", VALUEFUNC(_wrap_MsgType_REGISTRATION_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_REGISTRATION_INSTRUCTIONS_RESPONSE", VALUEFUNC(_wrap_MsgType_REGISTRATION_INSTRUCTIONS_RESPONSE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ORDER_MASS_CANCEL_REQUEST", VALUEFUNC(_wrap_MsgType_ORDER_MASS_CANCEL_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ORDER_MASS_CANCEL_REPORT", VALUEFUNC(_wrap_MsgType_ORDER_MASS_CANCEL_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NEW_ORDER_CROSS", VALUEFUNC(_wrap_MsgType_NEW_ORDER_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CROSS_ORDER_CANCEL_REPLACE_REQUEST", VALUEFUNC(_wrap_MsgType_CROSS_ORDER_CANCEL_REPLACE_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CROSS_ORDER_CANCEL_REQUEST", VALUEFUNC(_wrap_MsgType_CROSS_ORDER_CANCEL_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SECURITY_TYPE_REQUEST", VALUEFUNC(_wrap_MsgType_SECURITY_TYPE_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SECURITY_TYPES", VALUEFUNC(_wrap_MsgType_SECURITY_TYPES_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SECURITY_LIST_REQUEST", VALUEFUNC(_wrap_MsgType_SECURITY_LIST_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SECURITY_LIST", VALUEFUNC(_wrap_MsgType_SECURITY_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_DERIVATIVE_SECURITY_LIST_REQUEST", VALUEFUNC(_wrap_MsgType_DERIVATIVE_SECURITY_LIST_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_DERIVATIVE_SECURITY_LIST", VALUEFUNC(_wrap_MsgType_DERIVATIVE_SECURITY_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NEW_ORDER_MULTILEG", VALUEFUNC(_wrap_MsgType_NEW_ORDER_MULTILEG_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_MULTILEG_ORDER_CANCEL_REPLACE", VALUEFUNC(_wrap_MsgType_MULTILEG_ORDER_CANCEL_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TRADE_CAPTURE_REPORT_REQUEST", VALUEFUNC(_wrap_MsgType_TRADE_CAPTURE_REPORT_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TRADE_CAPTURE_REPORT", VALUEFUNC(_wrap_MsgType_TRADE_CAPTURE_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ORDER_MASS_STATUS_REQUEST", VALUEFUNC(_wrap_MsgType_ORDER_MASS_STATUS_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QUOTE_REQUEST_REJECT", VALUEFUNC(_wrap_MsgType_QUOTE_REQUEST_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_RFQ_REQUEST", VALUEFUNC(_wrap_MsgType_RFQ_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QUOTE_STATUS_REPORT", VALUEFUNC(_wrap_MsgType_QUOTE_STATUS_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_QUOTE_RESPONSE", VALUEFUNC(_wrap_MsgType_QUOTE_RESPONSE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CONFIRMATION", VALUEFUNC(_wrap_MsgType_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_POSITION_MAINTENANCE_REQUEST", VALUEFUNC(_wrap_MsgType_POSITION_MAINTENANCE_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_POSITION_MAINTENANCE_REPORT", VALUEFUNC(_wrap_MsgType_POSITION_MAINTENANCE_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_REQUEST_FOR_POSITIONS", VALUEFUNC(_wrap_MsgType_REQUEST_FOR_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_REQUEST_FOR_POSITIONS_ACK", VALUEFUNC(_wrap_MsgType_REQUEST_FOR_POSITIONS_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_POSITION_REPORT", VALUEFUNC(_wrap_MsgType_POSITION_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TRADE_CAPTURE_REPORT_REQUEST_ACK", VALUEFUNC(_wrap_MsgType_TRADE_CAPTURE_REPORT_REQUEST_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_TRADE_CAPTURE_REPORT_ACK", VALUEFUNC(_wrap_MsgType_TRADE_CAPTURE_REPORT_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ALLOCATION_REPORT", VALUEFUNC(_wrap_MsgType_ALLOCATION_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ALLOCATION_REPORT_ACK", VALUEFUNC(_wrap_MsgType_ALLOCATION_REPORT_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CONFIRMATION_ACK", VALUEFUNC(_wrap_MsgType_CONFIRMATION_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_SETTLEMENT_INSTRUCTION_REQUEST", VALUEFUNC(_wrap_MsgType_SETTLEMENT_INSTRUCTION_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_ASSIGNMENT_REPORT", VALUEFUNC(_wrap_MsgType_ASSIGNMENT_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_COLLATERAL_REQUEST", VALUEFUNC(_wrap_MsgType_COLLATERAL_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_COLLATERAL_ASSIGNMENT", VALUEFUNC(_wrap_MsgType_COLLATERAL_ASSIGNMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_COLLATERAL_RESPONSE", VALUEFUNC(_wrap_MsgType_COLLATERAL_RESPONSE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_COLLATERAL_REPORT", VALUEFUNC(_wrap_MsgType_COLLATERAL_REPORT_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_COLLATERAL_INQUIRY", VALUEFUNC(_wrap_MsgType_COLLATERAL_INQUIRY_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NETWORK_STATUS_REQUEST", VALUEFUNC(_wrap_MsgType_NETWORK_STATUS_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_NETWORK_STATUS_RESPONSE", VALUEFUNC(_wrap_MsgType_NETWORK_STATUS_RESPONSE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_USER_REQUEST", VALUEFUNC(_wrap_MsgType_USER_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_USER_RESPONSE", VALUEFUNC(_wrap_MsgType_USER_RESPONSE_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_COLLATERAL_INQUIRY_ACK", VALUEFUNC(_wrap_MsgType_COLLATERAL_INQUIRY_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgType_CONFIRMATION_REQUEST", VALUEFUNC(_wrap_MsgType_CONFIRMATION_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_NEW", VALUEFUNC(_wrap_OrdStatus_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_PARTIALLY_FILLED", VALUEFUNC(_wrap_OrdStatus_PARTIALLY_FILLED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_FILLED", VALUEFUNC(_wrap_OrdStatus_FILLED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_DONE_FOR_DAY", VALUEFUNC(_wrap_OrdStatus_DONE_FOR_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_CANCELED", VALUEFUNC(_wrap_OrdStatus_CANCELED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_REPLACED", VALUEFUNC(_wrap_OrdStatus_REPLACED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_PENDING_CANCEL", VALUEFUNC(_wrap_OrdStatus_PENDING_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_STOPPED", VALUEFUNC(_wrap_OrdStatus_STOPPED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_REJECTED", VALUEFUNC(_wrap_OrdStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_SUSPENDED", VALUEFUNC(_wrap_OrdStatus_SUSPENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_PENDING_NEW", VALUEFUNC(_wrap_OrdStatus_PENDING_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_CALCULATED", VALUEFUNC(_wrap_OrdStatus_CALCULATED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_EXPIRED", VALUEFUNC(_wrap_OrdStatus_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_ACCEPTED_FOR_BIDDING", VALUEFUNC(_wrap_OrdStatus_ACCEPTED_FOR_BIDDING_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdStatus_PENDING_REPLACE", VALUEFUNC(_wrap_OrdStatus_PENDING_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_MARKET", VALUEFUNC(_wrap_OrdType_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_LIMIT", VALUEFUNC(_wrap_OrdType_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_STOP", VALUEFUNC(_wrap_OrdType_STOP_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_STOP_LIMIT", VALUEFUNC(_wrap_OrdType_STOP_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_MARKET_ON_CLOSE", VALUEFUNC(_wrap_OrdType_MARKET_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_WITH_OR_WITHOUT", VALUEFUNC(_wrap_OrdType_WITH_OR_WITHOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_LIMIT_OR_BETTER", VALUEFUNC(_wrap_OrdType_LIMIT_OR_BETTER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_LIMIT_WITH_OR_WITHOUT", VALUEFUNC(_wrap_OrdType_LIMIT_WITH_OR_WITHOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_ON_BASIS", VALUEFUNC(_wrap_OrdType_ON_BASIS_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_ON_CLOSE", VALUEFUNC(_wrap_OrdType_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_LIMIT_ON_CLOSE", VALUEFUNC(_wrap_OrdType_LIMIT_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_FOREX_MARKET", VALUEFUNC(_wrap_OrdType_FOREX_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_PREVIOUSLY_QUOTED", VALUEFUNC(_wrap_OrdType_PREVIOUSLY_QUOTED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_PREVIOUSLY_INDICATED", VALUEFUNC(_wrap_OrdType_PREVIOUSLY_INDICATED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_FOREX_LIMIT", VALUEFUNC(_wrap_OrdType_FOREX_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_FOREX_SWAP", VALUEFUNC(_wrap_OrdType_FOREX_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_FOREX_PREVIOUSLY_QUOTED", VALUEFUNC(_wrap_OrdType_FOREX_PREVIOUSLY_QUOTED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_FUNARI", VALUEFUNC(_wrap_OrdType_FUNARI_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_MARKET_IF_TOUCHED", VALUEFUNC(_wrap_OrdType_MARKET_IF_TOUCHED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_MARKET_WITH_LEFTOVER_AS_LIMIT", VALUEFUNC(_wrap_OrdType_MARKET_WITH_LEFTOVER_AS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_PREVIOUS_FUND_VALUATION_POINT", VALUEFUNC(_wrap_OrdType_PREVIOUS_FUND_VALUATION_POINT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_NEXT_FUND_VALUATION_POINT", VALUEFUNC(_wrap_OrdType_NEXT_FUND_VALUATION_POINT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdType_PEGGED", VALUEFUNC(_wrap_OrdType_PEGGED_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_BUY", VALUEFUNC(_wrap_Side_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SELL", VALUEFUNC(_wrap_Side_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_BUY_MINUS", VALUEFUNC(_wrap_Side_BUY_MINUS_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SELL_PLUS", VALUEFUNC(_wrap_Side_SELL_PLUS_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SELL_SHORT", VALUEFUNC(_wrap_Side_SELL_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SELL_SHORT_EXEMPT", VALUEFUNC(_wrap_Side_SELL_SHORT_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_UNDISCLOSED", VALUEFUNC(_wrap_Side_UNDISCLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_CROSS", VALUEFUNC(_wrap_Side_CROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_CROSS_SHORT", VALUEFUNC(_wrap_Side_CROSS_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_CROSS_SHORT_EXEMPT", VALUEFUNC(_wrap_Side_CROSS_SHORT_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_AS_DEFINED", VALUEFUNC(_wrap_Side_AS_DEFINED_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_OPPOSITE", VALUEFUNC(_wrap_Side_OPPOSITE_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_SUBSCRIBE", VALUEFUNC(_wrap_Side_SUBSCRIBE_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_REDEEM", VALUEFUNC(_wrap_Side_REDEEM_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_LEND", VALUEFUNC(_wrap_Side_LEND_get), 0);
  rb_define_singleton_method(mQuickfix, "Side_BORROW", VALUEFUNC(_wrap_Side_BORROW_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_DAY", VALUEFUNC(_wrap_TimeInForce_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_GOOD_TILL_CANCEL", VALUEFUNC(_wrap_TimeInForce_GOOD_TILL_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_AT_THE_OPENING", VALUEFUNC(_wrap_TimeInForce_AT_THE_OPENING_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_IMMEDIATE_OR_CANCEL", VALUEFUNC(_wrap_TimeInForce_IMMEDIATE_OR_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_FILL_OR_KILL", VALUEFUNC(_wrap_TimeInForce_FILL_OR_KILL_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_GOOD_TILL_CROSSING", VALUEFUNC(_wrap_TimeInForce_GOOD_TILL_CROSSING_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_GOOD_TILL_DATE", VALUEFUNC(_wrap_TimeInForce_GOOD_TILL_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "TimeInForce_AT_THE_CLOSE", VALUEFUNC(_wrap_TimeInForce_AT_THE_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "Urgency_NORMAL", VALUEFUNC(_wrap_Urgency_NORMAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Urgency_FLASH", VALUEFUNC(_wrap_Urgency_FLASH_get), 0);
  rb_define_singleton_method(mQuickfix, "Urgency_BACKGROUND", VALUEFUNC(_wrap_Urgency_BACKGROUND_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_REGULAR", VALUEFUNC(_wrap_SettlType_REGULAR_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_CASH", VALUEFUNC(_wrap_SettlType_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_NEXT_DAY", VALUEFUNC(_wrap_SettlType_NEXT_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_T_PLUS_2", VALUEFUNC(_wrap_SettlType_T_PLUS_2_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_T_PLUS_3", VALUEFUNC(_wrap_SettlType_T_PLUS_3_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_T_PLUS_4", VALUEFUNC(_wrap_SettlType_T_PLUS_4_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_FUTURE", VALUEFUNC(_wrap_SettlType_FUTURE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_WHEN_AND_IF_ISSUED", VALUEFUNC(_wrap_SettlType_WHEN_AND_IF_ISSUED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_SELLERS_OPTION", VALUEFUNC(_wrap_SettlType_SELLERS_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlType_T_PLUS_5", VALUEFUNC(_wrap_SettlType_T_PLUS_5_get), 0);
  rb_define_singleton_method(mQuickfix, "SymbolSfx_WHEN_ISSUED", VALUEFUNC(_wrap_SymbolSfx_WHEN_ISSUED_get), 0);
  rb_define_singleton_method(mQuickfix, "SymbolSfx_A_EUCP_WITH_LUMP_SUM_INTEREST", VALUEFUNC(_wrap_SymbolSfx_A_EUCP_WITH_LUMP_SUM_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocTransType_NEW", VALUEFUNC(_wrap_AllocTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocTransType_REPLACE", VALUEFUNC(_wrap_AllocTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocTransType_CANCEL", VALUEFUNC(_wrap_AllocTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionEffect_OPEN", VALUEFUNC(_wrap_PositionEffect_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionEffect_CLOSE", VALUEFUNC(_wrap_PositionEffect_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionEffect_ROLLED", VALUEFUNC(_wrap_PositionEffect_ROLLED_get), 0);
  rb_define_singleton_method(mQuickfix, "PositionEffect_FIFO", VALUEFUNC(_wrap_PositionEffect_FIFO_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_REGULAR", VALUEFUNC(_wrap_ProcessCode_REGULAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_SOFT_DOLLAR", VALUEFUNC(_wrap_ProcessCode_SOFT_DOLLAR_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_STEP_IN", VALUEFUNC(_wrap_ProcessCode_STEP_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_STEP_OUT", VALUEFUNC(_wrap_ProcessCode_STEP_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_SOFT_DOLLAR_STEP_IN", VALUEFUNC(_wrap_ProcessCode_SOFT_DOLLAR_STEP_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_SOFT_DOLLAR_STEP_OUT", VALUEFUNC(_wrap_ProcessCode_SOFT_DOLLAR_STEP_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "ProcessCode_PLAN_SPONSOR", VALUEFUNC(_wrap_ProcessCode_PLAN_SPONSOR_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_ACCEPTED", VALUEFUNC(_wrap_AllocStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_BLOCK_LEVEL_REJECT", VALUEFUNC(_wrap_AllocStatus_BLOCK_LEVEL_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_ACCOUNT_LEVEL_REJECT", VALUEFUNC(_wrap_AllocStatus_ACCOUNT_LEVEL_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_RECEIVED", VALUEFUNC(_wrap_AllocStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_INCOMPLETE", VALUEFUNC(_wrap_AllocStatus_INCOMPLETE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocStatus_REJECTED_BY_INTERMEDIARY", VALUEFUNC(_wrap_AllocStatus_REJECTED_BY_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_ACCOUNT", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_QUANTITY", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_AVERAGE_PRICE", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_AVERAGE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_EXECUTING_BROKER_MNEMONIC", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_EXECUTING_BROKER_MNEMONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_COMMISSION_DIFFERENCE", VALUEFUNC(_wrap_AllocRejCode_COMMISSION_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_ORDERID", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_ORDERID_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_UNKNOWN_LISTID", VALUEFUNC(_wrap_AllocRejCode_UNKNOWN_LISTID_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_OTHER", VALUEFUNC(_wrap_AllocRejCode_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_INCORRECT_ALLOCATED_QUANTITY", VALUEFUNC(_wrap_AllocRejCode_INCORRECT_ALLOCATED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocRejCode_CALCULATION_DIFFERENCE", VALUEFUNC(_wrap_AllocRejCode_CALCULATION_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "EmailType_NEW", VALUEFUNC(_wrap_EmailType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "EmailType_REPLY", VALUEFUNC(_wrap_EmailType_REPLY_get), 0);
  rb_define_singleton_method(mQuickfix, "EmailType_ADMIN_REPLY", VALUEFUNC(_wrap_EmailType_ADMIN_REPLY_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_NONE_OTHER", VALUEFUNC(_wrap_EncryptMethod_NONE_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PKCS", VALUEFUNC(_wrap_EncryptMethod_PKCS_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_DES", VALUEFUNC(_wrap_EncryptMethod_DES_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PKCS_DES", VALUEFUNC(_wrap_EncryptMethod_PKCS_DES_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PGP_DES", VALUEFUNC(_wrap_EncryptMethod_PGP_DES_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PGP_DES_MD5", VALUEFUNC(_wrap_EncryptMethod_PGP_DES_MD5_get), 0);
  rb_define_singleton_method(mQuickfix, "EncryptMethod_PEM_DES_MD5", VALUEFUNC(_wrap_EncryptMethod_PEM_DES_MD5_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_TOO_LATE_TO_CANCEL", VALUEFUNC(_wrap_CxlRejReason_TOO_LATE_TO_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_UNKNOWN_ORDER", VALUEFUNC(_wrap_CxlRejReason_UNKNOWN_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_BROKER_EXCHANGE_OPTION", VALUEFUNC(_wrap_CxlRejReason_BROKER_EXCHANGE_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS", VALUEFUNC(_wrap_CxlRejReason_ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST", VALUEFUNC(_wrap_CxlRejReason_UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_ORIGORDMODTIME_DID_NOT_MATCH_LAST_TRANSACTTIME_OF_ORDER", VALUEFUNC(_wrap_CxlRejReason_ORIGORDMODTIME_DID_NOT_MATCH_LAST_TRANSACTTIME_OF_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_DUPLICATE_CLORDID_RECEIVED", VALUEFUNC(_wrap_CxlRejReason_DUPLICATE_CLORDID_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejReason_OTHER", VALUEFUNC(_wrap_CxlRejReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_BROKER_EXCHANGE_OPTION", VALUEFUNC(_wrap_OrdRejReason_BROKER_EXCHANGE_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_OrdRejReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_EXCHANGE_CLOSED", VALUEFUNC(_wrap_OrdRejReason_EXCHANGE_CLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_ORDER_EXCEEDS_LIMIT", VALUEFUNC(_wrap_OrdRejReason_ORDER_EXCEEDS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_TOO_LATE_TO_ENTER", VALUEFUNC(_wrap_OrdRejReason_TOO_LATE_TO_ENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_UNKNOWN_ORDER", VALUEFUNC(_wrap_OrdRejReason_UNKNOWN_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_DUPLICATE_ORDER", VALUEFUNC(_wrap_OrdRejReason_DUPLICATE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER", VALUEFUNC(_wrap_OrdRejReason_DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_STALE_ORDER", VALUEFUNC(_wrap_OrdRejReason_STALE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_TRADE_ALONG_REQUIRED", VALUEFUNC(_wrap_OrdRejReason_TRADE_ALONG_REQUIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_INVALID_INVESTOR_ID", VALUEFUNC(_wrap_OrdRejReason_INVALID_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_UNSUPPORTED_ORDER_CHARACTERISTIC", VALUEFUNC(_wrap_OrdRejReason_UNSUPPORTED_ORDER_CHARACTERISTIC_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_SURVEILLENCE_OPTION", VALUEFUNC(_wrap_OrdRejReason_SURVEILLENCE_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_INCORRECT_QUANTITY", VALUEFUNC(_wrap_OrdRejReason_INCORRECT_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_INCORRECT_ALLOCATED_QUANTITY", VALUEFUNC(_wrap_OrdRejReason_INCORRECT_ALLOCATED_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_UNKNOWN_ACCOUNT", VALUEFUNC(_wrap_OrdRejReason_UNKNOWN_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrdRejReason_OTHER", VALUEFUNC(_wrap_OrdRejReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_ALL_OR_NONE", VALUEFUNC(_wrap_IOIQualifier_ALL_OR_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_MARKET_ON_CLOSE", VALUEFUNC(_wrap_IOIQualifier_MARKET_ON_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AT_THE_CLOSE", VALUEFUNC(_wrap_IOIQualifier_AT_THE_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_VWAP", VALUEFUNC(_wrap_IOIQualifier_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_IN_TOUCH_WITH", VALUEFUNC(_wrap_IOIQualifier_IN_TOUCH_WITH_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_LIMIT", VALUEFUNC(_wrap_IOIQualifier_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_MORE_BEHIND", VALUEFUNC(_wrap_IOIQualifier_MORE_BEHIND_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AT_THE_OPEN", VALUEFUNC(_wrap_IOIQualifier_AT_THE_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_TAKING_A_POSITION", VALUEFUNC(_wrap_IOIQualifier_TAKING_A_POSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AT_THE_MARKET", VALUEFUNC(_wrap_IOIQualifier_AT_THE_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_READY_TO_TRADE", VALUEFUNC(_wrap_IOIQualifier_READY_TO_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_PORTFOLIO_SHOWN", VALUEFUNC(_wrap_IOIQualifier_PORTFOLIO_SHOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_THROUGH_THE_DAY", VALUEFUNC(_wrap_IOIQualifier_THROUGH_THE_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_VERSUS", VALUEFUNC(_wrap_IOIQualifier_VERSUS_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_INDICATION_WORKING_AWAY", VALUEFUNC(_wrap_IOIQualifier_INDICATION_WORKING_AWAY_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_CROSSING_OPPORTUNITY", VALUEFUNC(_wrap_IOIQualifier_CROSSING_OPPORTUNITY_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_AT_THE_MIDPOINT", VALUEFUNC(_wrap_IOIQualifier_AT_THE_MIDPOINT_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIQualifier_PRE_OPEN", VALUEFUNC(_wrap_IOIQualifier_PRE_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_DKReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_WRONG_SIDE", VALUEFUNC(_wrap_DKReason_WRONG_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_QUANTITY_EXCEEDS_ORDER", VALUEFUNC(_wrap_DKReason_QUANTITY_EXCEEDS_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_NO_MATCHING_ORDER", VALUEFUNC(_wrap_DKReason_NO_MATCHING_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_PRICE_EXCEEDS_LIMIT", VALUEFUNC(_wrap_DKReason_PRICE_EXCEEDS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_CALCULATION_DIFFERENCE", VALUEFUNC(_wrap_DKReason_CALCULATION_DIFFERENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "DKReason_OTHER", VALUEFUNC(_wrap_DKReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_REGULATORY", VALUEFUNC(_wrap_MiscFeeType_REGULATORY_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_TAX", VALUEFUNC(_wrap_MiscFeeType_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_LOCAL_COMMISSION", VALUEFUNC(_wrap_MiscFeeType_LOCAL_COMMISSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_EXCHANGE_FEES", VALUEFUNC(_wrap_MiscFeeType_EXCHANGE_FEES_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_STAMP", VALUEFUNC(_wrap_MiscFeeType_STAMP_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_LEVY", VALUEFUNC(_wrap_MiscFeeType_LEVY_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_OTHER", VALUEFUNC(_wrap_MiscFeeType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_MARKUP", VALUEFUNC(_wrap_MiscFeeType_MARKUP_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeType_CONSUMPTION_TAX", VALUEFUNC(_wrap_MiscFeeType_CONSUMPTION_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_NEW", VALUEFUNC(_wrap_ExecType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_PARTIAL_FILL", VALUEFUNC(_wrap_ExecType_PARTIAL_FILL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_FILL", VALUEFUNC(_wrap_ExecType_FILL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_DONE_FOR_DAY", VALUEFUNC(_wrap_ExecType_DONE_FOR_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_CANCELED", VALUEFUNC(_wrap_ExecType_CANCELED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_REPLACE", VALUEFUNC(_wrap_ExecType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_PENDING_CANCEL", VALUEFUNC(_wrap_ExecType_PENDING_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_STOPPED", VALUEFUNC(_wrap_ExecType_STOPPED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_REJECTED", VALUEFUNC(_wrap_ExecType_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_SUSPENDED", VALUEFUNC(_wrap_ExecType_SUSPENDED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_PENDING_NEW", VALUEFUNC(_wrap_ExecType_PENDING_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_CALCULATED", VALUEFUNC(_wrap_ExecType_CALCULATED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_EXPIRED", VALUEFUNC(_wrap_ExecType_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_RESTATED", VALUEFUNC(_wrap_ExecType_RESTATED_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_PENDING_REPLACE", VALUEFUNC(_wrap_ExecType_PENDING_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_TRADE", VALUEFUNC(_wrap_ExecType_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_TRADE_CORRECT", VALUEFUNC(_wrap_ExecType_TRADE_CORRECT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_TRADE_CANCEL", VALUEFUNC(_wrap_ExecType_TRADE_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecType_ORDER_STATUS", VALUEFUNC(_wrap_ExecType_ORDER_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlCurrFxRateCalc_MULTIPLY", VALUEFUNC(_wrap_SettlCurrFxRateCalc_MULTIPLY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlCurrFxRateCalc_DIVIDE", VALUEFUNC(_wrap_SettlCurrFxRateCalc_DIVIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstMode_DEFAULT", VALUEFUNC(_wrap_SettlInstMode_DEFAULT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstMode_STANDING_INSTRUCTIONS_PROVIDED", VALUEFUNC(_wrap_SettlInstMode_STANDING_INSTRUCTIONS_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstMode_SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT", VALUEFUNC(_wrap_SettlInstMode_SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstMode_REQUEST_REJECT", VALUEFUNC(_wrap_SettlInstMode_REQUEST_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstTransType_NEW", VALUEFUNC(_wrap_SettlInstTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstTransType_CANCEL", VALUEFUNC(_wrap_SettlInstTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstTransType_REPLACE", VALUEFUNC(_wrap_SettlInstTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstTransType_RESTATE", VALUEFUNC(_wrap_SettlInstTransType_RESTATE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstSource_BROKERS_INSTRUCTIONS", VALUEFUNC(_wrap_SettlInstSource_BROKERS_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstSource_INSTITUTIONS_INSTRUCTIONS", VALUEFUNC(_wrap_SettlInstSource_INSTITUTIONS_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstSource_INVESTOR", VALUEFUNC(_wrap_SettlInstSource_INVESTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_SUPRANATIONAL_COUPONS", VALUEFUNC(_wrap_SecurityType_EURO_SUPRANATIONAL_COUPONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FEDERAL_AGENCY_COUPON", VALUEFUNC(_wrap_SecurityType_FEDERAL_AGENCY_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FEDERAL_AGENCY_DISCOUNT_NOTE", VALUEFUNC(_wrap_SecurityType_FEDERAL_AGENCY_DISCOUNT_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PRIVATE_EXPORT_FUNDING", VALUEFUNC(_wrap_SecurityType_PRIVATE_EXPORT_FUNDING_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_USD_SUPRANATIONAL_COUPONS", VALUEFUNC(_wrap_SecurityType_USD_SUPRANATIONAL_COUPONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FUTURE", VALUEFUNC(_wrap_SecurityType_FUTURE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OPTION", VALUEFUNC(_wrap_SecurityType_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CORPORATE_BOND", VALUEFUNC(_wrap_SecurityType_CORPORATE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CORPORATE_PRIVATE_PLACEMENT", VALUEFUNC(_wrap_SecurityType_CORPORATE_PRIVATE_PLACEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CONVERTIBLE_BOND", VALUEFUNC(_wrap_SecurityType_CONVERTIBLE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DUAL_CURRENCY", VALUEFUNC(_wrap_SecurityType_DUAL_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_CORPORATE_BOND", VALUEFUNC(_wrap_SecurityType_EURO_CORPORATE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_INDEXED_LINKED", VALUEFUNC(_wrap_SecurityType_INDEXED_LINKED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_STRUCTURED_NOTES", VALUEFUNC(_wrap_SecurityType_STRUCTURED_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_YANKEE_CORPORATE_BOND", VALUEFUNC(_wrap_SecurityType_YANKEE_CORPORATE_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FOREIGN_EXCHANGE_CONTRACT", VALUEFUNC(_wrap_SecurityType_FOREIGN_EXCHANGE_CONTRACT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_COMMON_STOCK", VALUEFUNC(_wrap_SecurityType_COMMON_STOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PREFERRED_STOCK", VALUEFUNC(_wrap_SecurityType_PREFERRED_STOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BRADY_BOND", VALUEFUNC(_wrap_SecurityType_BRADY_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_SOVEREIGNS", VALUEFUNC(_wrap_SecurityType_EURO_SOVEREIGNS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_US_TREASURY_BOND", VALUEFUNC(_wrap_SecurityType_US_TREASURY_BOND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE", VALUEFUNC(_wrap_SecurityType_INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TREASURY_INFLATION_PROTECTED_SECURITIES", VALUEFUNC(_wrap_SecurityType_TREASURY_INFLATION_PROTECTED_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE", VALUEFUNC(_wrap_SecurityType_PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE", VALUEFUNC(_wrap_SecurityType_PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_US_TREASURY_NOTE", VALUEFUNC(_wrap_SecurityType_US_TREASURY_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_US_TREASURY_BILL", VALUEFUNC(_wrap_SecurityType_US_TREASURY_BILL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REPURCHASE", VALUEFUNC(_wrap_SecurityType_REPURCHASE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_FORWARD", VALUEFUNC(_wrap_SecurityType_FORWARD_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BUY_SELLBACK", VALUEFUNC(_wrap_SecurityType_BUY_SELLBACK_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SECURITIES_LOAN", VALUEFUNC(_wrap_SecurityType_SECURITIES_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SECURITIES_PLEDGE", VALUEFUNC(_wrap_SecurityType_SECURITIES_PLEDGE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TERM_LOAN", VALUEFUNC(_wrap_SecurityType_TERM_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REVOLVER_LOAN", VALUEFUNC(_wrap_SecurityType_REVOLVER_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REVOLVER_TERM_LOAN", VALUEFUNC(_wrap_SecurityType_REVOLVER_TERM_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BRIDGE_LOAN", VALUEFUNC(_wrap_SecurityType_BRIDGE_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_LETTER_OF_CREDIT", VALUEFUNC(_wrap_SecurityType_LETTER_OF_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SWING_LINE_FACILITY", VALUEFUNC(_wrap_SecurityType_SWING_LINE_FACILITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DEBTOR_IN_POSSESSION", VALUEFUNC(_wrap_SecurityType_DEBTOR_IN_POSSESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DEFAULTED", VALUEFUNC(_wrap_SecurityType_DEFAULTED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_WITHDRAWN", VALUEFUNC(_wrap_SecurityType_WITHDRAWN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REPLACED", VALUEFUNC(_wrap_SecurityType_REPLACED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MATURED", VALUEFUNC(_wrap_SecurityType_MATURED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_AMENDED_AND_RESTATED", VALUEFUNC(_wrap_SecurityType_AMENDED_AND_RESTATED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_RETIRED", VALUEFUNC(_wrap_SecurityType_RETIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BANKERS_ACCEPTANCE", VALUEFUNC(_wrap_SecurityType_BANKERS_ACCEPTANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BANK_NOTES", VALUEFUNC(_wrap_SecurityType_BANK_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_BILL_OF_EXCHANGES", VALUEFUNC(_wrap_SecurityType_BILL_OF_EXCHANGES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CERTIFICATE_OF_DEPOSIT", VALUEFUNC(_wrap_SecurityType_CERTIFICATE_OF_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CALL_LOANS", VALUEFUNC(_wrap_SecurityType_CALL_LOANS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_DEPOSIT_NOTES", VALUEFUNC(_wrap_SecurityType_DEPOSIT_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_CERTIFICATE_OF_DEPOSIT", VALUEFUNC(_wrap_SecurityType_EURO_CERTIFICATE_OF_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EURO_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_EURO_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_LIQUIDITY_NOTE", VALUEFUNC(_wrap_SecurityType_LIQUIDITY_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MEDIUM_TERM_NOTES", VALUEFUNC(_wrap_SecurityType_MEDIUM_TERM_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OVERNIGHT", VALUEFUNC(_wrap_SecurityType_OVERNIGHT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PROMISSORY_NOTE", VALUEFUNC(_wrap_SecurityType_PROMISSORY_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PLAZOS_FIJOS", VALUEFUNC(_wrap_SecurityType_PLAZOS_FIJOS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SHORT_TERM_LOAN_NOTE", VALUEFUNC(_wrap_SecurityType_SHORT_TERM_LOAN_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TIME_DEPOSIT", VALUEFUNC(_wrap_SecurityType_TIME_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_EXTENDED_COMM_NOTE", VALUEFUNC(_wrap_SecurityType_EXTENDED_COMM_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_YANKEE_CERTIFICATE_OF_DEPOSIT", VALUEFUNC(_wrap_SecurityType_YANKEE_CERTIFICATE_OF_DEPOSIT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_ASSET_BACKED_SECURITIES", VALUEFUNC(_wrap_SecurityType_ASSET_BACKED_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CORP_MORTGAGE_BACKED_SECURITIES", VALUEFUNC(_wrap_SecurityType_CORP_MORTGAGE_BACKED_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_COLLATERALIZED_MORTGAGE_OBLIGATION", VALUEFUNC(_wrap_SecurityType_COLLATERALIZED_MORTGAGE_OBLIGATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_IOETTE_MORTGAGE", VALUEFUNC(_wrap_SecurityType_IOETTE_MORTGAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MORTGAGE_BACKED_SECURITIES", VALUEFUNC(_wrap_SecurityType_MORTGAGE_BACKED_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MORTGAGE_INTEREST_ONLY", VALUEFUNC(_wrap_SecurityType_MORTGAGE_INTEREST_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MORTGAGE_PRINCIPAL_ONLY", VALUEFUNC(_wrap_SecurityType_MORTGAGE_PRINCIPAL_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MORTGAGE_PRIVATE_PLACEMENT", VALUEFUNC(_wrap_SecurityType_MORTGAGE_PRIVATE_PLACEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MISCELLANEOUS_PASS_THROUGH", VALUEFUNC(_wrap_SecurityType_MISCELLANEOUS_PASS_THROUGH_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_PFANDBRIEFE", VALUEFUNC(_wrap_SecurityType_PFANDBRIEFE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TO_BE_ANNOUNCED", VALUEFUNC(_wrap_SecurityType_TO_BE_ANNOUNCED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_OTHER_ANTICIPATION_NOTES", VALUEFUNC(_wrap_SecurityType_OTHER_ANTICIPATION_NOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CERTIFICATE_OF_OBLIGATION", VALUEFUNC(_wrap_SecurityType_CERTIFICATE_OF_OBLIGATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_CERTIFICATE_OF_PARTICIPATION", VALUEFUNC(_wrap_SecurityType_CERTIFICATE_OF_PARTICIPATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_GENERAL_OBLIGATION_BONDS", VALUEFUNC(_wrap_SecurityType_GENERAL_OBLIGATION_BONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MANDATORY_TENDER", VALUEFUNC(_wrap_SecurityType_MANDATORY_TENDER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REVENUE_ANTICIPATION_NOTE", VALUEFUNC(_wrap_SecurityType_REVENUE_ANTICIPATION_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_REVENUE_BONDS", VALUEFUNC(_wrap_SecurityType_REVENUE_BONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SPECIAL_ASSESSMENT", VALUEFUNC(_wrap_SecurityType_SPECIAL_ASSESSMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SPECIAL_OBLIGATION", VALUEFUNC(_wrap_SecurityType_SPECIAL_OBLIGATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_SPECIAL_TAX", VALUEFUNC(_wrap_SecurityType_SPECIAL_TAX_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TAX_ANTICIPATION_NOTE", VALUEFUNC(_wrap_SecurityType_TAX_ANTICIPATION_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TAX_ALLOCATION", VALUEFUNC(_wrap_SecurityType_TAX_ALLOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TAX_EXEMPT_COMMERCIAL_PAPER", VALUEFUNC(_wrap_SecurityType_TAX_EXEMPT_COMMERCIAL_PAPER_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_TAX_AND_REVENUE_ANTICIPATION_NOTE", VALUEFUNC(_wrap_SecurityType_TAX_AND_REVENUE_ANTICIPATION_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_VARIABLE_RATE_DEMAND_NOTE", VALUEFUNC(_wrap_SecurityType_VARIABLE_RATE_DEMAND_NOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_WARRANT", VALUEFUNC(_wrap_SecurityType_WARRANT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MUTUAL_FUND", VALUEFUNC(_wrap_SecurityType_MUTUAL_FUND_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_MULTI_LEG_INSTRUMENT", VALUEFUNC(_wrap_SecurityType_MULTI_LEG_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_NO_SECURITY_TYPE", VALUEFUNC(_wrap_SecurityType_NO_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityType_WILDCARD", VALUEFUNC(_wrap_SecurityType_WILDCARD_get), 0);
  rb_define_singleton_method(mQuickfix, "StandInstDbType_OTHER", VALUEFUNC(_wrap_StandInstDbType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "StandInstDbType_DTC_SID", VALUEFUNC(_wrap_StandInstDbType_DTC_SID_get), 0);
  rb_define_singleton_method(mQuickfix, "StandInstDbType_THOMSON_ALERT", VALUEFUNC(_wrap_StandInstDbType_THOMSON_ALERT_get), 0);
  rb_define_singleton_method(mQuickfix, "StandInstDbType_A_GLOBAL_CUSTODIAN", VALUEFUNC(_wrap_StandInstDbType_A_GLOBAL_CUSTODIAN_get), 0);
  rb_define_singleton_method(mQuickfix, "StandInstDbType_ACCOUNTNET", VALUEFUNC(_wrap_StandInstDbType_ACCOUNTNET_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlDeliveryType_VERSUS_PAYMENT", VALUEFUNC(_wrap_SettlDeliveryType_VERSUS_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlDeliveryType_FREE", VALUEFUNC(_wrap_SettlDeliveryType_FREE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlDeliveryType_TRI_PARTY", VALUEFUNC(_wrap_SettlDeliveryType_TRI_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlDeliveryType_HOLD_IN_CUSTODY", VALUEFUNC(_wrap_SettlDeliveryType_HOLD_IN_CUSTODY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocLinkType_F_X_NETTING", VALUEFUNC(_wrap_AllocLinkType_F_X_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocLinkType_F_X_SWAP", VALUEFUNC(_wrap_AllocLinkType_F_X_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "CoveredOrUncovered_COVERED", VALUEFUNC(_wrap_CoveredOrUncovered_COVERED_get), 0);
  rb_define_singleton_method(mQuickfix, "CoveredOrUncovered_UNCOVERED", VALUEFUNC(_wrap_CoveredOrUncovered_UNCOVERED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocHandlInst_MATCH", VALUEFUNC(_wrap_AllocHandlInst_MATCH_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocHandlInst_FORWARD", VALUEFUNC(_wrap_AllocHandlInst_FORWARD_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocHandlInst_FORWARD_AND_MATCH", VALUEFUNC(_wrap_AllocHandlInst_FORWARD_AND_MATCH_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingType_TARGET_FIRM", VALUEFUNC(_wrap_RoutingType_TARGET_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingType_TARGET_LIST", VALUEFUNC(_wrap_RoutingType_TARGET_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingType_BLOCK_FIRM", VALUEFUNC(_wrap_RoutingType_BLOCK_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "RoutingType_BLOCK_LIST", VALUEFUNC(_wrap_RoutingType_BLOCK_LIST_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_MUNIAAA", VALUEFUNC(_wrap_BenchmarkCurveName_MUNIAAA_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_FUTURESWAP", VALUEFUNC(_wrap_BenchmarkCurveName_FUTURESWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_LIBID", VALUEFUNC(_wrap_BenchmarkCurveName_LIBID_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_LIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_LIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_OTHER", VALUEFUNC(_wrap_BenchmarkCurveName_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_SWAP", VALUEFUNC(_wrap_BenchmarkCurveName_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_TREASURY", VALUEFUNC(_wrap_BenchmarkCurveName_TREASURY_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_EURIBOR", VALUEFUNC(_wrap_BenchmarkCurveName_EURIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_PFANDBRIEFE", VALUEFUNC(_wrap_BenchmarkCurveName_PFANDBRIEFE_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_EONIA", VALUEFUNC(_wrap_BenchmarkCurveName_EONIA_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_SONIA", VALUEFUNC(_wrap_BenchmarkCurveName_SONIA_get), 0);
  rb_define_singleton_method(mQuickfix, "BenchmarkCurveName_EUREPO", VALUEFUNC(_wrap_BenchmarkCurveName_EUREPO_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_AMT", VALUEFUNC(_wrap_StipulationType_AMT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_AUTO_REINVESTMENT_AT_OR_BETTER", VALUEFUNC(_wrap_StipulationType_AUTO_REINVESTMENT_AT_OR_BETTER_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_BANK_QUALIFIED", VALUEFUNC(_wrap_StipulationType_BANK_QUALIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_BARGAIN_CONDITIONS", VALUEFUNC(_wrap_StipulationType_BARGAIN_CONDITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_COUPON_RANGE", VALUEFUNC(_wrap_StipulationType_COUPON_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ISO_CURRENCY_CODE", VALUEFUNC(_wrap_StipulationType_ISO_CURRENCY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_CUSTOM_START_END_DATE", VALUEFUNC(_wrap_StipulationType_CUSTOM_START_END_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_GEOGRAPHICS_AND_PERCENT_RANGE", VALUEFUNC(_wrap_StipulationType_GEOGRAPHICS_AND_PERCENT_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_VALUATION_DISCOUNT", VALUEFUNC(_wrap_StipulationType_VALUATION_DISCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_INSURED", VALUEFUNC(_wrap_StipulationType_INSURED_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_YEAR_OR_YEAR_MONTH_OF_ISSUE", VALUEFUNC(_wrap_StipulationType_YEAR_OR_YEAR_MONTH_OF_ISSUE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ISSUERS_TICKER", VALUEFUNC(_wrap_StipulationType_ISSUERS_TICKER_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ISSUE_SIZE_RANGE", VALUEFUNC(_wrap_StipulationType_ISSUE_SIZE_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_LOOKBACK_DAYS", VALUEFUNC(_wrap_StipulationType_LOOKBACK_DAYS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_EXPLICIT_LOT_IDENTIFIER", VALUEFUNC(_wrap_StipulationType_EXPLICIT_LOT_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_LOT_VARIANCE", VALUEFUNC(_wrap_StipulationType_LOT_VARIANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MATURITY_YEAR_AND_MONTH", VALUEFUNC(_wrap_StipulationType_MATURITY_YEAR_AND_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MATURITY_RANGE", VALUEFUNC(_wrap_StipulationType_MATURITY_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MAXIMUM_SUBSTITUTIONS", VALUEFUNC(_wrap_StipulationType_MAXIMUM_SUBSTITUTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MINIMUM_QUANTITY", VALUEFUNC(_wrap_StipulationType_MINIMUM_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MINIMUM_INCREMENT", VALUEFUNC(_wrap_StipulationType_MINIMUM_INCREMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MINIMUM_DENOMINATION", VALUEFUNC(_wrap_StipulationType_MINIMUM_DENOMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PAYMENT_FREQUENCY_CALENDAR", VALUEFUNC(_wrap_StipulationType_PAYMENT_FREQUENCY_CALENDAR_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_NUMBER_OF_PIECES", VALUEFUNC(_wrap_StipulationType_NUMBER_OF_PIECES_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOLS_MAXIMUM", VALUEFUNC(_wrap_StipulationType_POOLS_MAXIMUM_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOLS_PER_MILLION", VALUEFUNC(_wrap_StipulationType_POOLS_PER_MILLION_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOLS_PER_LOT", VALUEFUNC(_wrap_StipulationType_POOLS_PER_LOT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_POOLS_PER_TRADE", VALUEFUNC(_wrap_StipulationType_POOLS_PER_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PRICE_RANGE", VALUEFUNC(_wrap_StipulationType_PRICE_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PRICING_FREQUENCY", VALUEFUNC(_wrap_StipulationType_PRICING_FREQUENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PRODUCTION_YEAR", VALUEFUNC(_wrap_StipulationType_PRODUCTION_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_CALL_PROTECTION", VALUEFUNC(_wrap_StipulationType_CALL_PROTECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PURPOSE", VALUEFUNC(_wrap_StipulationType_PURPOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_BENCHMARK_PRICE_SOURCE", VALUEFUNC(_wrap_StipulationType_BENCHMARK_PRICE_SOURCE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_RATING_SOURCE_AND_RANGE", VALUEFUNC(_wrap_StipulationType_RATING_SOURCE_AND_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_RESTRICTED", VALUEFUNC(_wrap_StipulationType_RESTRICTED_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MARKET_SECTOR", VALUEFUNC(_wrap_StipulationType_MARKET_SECTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_SECURITYTYPE_INCLUDED_OR_EXCLUDED", VALUEFUNC(_wrap_StipulationType_SECURITYTYPE_INCLUDED_OR_EXCLUDED_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_STRUCTURE", VALUEFUNC(_wrap_StipulationType_STRUCTURE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_SUBSTITUTIONS_FREQUENCY", VALUEFUNC(_wrap_StipulationType_SUBSTITUTIONS_FREQUENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_SUBSTITUTIONS_LEFT", VALUEFUNC(_wrap_StipulationType_SUBSTITUTIONS_LEFT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_FREEFORM_TEXT", VALUEFUNC(_wrap_StipulationType_FREEFORM_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_TRADE_VARIANCE", VALUEFUNC(_wrap_StipulationType_TRADE_VARIANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_WEIGHTED_AVERAGE_COUPON", VALUEFUNC(_wrap_StipulationType_WEIGHTED_AVERAGE_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_WEIGHTED_AVERAGE_LIFE_COUPON", VALUEFUNC(_wrap_StipulationType_WEIGHTED_AVERAGE_LIFE_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_WEIGHTED_AVERAGE_LOAN_AGE", VALUEFUNC(_wrap_StipulationType_WEIGHTED_AVERAGE_LOAN_AGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_WEIGHTED_AVERAGE_MATURITY", VALUEFUNC(_wrap_StipulationType_WEIGHTED_AVERAGE_MATURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_WHOLE_POOL", VALUEFUNC(_wrap_StipulationType_WHOLE_POOL_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_YIELD_RANGE", VALUEFUNC(_wrap_StipulationType_YIELD_RANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_SINGLE_MONTHLY_MORTALITY", VALUEFUNC(_wrap_StipulationType_SINGLE_MONTHLY_MORTALITY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_CONSTANT_PREPAYMENT_RATE", VALUEFUNC(_wrap_StipulationType_CONSTANT_PREPAYMENT_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_CONSTANT_PREPAYMENT_YIELD", VALUEFUNC(_wrap_StipulationType_CONSTANT_PREPAYMENT_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_CONSTANT_PREPAYMENT_PENALTY", VALUEFUNC(_wrap_StipulationType_CONSTANT_PREPAYMENT_PENALTY_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_ABSOLUTE_PREPAYMENT_SPEED", VALUEFUNC(_wrap_StipulationType_ABSOLUTE_PREPAYMENT_SPEED_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_MONTHLY_PREPAYMENT_RATE", VALUEFUNC(_wrap_StipulationType_MONTHLY_PREPAYMENT_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PERCENT_OF_BMA_PREPAYMENT_CURVE", VALUEFUNC(_wrap_StipulationType_PERCENT_OF_BMA_PREPAYMENT_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PERCENT_OF_PROSPECTUS_PREPAYMENT_CURVE", VALUEFUNC(_wrap_StipulationType_PERCENT_OF_PROSPECTUS_PREPAYMENT_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_PERCENT_OF_MANUFACTURED_HOUSING_PREPAYMENT_CURVE", VALUEFUNC(_wrap_StipulationType_PERCENT_OF_MANUFACTURED_HOUSING_PREPAYMENT_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationType_FINAL_CPR_OF_HOME_EQUITY_PREPAYMENT_CURVE", VALUEFUNC(_wrap_StipulationType_FINAL_CPR_OF_HOME_EQUITY_PREPAYMENT_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_CUM_DIVIDEND", VALUEFUNC(_wrap_StipulationValue_SPECIAL_CUM_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_EX_DIVIDEND", VALUEFUNC(_wrap_StipulationValue_SPECIAL_EX_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_CUM_COUPON", VALUEFUNC(_wrap_StipulationValue_SPECIAL_CUM_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_EX_COUPON", VALUEFUNC(_wrap_StipulationValue_SPECIAL_EX_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_CUM_BONUS", VALUEFUNC(_wrap_StipulationValue_SPECIAL_CUM_BONUS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_EX_BONUS", VALUEFUNC(_wrap_StipulationValue_SPECIAL_EX_BONUS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_CUM_RIGHTS", VALUEFUNC(_wrap_StipulationValue_SPECIAL_CUM_RIGHTS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_EX_RIGHTS", VALUEFUNC(_wrap_StipulationValue_SPECIAL_EX_RIGHTS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_CUM_CAPITAL_REPAYMENTS", VALUEFUNC(_wrap_StipulationValue_SPECIAL_CUM_CAPITAL_REPAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_EX_CAPITAL_REPAYMENTS", VALUEFUNC(_wrap_StipulationValue_SPECIAL_EX_CAPITAL_REPAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_CASH_SETTLEMENT", VALUEFUNC(_wrap_StipulationValue_CASH_SETTLEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_SPECIAL_PRICE", VALUEFUNC(_wrap_StipulationValue_SPECIAL_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_REPORT_FOR_EUROPEAN_EQUITY_MARKET_SECURITIES", VALUEFUNC(_wrap_StipulationValue_REPORT_FOR_EUROPEAN_EQUITY_MARKET_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "StipulationValue_GUARANTEED_DELIVERY", VALUEFUNC(_wrap_StipulationValue_GUARANTEED_DELIVERY_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_AFTER_TAX_YIELD", VALUEFUNC(_wrap_YieldType_AFTER_TAX_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_ANNUAL_YIELD", VALUEFUNC(_wrap_YieldType_ANNUAL_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_AT_ISSUE", VALUEFUNC(_wrap_YieldType_YIELD_AT_ISSUE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_AVERAGE_MATURITY", VALUEFUNC(_wrap_YieldType_YIELD_TO_AVERAGE_MATURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_BOOK_YIELD", VALUEFUNC(_wrap_YieldType_BOOK_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_NEXT_CALL", VALUEFUNC(_wrap_YieldType_YIELD_TO_NEXT_CALL_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_CHANGE_SINCE_CLOSE", VALUEFUNC(_wrap_YieldType_YIELD_CHANGE_SINCE_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_CLOSING_YIELD", VALUEFUNC(_wrap_YieldType_CLOSING_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_COMPOUND_YIELD", VALUEFUNC(_wrap_YieldType_COMPOUND_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_CURRENT_YIELD", VALUEFUNC(_wrap_YieldType_CURRENT_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_TRUE_GROSS_YIELD", VALUEFUNC(_wrap_YieldType_TRUE_GROSS_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_GOVERNMENT_EQUIVALENT_YIELD", VALUEFUNC(_wrap_YieldType_GOVERNMENT_EQUIVALENT_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_WITH_INFLATION_ASSUMPTION", VALUEFUNC(_wrap_YieldType_YIELD_WITH_INFLATION_ASSUMPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_INVERSE_FLOATER_BOND_YIELD", VALUEFUNC(_wrap_YieldType_INVERSE_FLOATER_BOND_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_MOST_RECENT_CLOSING_YIELD", VALUEFUNC(_wrap_YieldType_MOST_RECENT_CLOSING_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_CLOSING_YIELD_MOST_RECENT_MONTH", VALUEFUNC(_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_MONTH_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_CLOSING_YIELD_MOST_RECENT_QUARTER", VALUEFUNC(_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_QUARTER_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_CLOSING_YIELD_MOST_RECENT_YEAR", VALUEFUNC(_wrap_YieldType_CLOSING_YIELD_MOST_RECENT_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_LONGEST_AVERAGE_LIFE", VALUEFUNC(_wrap_YieldType_YIELD_TO_LONGEST_AVERAGE_LIFE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_MARK_TO_MARKET_YIELD", VALUEFUNC(_wrap_YieldType_MARK_TO_MARKET_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_MATURITY", VALUEFUNC(_wrap_YieldType_YIELD_TO_MATURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_NEXT_REFUND", VALUEFUNC(_wrap_YieldType_YIELD_TO_NEXT_REFUND_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_OPEN_AVERAGE_YIELD", VALUEFUNC(_wrap_YieldType_OPEN_AVERAGE_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_NEXT_PUT", VALUEFUNC(_wrap_YieldType_YIELD_TO_NEXT_PUT_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_PREVIOUS_CLOSE_YIELD", VALUEFUNC(_wrap_YieldType_PREVIOUS_CLOSE_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_PROCEEDS_YIELD", VALUEFUNC(_wrap_YieldType_PROCEEDS_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_SEMI_ANNUAL_YIELD", VALUEFUNC(_wrap_YieldType_SEMI_ANNUAL_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_SHORTEST_AVERAGE_LIFE", VALUEFUNC(_wrap_YieldType_YIELD_TO_SHORTEST_AVERAGE_LIFE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_SIMPLE_YIELD", VALUEFUNC(_wrap_YieldType_SIMPLE_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_TAX_EQUIVALENT_YIELD", VALUEFUNC(_wrap_YieldType_TAX_EQUIVALENT_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_TENDER_DATE", VALUEFUNC(_wrap_YieldType_YIELD_TO_TENDER_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_TRUE_YIELD", VALUEFUNC(_wrap_YieldType_TRUE_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_VALUE_OF_1_32", VALUEFUNC(_wrap_YieldType_YIELD_VALUE_OF_1_32_get), 0);
  rb_define_singleton_method(mQuickfix, "YieldType_YIELD_TO_WORST", VALUEFUNC(_wrap_YieldType_YIELD_TO_WORST_get), 0);
  rb_define_singleton_method(mQuickfix, "SubscriptionRequestType_SNAPSHOT", VALUEFUNC(_wrap_SubscriptionRequestType_SNAPSHOT_get), 0);
  rb_define_singleton_method(mQuickfix, "SubscriptionRequestType_SNAPSHOT_PLUS_UPDATES", VALUEFUNC(_wrap_SubscriptionRequestType_SNAPSHOT_PLUS_UPDATES_get), 0);
  rb_define_singleton_method(mQuickfix, "SubscriptionRequestType_DISABLE_PREVIOUS_SNAPSHOT_PLUS_UPDATE_REQUEST", VALUEFUNC(_wrap_SubscriptionRequestType_DISABLE_PREVIOUS_SNAPSHOT_PLUS_UPDATE_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateType_FULL_REFRESH", VALUEFUNC(_wrap_MDUpdateType_FULL_REFRESH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateType_INCREMENTAL_REFRESH", VALUEFUNC(_wrap_MDUpdateType_INCREMENTAL_REFRESH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_BID", VALUEFUNC(_wrap_MDEntryType_BID_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_OFFER", VALUEFUNC(_wrap_MDEntryType_OFFER_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TRADE", VALUEFUNC(_wrap_MDEntryType_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_INDEX_VALUE", VALUEFUNC(_wrap_MDEntryType_INDEX_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_OPENING_PRICE", VALUEFUNC(_wrap_MDEntryType_OPENING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_CLOSING_PRICE", VALUEFUNC(_wrap_MDEntryType_CLOSING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_SETTLEMENT_PRICE", VALUEFUNC(_wrap_MDEntryType_SETTLEMENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TRADING_SESSION_HIGH_PRICE", VALUEFUNC(_wrap_MDEntryType_TRADING_SESSION_HIGH_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TRADING_SESSION_LOW_PRICE", VALUEFUNC(_wrap_MDEntryType_TRADING_SESSION_LOW_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TRADING_SESSION_VWAP_PRICE", VALUEFUNC(_wrap_MDEntryType_TRADING_SESSION_VWAP_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_IMBALANCE", VALUEFUNC(_wrap_MDEntryType_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_TRADE_VOLUME", VALUEFUNC(_wrap_MDEntryType_TRADE_VOLUME_get), 0);
  rb_define_singleton_method(mQuickfix, "MDEntryType_OPEN_INTEREST", VALUEFUNC(_wrap_MDEntryType_OPEN_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "TickDirection_PLUS_TICK", VALUEFUNC(_wrap_TickDirection_PLUS_TICK_get), 0);
  rb_define_singleton_method(mQuickfix, "TickDirection_ZERO_PLUS_TICK", VALUEFUNC(_wrap_TickDirection_ZERO_PLUS_TICK_get), 0);
  rb_define_singleton_method(mQuickfix, "TickDirection_MINUS_TICK", VALUEFUNC(_wrap_TickDirection_MINUS_TICK_get), 0);
  rb_define_singleton_method(mQuickfix, "TickDirection_ZERO_MINUS_TICK", VALUEFUNC(_wrap_TickDirection_ZERO_MINUS_TICK_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_OPEN_ACTIVE", VALUEFUNC(_wrap_QuoteCondition_OPEN_ACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_CLOSED_INACTIVE", VALUEFUNC(_wrap_QuoteCondition_CLOSED_INACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_EXCHANGE_BEST", VALUEFUNC(_wrap_QuoteCondition_EXCHANGE_BEST_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_CONSOLIDATED_BEST", VALUEFUNC(_wrap_QuoteCondition_CONSOLIDATED_BEST_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_LOCKED", VALUEFUNC(_wrap_QuoteCondition_LOCKED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_CROSSED", VALUEFUNC(_wrap_QuoteCondition_CROSSED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_DEPTH", VALUEFUNC(_wrap_QuoteCondition_DEPTH_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_FAST_TRADING", VALUEFUNC(_wrap_QuoteCondition_FAST_TRADING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCondition_NON_FIRM", VALUEFUNC(_wrap_QuoteCondition_NON_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CASH_MARKET", VALUEFUNC(_wrap_TradeCondition_CASH_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_AVERAGE_PRICE_TRADE", VALUEFUNC(_wrap_TradeCondition_AVERAGE_PRICE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_CASH_TRADE", VALUEFUNC(_wrap_TradeCondition_CASH_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_NEXT_DAY_MARKET", VALUEFUNC(_wrap_TradeCondition_NEXT_DAY_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OPENING_REOPENING_TRADE_DETAIL", VALUEFUNC(_wrap_TradeCondition_OPENING_REOPENING_TRADE_DETAIL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_INTRADAY_TRADE_DETAIL", VALUEFUNC(_wrap_TradeCondition_INTRADAY_TRADE_DETAIL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_RULE127", VALUEFUNC(_wrap_TradeCondition_RULE127_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_RULE155", VALUEFUNC(_wrap_TradeCondition_RULE155_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SOLD_LAST", VALUEFUNC(_wrap_TradeCondition_SOLD_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_NEXT_DAY_TRADE", VALUEFUNC(_wrap_TradeCondition_NEXT_DAY_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OPENED", VALUEFUNC(_wrap_TradeCondition_OPENED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SELLER", VALUEFUNC(_wrap_TradeCondition_SELLER_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_SOLD", VALUEFUNC(_wrap_TradeCondition_SOLD_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_STOPPED_STOCK", VALUEFUNC(_wrap_TradeCondition_STOPPED_STOCK_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_IMBALANCE_MORE_BUYERS", VALUEFUNC(_wrap_TradeCondition_IMBALANCE_MORE_BUYERS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_IMBALANCE_MORE_SELLERS", VALUEFUNC(_wrap_TradeCondition_IMBALANCE_MORE_SELLERS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeCondition_OPENING_PRICE", VALUEFUNC(_wrap_TradeCondition_OPENING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateAction_NEW", VALUEFUNC(_wrap_MDUpdateAction_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateAction_CHANGE", VALUEFUNC(_wrap_MDUpdateAction_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDUpdateAction_DELETE", VALUEFUNC(_wrap_MDUpdateAction_DELETE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_MDReqRejReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_DUPLICATE_MDREQID", VALUEFUNC(_wrap_MDReqRejReason_DUPLICATE_MDREQID_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_INSUFFICIENT_BANDWIDTH", VALUEFUNC(_wrap_MDReqRejReason_INSUFFICIENT_BANDWIDTH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_INSUFFICIENT_PERMISSIONS", VALUEFUNC(_wrap_MDReqRejReason_INSUFFICIENT_PERMISSIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_SUBSCRIPTIONREQUESTTYPE", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_SUBSCRIPTIONREQUESTTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_MARKETDEPTH", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_MARKETDEPTH_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_MDUPDATETYPE", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_MDUPDATETYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_AGGREGATEDBOOK", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_AGGREGATEDBOOK_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_MDENTRYTYPE", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_MDENTRYTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_TRADINGSESSIONID", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_TRADINGSESSIONID_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_SCOPE", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_SCOPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_OPENCLOSESETTLEFLAG", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_OPENCLOSESETTLEFLAG_get), 0);
  rb_define_singleton_method(mQuickfix, "MDReqRejReason_UNSUPPORTED_MDIMPLICITDELETE", VALUEFUNC(_wrap_MDReqRejReason_UNSUPPORTED_MDIMPLICITDELETE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeleteReason_CANCELATION_TRADE_BUST", VALUEFUNC(_wrap_DeleteReason_CANCELATION_TRADE_BUST_get), 0);
  rb_define_singleton_method(mQuickfix, "DeleteReason_ERROR", VALUEFUNC(_wrap_DeleteReason_ERROR_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_DAILY_OPEN_CLOSE_SETTLEMENT_ENTRY", VALUEFUNC(_wrap_OpenCloseSettlFlag_DAILY_OPEN_CLOSE_SETTLEMENT_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_SESSION_OPEN_CLOSE_SETTLEMENT_ENTRY", VALUEFUNC(_wrap_OpenCloseSettlFlag_SESSION_OPEN_CLOSE_SETTLEMENT_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_DELIVERY_SETTLEMENT_ENTRY", VALUEFUNC(_wrap_OpenCloseSettlFlag_DELIVERY_SETTLEMENT_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_EXPECTED_ENTRY", VALUEFUNC(_wrap_OpenCloseSettlFlag_EXPECTED_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY", VALUEFUNC(_wrap_OpenCloseSettlFlag_ENTRY_FROM_PREVIOUS_BUSINESS_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettlFlag_THEORETICAL_PRICE_VALUE", VALUEFUNC(_wrap_OpenCloseSettlFlag_THEORETICAL_PRICE_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "FinancialStatus_BANKRUPT", VALUEFUNC(_wrap_FinancialStatus_BANKRUPT_get), 0);
  rb_define_singleton_method(mQuickfix, "FinancialStatus_PENDING_DELISTING", VALUEFUNC(_wrap_FinancialStatus_PENDING_DELISTING_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_EX_DIVIDEND", VALUEFUNC(_wrap_CorporateAction_EX_DIVIDEND_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_EX_DISTRIBUTION", VALUEFUNC(_wrap_CorporateAction_EX_DISTRIBUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_EX_RIGHTS", VALUEFUNC(_wrap_CorporateAction_EX_RIGHTS_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_NEW", VALUEFUNC(_wrap_CorporateAction_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "CorporateAction_EX_INTEREST", VALUEFUNC(_wrap_CorporateAction_EX_INTEREST_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_ACCEPTED", VALUEFUNC(_wrap_QuoteStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_FOR_SYMBOL", VALUEFUNC(_wrap_QuoteStatus_CANCELED_FOR_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_FOR_SECURITY_TYPE", VALUEFUNC(_wrap_QuoteStatus_CANCELED_FOR_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_FOR_UNDERLYING", VALUEFUNC(_wrap_QuoteStatus_CANCELED_FOR_UNDERLYING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_ALL", VALUEFUNC(_wrap_QuoteStatus_CANCELED_ALL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_REJECTED", VALUEFUNC(_wrap_QuoteStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_REMOVED_FROM_MARKET", VALUEFUNC(_wrap_QuoteStatus_REMOVED_FROM_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_EXPIRED", VALUEFUNC(_wrap_QuoteStatus_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_QUERY", VALUEFUNC(_wrap_QuoteStatus_QUERY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_QUOTE_NOT_FOUND", VALUEFUNC(_wrap_QuoteStatus_QUOTE_NOT_FOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_PENDING", VALUEFUNC(_wrap_QuoteStatus_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_PASS", VALUEFUNC(_wrap_QuoteStatus_PASS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_LOCKED_MARKET_WARNING", VALUEFUNC(_wrap_QuoteStatus_LOCKED_MARKET_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CROSS_MARKET_WARNING", VALUEFUNC(_wrap_QuoteStatus_CROSS_MARKET_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_DUE_TO_LOCK_MARKET", VALUEFUNC(_wrap_QuoteStatus_CANCELED_DUE_TO_LOCK_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteStatus_CANCELED_DUE_TO_CROSS_MARKET", VALUEFUNC(_wrap_QuoteStatus_CANCELED_DUE_TO_CROSS_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_FOR_SYMBOL", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_FOR_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_FOR_SECURITY_TYPE", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_FOR_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_FOR_UNDERLYING_SYMBOL", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_FOR_UNDERLYING_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteCancelType_CANCEL_ALL_QUOTES", VALUEFUNC(_wrap_QuoteCancelType_CANCEL_ALL_QUOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_QuoteRejectReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_EXCHANGE_CLOSED", VALUEFUNC(_wrap_QuoteRejectReason_EXCHANGE_CLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT", VALUEFUNC(_wrap_QuoteRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_TOO_LATE_TO_ENTER", VALUEFUNC(_wrap_QuoteRejectReason_TOO_LATE_TO_ENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_UNKNOWN_QUOTE", VALUEFUNC(_wrap_QuoteRejectReason_UNKNOWN_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_DUPLICATE_QUOTE", VALUEFUNC(_wrap_QuoteRejectReason_DUPLICATE_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_INVALID_BID_ASK_SPREAD", VALUEFUNC(_wrap_QuoteRejectReason_INVALID_BID_ASK_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_INVALID_PRICE", VALUEFUNC(_wrap_QuoteRejectReason_INVALID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY", VALUEFUNC(_wrap_QuoteRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteResponseLevel_NO_ACKNOWLEDGEMENT", VALUEFUNC(_wrap_QuoteResponseLevel_NO_ACKNOWLEDGEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteResponseLevel_ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES", VALUEFUNC(_wrap_QuoteResponseLevel_ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteResponseLevel_ACKNOWLEDGE_EACH_QUOTE_MESSAGES", VALUEFUNC(_wrap_QuoteResponseLevel_ACKNOWLEDGE_EACH_QUOTE_MESSAGES_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestType_MANUAL", VALUEFUNC(_wrap_QuoteRequestType_MANUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestType_AUTOMATIC", VALUEFUNC(_wrap_QuoteRequestType_AUTOMATIC_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS", VALUEFUNC(_wrap_SecurityRequestType_REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_REQUEST_SECURITY_IDENTITY_FOR_THE_SPECIFICATIONS_PROVIDED", VALUEFUNC(_wrap_SecurityRequestType_REQUEST_SECURITY_IDENTITY_FOR_THE_SPECIFICATIONS_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_REQUEST_LIST_SECURITY_TYPES", VALUEFUNC(_wrap_SecurityRequestType_REQUEST_LIST_SECURITY_TYPES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestType_REQUEST_LIST_SECURITIES", VALUEFUNC(_wrap_SecurityRequestType_REQUEST_LIST_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_ACCEPT_SECURITY_PROPOSAL_AS_IS", VALUEFUNC(_wrap_SecurityResponseType_ACCEPT_SECURITY_PROPOSAL_AS_IS_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_ACCEPT_SECURITY_PROPOSAL_WITH_REVISIONS_AS_INDICATED_IN_THE_MESSAGE", VALUEFUNC(_wrap_SecurityResponseType_ACCEPT_SECURITY_PROPOSAL_WITH_REVISIONS_AS_INDICATED_IN_THE_MESSAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_LIST_OF_SECURITY_TYPES_RETURNED_PER_REQUEST", VALUEFUNC(_wrap_SecurityResponseType_LIST_OF_SECURITY_TYPES_RETURNED_PER_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_LIST_OF_SECURITIES_RETURNED_PER_REQUEST", VALUEFUNC(_wrap_SecurityResponseType_LIST_OF_SECURITIES_RETURNED_PER_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_REJECT_SECURITY_PROPOSAL", VALUEFUNC(_wrap_SecurityResponseType_REJECT_SECURITY_PROPOSAL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityResponseType_CAN_NOT_MATCH_SELECTION_CRITERIA", VALUEFUNC(_wrap_SecurityResponseType_CAN_NOT_MATCH_SELECTION_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_OPENING_DELAY", VALUEFUNC(_wrap_SecurityTradingStatus_OPENING_DELAY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_TRADING_HALT", VALUEFUNC(_wrap_SecurityTradingStatus_TRADING_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_RESUME", VALUEFUNC(_wrap_SecurityTradingStatus_RESUME_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NO_OPEN_NO_RESUME", VALUEFUNC(_wrap_SecurityTradingStatus_NO_OPEN_NO_RESUME_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_PRICE_INDICATION", VALUEFUNC(_wrap_SecurityTradingStatus_PRICE_INDICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_TRADING_RANGE_INDICATION", VALUEFUNC(_wrap_SecurityTradingStatus_TRADING_RANGE_INDICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_MARKET_IMBALANCE_BUY", VALUEFUNC(_wrap_SecurityTradingStatus_MARKET_IMBALANCE_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_MARKET_IMBALANCE_SELL", VALUEFUNC(_wrap_SecurityTradingStatus_MARKET_IMBALANCE_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_BUY", VALUEFUNC(_wrap_SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_BUY_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_SELL", VALUEFUNC(_wrap_SecurityTradingStatus_MARKET_ON_CLOSE_IMBALANCE_SELL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NOT_ASSIGNED", VALUEFUNC(_wrap_SecurityTradingStatus_NOT_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NO_MARKET_IMBALANCE", VALUEFUNC(_wrap_SecurityTradingStatus_NO_MARKET_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NO_MARKET_ON_CLOSE_IMBALANCE", VALUEFUNC(_wrap_SecurityTradingStatus_NO_MARKET_ON_CLOSE_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_ITS_PRE_OPENING", VALUEFUNC(_wrap_SecurityTradingStatus_ITS_PRE_OPENING_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NEW_PRICE_INDICATION", VALUEFUNC(_wrap_SecurityTradingStatus_NEW_PRICE_INDICATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_TRADE_DISSEMINATION_TIME", VALUEFUNC(_wrap_SecurityTradingStatus_TRADE_DISSEMINATION_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_READY_TO_TRADE_START_OF_SESSION", VALUEFUNC(_wrap_SecurityTradingStatus_READY_TO_TRADE_START_OF_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NOT_AVAILABLE_FOR_TRADING_END_OF_SESSION", VALUEFUNC(_wrap_SecurityTradingStatus_NOT_AVAILABLE_FOR_TRADING_END_OF_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_NOT_TRADED_ON_THIS_MARKET", VALUEFUNC(_wrap_SecurityTradingStatus_NOT_TRADED_ON_THIS_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_UNKNOWN_OR_INVALID", VALUEFUNC(_wrap_SecurityTradingStatus_UNKNOWN_OR_INVALID_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_PRE_OPEN", VALUEFUNC(_wrap_SecurityTradingStatus_PRE_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_OPENING_ROTATION", VALUEFUNC(_wrap_SecurityTradingStatus_OPENING_ROTATION_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityTradingStatus_FAST_MARKET", VALUEFUNC(_wrap_SecurityTradingStatus_FAST_MARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReason_ORDER_IMBALANCE", VALUEFUNC(_wrap_HaltReason_ORDER_IMBALANCE_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReason_EQUIPMENT_CHANGEOVER", VALUEFUNC(_wrap_HaltReason_EQUIPMENT_CHANGEOVER_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReason_NEWS_PENDING", VALUEFUNC(_wrap_HaltReason_NEWS_PENDING_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReason_NEWS_DISSEMINATION", VALUEFUNC(_wrap_HaltReason_NEWS_DISSEMINATION_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReason_ORDER_INFLUX", VALUEFUNC(_wrap_HaltReason_ORDER_INFLUX_get), 0);
  rb_define_singleton_method(mQuickfix, "HaltReason_ADDITIONAL_INFORMATION", VALUEFUNC(_wrap_HaltReason_ADDITIONAL_INFORMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "Adjustment_CANCEL", VALUEFUNC(_wrap_Adjustment_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "Adjustment_ERROR", VALUEFUNC(_wrap_Adjustment_ERROR_get), 0);
  rb_define_singleton_method(mQuickfix, "Adjustment_CORRECTION", VALUEFUNC(_wrap_Adjustment_CORRECTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMethod_ELECTRONIC", VALUEFUNC(_wrap_TradSesMethod_ELECTRONIC_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMethod_OPEN_OUTCRY", VALUEFUNC(_wrap_TradSesMethod_OPEN_OUTCRY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMethod_TWO_PARTY", VALUEFUNC(_wrap_TradSesMethod_TWO_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMode_TESTING", VALUEFUNC(_wrap_TradSesMode_TESTING_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMode_SIMULATED", VALUEFUNC(_wrap_TradSesMode_SIMULATED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesMode_PRODUCTION", VALUEFUNC(_wrap_TradSesMode_PRODUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_UNKNOWN", VALUEFUNC(_wrap_TradSesStatus_UNKNOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_HALTED", VALUEFUNC(_wrap_TradSesStatus_HALTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_OPEN", VALUEFUNC(_wrap_TradSesStatus_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_CLOSED", VALUEFUNC(_wrap_TradSesStatus_CLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_PRE_OPEN", VALUEFUNC(_wrap_TradSesStatus_PRE_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_PRE_CLOSE", VALUEFUNC(_wrap_TradSesStatus_PRE_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatus_REQUEST_REJECTED", VALUEFUNC(_wrap_TradSesStatus_REQUEST_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MessageEncoding_ISO_2022_JP", VALUEFUNC(_wrap_MessageEncoding_ISO_2022_JP_get), 0);
  rb_define_singleton_method(mQuickfix, "MessageEncoding_EUC_JP", VALUEFUNC(_wrap_MessageEncoding_EUC_JP_get), 0);
  rb_define_singleton_method(mQuickfix, "MessageEncoding_SHIFT_JIS", VALUEFUNC(_wrap_MessageEncoding_SHIFT_JIS_get), 0);
  rb_define_singleton_method(mQuickfix, "MessageEncoding_UTF_8", VALUEFUNC(_wrap_MessageEncoding_UTF_8_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_QuoteEntryRejectReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_EXCHANGE_CLOSED", VALUEFUNC(_wrap_QuoteEntryRejectReason_EXCHANGE_CLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_QUOTE_EXCEEDS_LIMIT", VALUEFUNC(_wrap_QuoteEntryRejectReason_QUOTE_EXCEEDS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_TOO_LATE_TO_ENTER", VALUEFUNC(_wrap_QuoteEntryRejectReason_TOO_LATE_TO_ENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_UNKNOWN_QUOTE", VALUEFUNC(_wrap_QuoteEntryRejectReason_UNKNOWN_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_DUPLICATE_QUOTE", VALUEFUNC(_wrap_QuoteEntryRejectReason_DUPLICATE_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_INVALID_BID_ASK_SPREAD", VALUEFUNC(_wrap_QuoteEntryRejectReason_INVALID_BID_ASK_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_INVALID_PRICE", VALUEFUNC(_wrap_QuoteEntryRejectReason_INVALID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteEntryRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY", VALUEFUNC(_wrap_QuoteEntryRejectReason_NOT_AUTHORIZED_TO_QUOTE_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INVALID_TAG_NUMBER", VALUEFUNC(_wrap_SessionRejectReason_INVALID_TAG_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_REQUIRED_TAG_MISSING", VALUEFUNC(_wrap_SessionRejectReason_REQUIRED_TAG_MISSING_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE", VALUEFUNC(_wrap_SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_UNDEFINED_TAG", VALUEFUNC(_wrap_SessionRejectReason_UNDEFINED_TAG_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE", VALUEFUNC(_wrap_SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_VALUE_IS_INCORRECT", VALUEFUNC(_wrap_SessionRejectReason_VALUE_IS_INCORRECT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE", VALUEFUNC(_wrap_SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_DECRYPTION_PROBLEM", VALUEFUNC(_wrap_SessionRejectReason_DECRYPTION_PROBLEM_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_SIGNATURE_PROBLEM", VALUEFUNC(_wrap_SessionRejectReason_SIGNATURE_PROBLEM_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_COMPID_PROBLEM", VALUEFUNC(_wrap_SessionRejectReason_COMPID_PROBLEM_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM", VALUEFUNC(_wrap_SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INVALID_MSGTYPE", VALUEFUNC(_wrap_SessionRejectReason_INVALID_MSGTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_XML_VALIDATION_ERROR", VALUEFUNC(_wrap_SessionRejectReason_XML_VALIDATION_ERROR_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE", VALUEFUNC(_wrap_SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER", VALUEFUNC(_wrap_SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_REPEATING_GROUP_FIELDS_OUT_OF_ORDER", VALUEFUNC(_wrap_SessionRejectReason_REPEATING_GROUP_FIELDS_OUT_OF_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP", VALUEFUNC(_wrap_SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER", VALUEFUNC(_wrap_SessionRejectReason_NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_OTHER", VALUEFUNC(_wrap_SessionRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "BidRequestTransType_NEW", VALUEFUNC(_wrap_BidRequestTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "BidRequestTransType_CANCEL", VALUEFUNC(_wrap_BidRequestTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_GT_CORPORATE_ACTION", VALUEFUNC(_wrap_ExecRestatementReason_GT_CORPORATE_ACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_GT_RENEWAL_RESTATEMENT", VALUEFUNC(_wrap_ExecRestatementReason_GT_RENEWAL_RESTATEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_VERBAL_CHANGE", VALUEFUNC(_wrap_ExecRestatementReason_VERBAL_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_REPRICING_OF_ORDER", VALUEFUNC(_wrap_ExecRestatementReason_REPRICING_OF_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_BROKER_OPTION", VALUEFUNC(_wrap_ExecRestatementReason_BROKER_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_PARTIAL_DECLINE_OF_ORDERQTY", VALUEFUNC(_wrap_ExecRestatementReason_PARTIAL_DECLINE_OF_ORDERQTY_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CANCEL_ON_TRADING_HALT", VALUEFUNC(_wrap_ExecRestatementReason_CANCEL_ON_TRADING_HALT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CANCEL_ON_SYSTEM_FAILURE", VALUEFUNC(_wrap_ExecRestatementReason_CANCEL_ON_SYSTEM_FAILURE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_MARKET_OPTION", VALUEFUNC(_wrap_ExecRestatementReason_MARKET_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecRestatementReason_CANCELED_NOT_BEST", VALUEFUNC(_wrap_ExecRestatementReason_CANCELED_NOT_BEST_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_OTHER", VALUEFUNC(_wrap_BusinessRejectReason_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNKOWN_ID", VALUEFUNC(_wrap_BusinessRejectReason_UNKOWN_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNKNOWN_SECURITY", VALUEFUNC(_wrap_BusinessRejectReason_UNKNOWN_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE", VALUEFUNC(_wrap_BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_APPLICATION_NOT_AVAILABLE", VALUEFUNC(_wrap_BusinessRejectReason_APPLICATION_NOT_AVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING", VALUEFUNC(_wrap_BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_NOT_AUTHORIZED", VALUEFUNC(_wrap_BusinessRejectReason_NOT_AUTHORIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME", VALUEFUNC(_wrap_BusinessRejectReason_DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgDirection_SEND", VALUEFUNC(_wrap_MsgDirection_SEND_get), 0);
  rb_define_singleton_method(mQuickfix, "MsgDirection_RECEIVE", VALUEFUNC(_wrap_MsgDirection_RECEIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_DISPLAYED_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_DISPLAYED_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_MARKET_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_MARKET_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_PRIMARY_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_PRIMARY_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_LOCAL_PRIMARY_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_LOCAL_PRIMARY_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_MIDPOINT_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_MIDPOINT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_LAST_TRADE_PRICE", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_LAST_TRADE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionInst_RELATED_TO_VWAP", VALUEFUNC(_wrap_DiscretionInst_RELATED_TO_VWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "BidType_NON_DISCLOSED", VALUEFUNC(_wrap_BidType_NON_DISCLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "BidType_DISCLOSED_STYLE", VALUEFUNC(_wrap_BidType_DISCLOSED_STYLE_get), 0);
  rb_define_singleton_method(mQuickfix, "BidType_NO_BIDDING_PROCESS", VALUEFUNC(_wrap_BidType_NO_BIDDING_PROCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "BidDescriptorType_SECTOR", VALUEFUNC(_wrap_BidDescriptorType_SECTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "BidDescriptorType_COUNTRY", VALUEFUNC(_wrap_BidDescriptorType_COUNTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "BidDescriptorType_INDEX", VALUEFUNC(_wrap_BidDescriptorType_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "SideValueInd_SIDEVALUE1", VALUEFUNC(_wrap_SideValueInd_SIDEVALUE1_get), 0);
  rb_define_singleton_method(mQuickfix, "SideValueInd_SIDEVALUE2", VALUEFUNC(_wrap_SideValueInd_SIDEVALUE2_get), 0);
  rb_define_singleton_method(mQuickfix, "LiquidityIndType_FIVEDAY_MOVING_AVERAGE", VALUEFUNC(_wrap_LiquidityIndType_FIVEDAY_MOVING_AVERAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "LiquidityIndType_TWENTYDAY_MOVING_AVERAGE", VALUEFUNC(_wrap_LiquidityIndType_TWENTYDAY_MOVING_AVERAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "LiquidityIndType_NORMAL_MARKET_SIZE", VALUEFUNC(_wrap_LiquidityIndType_NORMAL_MARKET_SIZE_get), 0);
  rb_define_singleton_method(mQuickfix, "LiquidityIndType_OTHER", VALUEFUNC(_wrap_LiquidityIndType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "ProgRptReqs_BUYSIDE_EXPLICITLY_REQUESTS_STATUS_USING_STATUSREQUEST", VALUEFUNC(_wrap_ProgRptReqs_BUYSIDE_EXPLICITLY_REQUESTS_STATUS_USING_STATUSREQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "ProgRptReqs_SELLSIDE_PERIODICALLY_SENDS_STATUS_USING_LISTSTATUS", VALUEFUNC(_wrap_ProgRptReqs_SELLSIDE_PERIODICALLY_SENDS_STATUS_USING_LISTSTATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "ProgRptReqs_REAL_TIME_EXECUTION_REPORTS", VALUEFUNC(_wrap_ProgRptReqs_REAL_TIME_EXECUTION_REPORTS_get), 0);
  rb_define_singleton_method(mQuickfix, "IncTaxInd_NET", VALUEFUNC(_wrap_IncTaxInd_NET_get), 0);
  rb_define_singleton_method(mQuickfix, "IncTaxInd_GROSS", VALUEFUNC(_wrap_IncTaxInd_GROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "BidTradeType_RISK_TRADE", VALUEFUNC(_wrap_BidTradeType_RISK_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "BidTradeType_VWAP_GUARANTEE", VALUEFUNC(_wrap_BidTradeType_VWAP_GUARANTEE_get), 0);
  rb_define_singleton_method(mQuickfix, "BidTradeType_AGENCY", VALUEFUNC(_wrap_BidTradeType_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "BidTradeType_GUARANTEED_CLOSE", VALUEFUNC(_wrap_BidTradeType_GUARANTEED_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_CLOSING_PRICE_AT_MORNING_SESSION", VALUEFUNC(_wrap_BasisPxType_CLOSING_PRICE_AT_MORNING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_CLOSING_PRICE", VALUEFUNC(_wrap_BasisPxType_CLOSING_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_CURRENT_PRICE", VALUEFUNC(_wrap_BasisPxType_CURRENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_SQ", VALUEFUNC(_wrap_BasisPxType_SQ_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_A_DAY", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_A_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_A_MORNING_SESSION", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_A_DAY_EXCEPT_YORI", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_A_DAY_EXCEPT_YORI_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_YORI", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_YORI_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_YORI", VALUEFUNC(_wrap_BasisPxType_VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_YORI_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_STRIKE", VALUEFUNC(_wrap_BasisPxType_STRIKE_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_OPEN", VALUEFUNC(_wrap_BasisPxType_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "BasisPxType_OTHERS", VALUEFUNC(_wrap_BasisPxType_OTHERS_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PERCENTAGE", VALUEFUNC(_wrap_PriceType_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PER_UNIT", VALUEFUNC(_wrap_PriceType_PER_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_FIXED_AMOUNT", VALUEFUNC(_wrap_PriceType_FIXED_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_DISCOUNT", VALUEFUNC(_wrap_PriceType_DISCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_PREMIUM", VALUEFUNC(_wrap_PriceType_PREMIUM_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_SPREAD", VALUEFUNC(_wrap_PriceType_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_TED_PRICE", VALUEFUNC(_wrap_PriceType_TED_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_TED_YIELD", VALUEFUNC(_wrap_PriceType_TED_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "PriceType_YIELD", VALUEFUNC(_wrap_PriceType_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "GTBookingInst_BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION", VALUEFUNC(_wrap_GTBookingInst_BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "GTBookingInst_ACCUMULATE_EXECUTIONS_UNTIL_ORDER_IS_FILLED_OR_EXPIRES", VALUEFUNC(_wrap_GTBookingInst_ACCUMULATE_EXECUTIONS_UNTIL_ORDER_IS_FILLED_OR_EXPIRES_get), 0);
  rb_define_singleton_method(mQuickfix, "GTBookingInst_ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE", VALUEFUNC(_wrap_GTBookingInst_ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_ACK", VALUEFUNC(_wrap_ListStatusType_ACK_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_RESPONSE", VALUEFUNC(_wrap_ListStatusType_RESPONSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_TIMED", VALUEFUNC(_wrap_ListStatusType_TIMED_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_EXECSTARTED", VALUEFUNC(_wrap_ListStatusType_EXECSTARTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_ALLDONE", VALUEFUNC(_wrap_ListStatusType_ALLDONE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListStatusType_ALERT", VALUEFUNC(_wrap_ListStatusType_ALERT_get), 0);
  rb_define_singleton_method(mQuickfix, "NetGrossInd_NET", VALUEFUNC(_wrap_NetGrossInd_NET_get), 0);
  rb_define_singleton_method(mQuickfix, "NetGrossInd_GROSS", VALUEFUNC(_wrap_NetGrossInd_GROSS_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_INBIDDINGPROCESS", VALUEFUNC(_wrap_ListOrderStatus_INBIDDINGPROCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_RECEIVEDFOREXECUTION", VALUEFUNC(_wrap_ListOrderStatus_RECEIVEDFOREXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_EXECUTING", VALUEFUNC(_wrap_ListOrderStatus_EXECUTING_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_CANCELING", VALUEFUNC(_wrap_ListOrderStatus_CANCELING_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_ALERT", VALUEFUNC(_wrap_ListOrderStatus_ALERT_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_ALL_DONE", VALUEFUNC(_wrap_ListOrderStatus_ALL_DONE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListOrderStatus_REJECT", VALUEFUNC(_wrap_ListOrderStatus_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "ListExecInstType_IMMEDIATE", VALUEFUNC(_wrap_ListExecInstType_IMMEDIATE_get), 0);
  rb_define_singleton_method(mQuickfix, "ListExecInstType_WAIT_FOR_EXECUTE_INSTRUCTION", VALUEFUNC(_wrap_ListExecInstType_WAIT_FOR_EXECUTE_INSTRUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_SELL_DRIVEN", VALUEFUNC(_wrap_ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_SELL_DRIVEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_TOP_UP", VALUEFUNC(_wrap_ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_TOP_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_WITHDRAW", VALUEFUNC(_wrap_ListExecInstType_EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_WITHDRAW_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejResponseTo_ORDER_CANCEL_REQUEST", VALUEFUNC(_wrap_CxlRejResponseTo_ORDER_CANCEL_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlRejResponseTo_ORDER_CANCEL_REPLACE_REQUEST", VALUEFUNC(_wrap_CxlRejResponseTo_ORDER_CANCEL_REPLACE_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegReportingType_SINGLE_SECURITY", VALUEFUNC(_wrap_MultiLegReportingType_SINGLE_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY", VALUEFUNC(_wrap_MultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegReportingType_MULTI_LEG_SECURITY", VALUEFUNC(_wrap_MultiLegReportingType_MULTI_LEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_BIC", VALUEFUNC(_wrap_PartyIDSource_BIC_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_GENERALLY_ACCEPTED_MARKET_PARTICIPANT_IDENTIFIER", VALUEFUNC(_wrap_PartyIDSource_GENERALLY_ACCEPTED_MARKET_PARTICIPANT_IDENTIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_PROPRIETARY_CUSTOM_CODE", VALUEFUNC(_wrap_PartyIDSource_PROPRIETARY_CUSTOM_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_ISO_COUNTRY_CODE", VALUEFUNC(_wrap_PartyIDSource_ISO_COUNTRY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_SETTLEMENT_ENTITY_LOCATION", VALUEFUNC(_wrap_PartyIDSource_SETTLEMENT_ENTITY_LOCATION_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_MIC", VALUEFUNC(_wrap_PartyIDSource_MIC_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_CSD_PARTICIPANT_MEMBER_CODE", VALUEFUNC(_wrap_PartyIDSource_CSD_PARTICIPANT_MEMBER_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_KOREAN_INVESTOR_ID", VALUEFUNC(_wrap_PartyIDSource_KOREAN_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_TAIWANESE_QUALIFIED_FOREIGN_INVESTOR_ID_QFII_FID", VALUEFUNC(_wrap_PartyIDSource_TAIWANESE_QUALIFIED_FOREIGN_INVESTOR_ID_QFII_FID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_TAIWANESE_TRADING_ACCOUNT", VALUEFUNC(_wrap_PartyIDSource_TAIWANESE_TRADING_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_MALAYSIAN_CENTRAL_DEPOSITORY_NUMBER", VALUEFUNC(_wrap_PartyIDSource_MALAYSIAN_CENTRAL_DEPOSITORY_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_CHINESE_B_SHARE", VALUEFUNC(_wrap_PartyIDSource_CHINESE_B_SHARE_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER", VALUEFUNC(_wrap_PartyIDSource_UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_US_SOCIAL_SECURITY_NUMBER", VALUEFUNC(_wrap_PartyIDSource_US_SOCIAL_SECURITY_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_US_EMPLOYER_IDENTIFICATION_NUMBER", VALUEFUNC(_wrap_PartyIDSource_US_EMPLOYER_IDENTIFICATION_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_AUSTRALIAN_BUSINESS_NUMBER", VALUEFUNC(_wrap_PartyIDSource_AUSTRALIAN_BUSINESS_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_AUSTRALIAN_TAX_FILE_NUMBER", VALUEFUNC(_wrap_PartyIDSource_AUSTRALIAN_TAX_FILE_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyIDSource_DIRECTED_BROKER", VALUEFUNC(_wrap_PartyIDSource_DIRECTED_BROKER_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_EXECUTING_FIRM", VALUEFUNC(_wrap_PartyRole_EXECUTING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_BROKER_OF_CREDIT", VALUEFUNC(_wrap_PartyRole_BROKER_OF_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CLIENT_ID", VALUEFUNC(_wrap_PartyRole_CLIENT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_CLEARING_FIRM", VALUEFUNC(_wrap_PartyRole_CLEARING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_INVESTOR_ID", VALUEFUNC(_wrap_PartyRole_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_INTRODUCING_FIRM", VALUEFUNC(_wrap_PartyRole_INTRODUCING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_ENTERING_FIRM", VALUEFUNC(_wrap_PartyRole_ENTERING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_LOCATE_LENDING_FIRM", VALUEFUNC(_wrap_PartyRole_LOCATE_LENDING_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "PartyRole_FUND_MANAGER_CLIENT_ID", VALUEFUNC(_wrap_PartyRole_FUND_MANAGER_CLIENT_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_AGENCY", VALUEFUNC(_wrap_Product_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_COMMODITY", VALUEFUNC(_wrap_Product_COMMODITY_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_CORPORATE", VALUEFUNC(_wrap_Product_CORPORATE_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_CURRENCY", VALUEFUNC(_wrap_Product_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_EQUITY", VALUEFUNC(_wrap_Product_EQUITY_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_GOVERNMENT", VALUEFUNC(_wrap_Product_GOVERNMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_INDEX", VALUEFUNC(_wrap_Product_INDEX_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_LOAN", VALUEFUNC(_wrap_Product_LOAN_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_MONEYMARKET", VALUEFUNC(_wrap_Product_MONEYMARKET_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_MORTGAGE", VALUEFUNC(_wrap_Product_MORTGAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_MUNICIPAL", VALUEFUNC(_wrap_Product_MUNICIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_OTHER", VALUEFUNC(_wrap_Product_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "Product_FINANCING", VALUEFUNC(_wrap_Product_FINANCING_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_SHARES", VALUEFUNC(_wrap_QuantityType_SHARES_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_BONDS", VALUEFUNC(_wrap_QuantityType_BONDS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_CURRENTFACE", VALUEFUNC(_wrap_QuantityType_CURRENTFACE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_ORIGINALFACE", VALUEFUNC(_wrap_QuantityType_ORIGINALFACE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_CURRENCY", VALUEFUNC(_wrap_QuantityType_CURRENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_CONTRACTS", VALUEFUNC(_wrap_QuantityType_CONTRACTS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_OTHER", VALUEFUNC(_wrap_QuantityType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuantityType_PAR", VALUEFUNC(_wrap_QuantityType_PAR_get), 0);
  rb_define_singleton_method(mQuickfix, "RoundingDirection_ROUND_TO_NEAREST", VALUEFUNC(_wrap_RoundingDirection_ROUND_TO_NEAREST_get), 0);
  rb_define_singleton_method(mQuickfix, "RoundingDirection_ROUND_DOWN", VALUEFUNC(_wrap_RoundingDirection_ROUND_DOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "RoundingDirection_ROUND_UP", VALUEFUNC(_wrap_RoundingDirection_ROUND_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_CREST", VALUEFUNC(_wrap_DistribPaymentMethod_CREST_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_NSCC", VALUEFUNC(_wrap_DistribPaymentMethod_NSCC_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_EUROCLEAR", VALUEFUNC(_wrap_DistribPaymentMethod_EUROCLEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_CLEARSTREAM", VALUEFUNC(_wrap_DistribPaymentMethod_CLEARSTREAM_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_CHEQUE", VALUEFUNC(_wrap_DistribPaymentMethod_CHEQUE_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_TELEGRAPHIC_TRANSFER", VALUEFUNC(_wrap_DistribPaymentMethod_TELEGRAPHIC_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_FEDWIRE", VALUEFUNC(_wrap_DistribPaymentMethod_FEDWIRE_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_DIRECT_CREDIT", VALUEFUNC(_wrap_DistribPaymentMethod_DIRECT_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "DistribPaymentMethod_ACH_CREDIT", VALUEFUNC(_wrap_DistribPaymentMethod_ACH_CREDIT_get), 0);
  rb_define_singleton_method(mQuickfix, "CancellationRights_NO_EXECUTION_ONLY", VALUEFUNC(_wrap_CancellationRights_NO_EXECUTION_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "CancellationRights_NO_WAIVER_AGREEMENT", VALUEFUNC(_wrap_CancellationRights_NO_WAIVER_AGREEMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CancellationRights_NO_INSTITUTIONAL", VALUEFUNC(_wrap_CancellationRights_NO_INSTITUTIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "MoneyLaunderingStatus_PASSED", VALUEFUNC(_wrap_MoneyLaunderingStatus_PASSED_get), 0);
  rb_define_singleton_method(mQuickfix, "MoneyLaunderingStatus_NOT_CHECKED", VALUEFUNC(_wrap_MoneyLaunderingStatus_NOT_CHECKED_get), 0);
  rb_define_singleton_method(mQuickfix, "MoneyLaunderingStatus_EXEMPT_BELOW_THE_LIMIT", VALUEFUNC(_wrap_MoneyLaunderingStatus_EXEMPT_BELOW_THE_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MoneyLaunderingStatus_EXEMPT_CLIENT_MONEY_TYPE_EXEMPTION", VALUEFUNC(_wrap_MoneyLaunderingStatus_EXEMPT_CLIENT_MONEY_TYPE_EXEMPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "MoneyLaunderingStatus_EXEMPT_AUTHORISED_CREDIT_OR_FINANCIAL_INSTITUTION", VALUEFUNC(_wrap_MoneyLaunderingStatus_EXEMPT_AUTHORISED_CREDIT_OR_FINANCIAL_INSTITUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_BID_PRICE", VALUEFUNC(_wrap_ExecPriceType_BID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_CREATION_PRICE", VALUEFUNC(_wrap_ExecPriceType_CREATION_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_PERCENT", VALUEFUNC(_wrap_ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT", VALUEFUNC(_wrap_ExecPriceType_CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_OFFER_PRICE", VALUEFUNC(_wrap_ExecPriceType_OFFER_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_PERCENT", VALUEFUNC(_wrap_ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT", VALUEFUNC(_wrap_ExecPriceType_OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecPriceType_SINGLE_PRICE", VALUEFUNC(_wrap_ExecPriceType_SINGLE_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_NEW", VALUEFUNC(_wrap_TradeReportTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_CANCEL", VALUEFUNC(_wrap_TradeReportTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_REPLACE", VALUEFUNC(_wrap_TradeReportTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_RELEASE", VALUEFUNC(_wrap_TradeReportTransType_RELEASE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportTransType_REVERSE", VALUEFUNC(_wrap_TradeReportTransType_REVERSE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_CREST", VALUEFUNC(_wrap_PaymentMethod_CREST_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_NSCC", VALUEFUNC(_wrap_PaymentMethod_NSCC_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_EUROCLEAR", VALUEFUNC(_wrap_PaymentMethod_EUROCLEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_CLEARSTREAM", VALUEFUNC(_wrap_PaymentMethod_CLEARSTREAM_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_CHEQUE", VALUEFUNC(_wrap_PaymentMethod_CHEQUE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_TELEGRAPHIC_TRANSFER", VALUEFUNC(_wrap_PaymentMethod_TELEGRAPHIC_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_FEDWIRE", VALUEFUNC(_wrap_PaymentMethod_FEDWIRE_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_DEBIT_CARD", VALUEFUNC(_wrap_PaymentMethod_DEBIT_CARD_get), 0);
  rb_define_singleton_method(mQuickfix, "PaymentMethod_DIRECT_DEBIT", VALUEFUNC(_wrap_PaymentMethod_DIRECT_DEBIT_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_NONE", VALUEFUNC(_wrap_TaxAdvantageType_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_MAXI_ISA", VALUEFUNC(_wrap_TaxAdvantageType_MAXI_ISA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_TESSA", VALUEFUNC(_wrap_TaxAdvantageType_TESSA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_MINI_CASH_ISA", VALUEFUNC(_wrap_TaxAdvantageType_MINI_CASH_ISA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_MINI_STOCKS_AND_SHARES_ISA", VALUEFUNC(_wrap_TaxAdvantageType_MINI_STOCKS_AND_SHARES_ISA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_MINI_INSURANCE_ISA", VALUEFUNC(_wrap_TaxAdvantageType_MINI_INSURANCE_ISA_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_CURRENT_YEAR_PAYMENT", VALUEFUNC(_wrap_TaxAdvantageType_CURRENT_YEAR_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_PRIOR_YEAR_PAYMENT", VALUEFUNC(_wrap_TaxAdvantageType_PRIOR_YEAR_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_ASSET_TRANSFER", VALUEFUNC(_wrap_TaxAdvantageType_ASSET_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_EMPLOYEE_PRIOR_YEAR", VALUEFUNC(_wrap_TaxAdvantageType_EMPLOYEE_PRIOR_YEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "TaxAdvantageType_OTHER", VALUEFUNC(_wrap_TaxAdvantageType_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "FundRenewWaiv_YES", VALUEFUNC(_wrap_FundRenewWaiv_YES_get), 0);
  rb_define_singleton_method(mQuickfix, "FundRenewWaiv_NO", VALUEFUNC(_wrap_FundRenewWaiv_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistStatus_ACCEPTED", VALUEFUNC(_wrap_RegistStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistStatus_REJECTED", VALUEFUNC(_wrap_RegistStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistStatus_HELD", VALUEFUNC(_wrap_RegistStatus_HELD_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistStatus_REMINDER", VALUEFUNC(_wrap_RegistStatus_REMINDER_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_ACCOUNT_TYPE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_ACCOUNT_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_TAX_EXEMPT_TYPE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_TAX_EXEMPT_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_OWNERSHIP_TYPE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_OWNERSHIP_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_NO_REG_DETLS", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_NO_REG_DETLS_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_REG_SEQ_NO", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_REG_SEQ_NO_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_REG_DTLS", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_REG_DTLS_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_MAILING_DTLS", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_MAILING_DTLS_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_MAILING_INST", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_MAILING_INST_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_ID", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_ID_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_ID_SOURCE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_ID_SOURCE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_DATE_OF_BIRTH", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_DATE_OF_BIRTH_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_COUNTRY_OF_RESIDENCE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_INVESTOR_COUNTRY_OF_RESIDENCE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_NODISTRIBINSTNS", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_NODISTRIBINSTNS_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_DISTRIB_PERCENTAGE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_DISTRIB_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_DISTRIB_PAYMENT_METHOD", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_DISTRIB_PAYMENT_METHOD_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NAME", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NAME_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_CODE", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NUM", VALUEFUNC(_wrap_RegistRejReasonCode_INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NUM_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistRejReasonCode_OTHER", VALUEFUNC(_wrap_RegistRejReasonCode_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistTransType_NEW", VALUEFUNC(_wrap_RegistTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistTransType_REPLACE", VALUEFUNC(_wrap_RegistTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "RegistTransType_CANCEL", VALUEFUNC(_wrap_RegistTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnershipType_JOINT_INVESTORS", VALUEFUNC(_wrap_OwnershipType_JOINT_INVESTORS_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnershipType_TENANTS_IN_COMMON", VALUEFUNC(_wrap_OwnershipType_TENANTS_IN_COMMON_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnershipType_JOINT_TRUSTEES", VALUEFUNC(_wrap_OwnershipType_JOINT_TRUSTEES_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_COMMISSION_AMOUNT", VALUEFUNC(_wrap_ContAmtType_COMMISSION_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_COMMISSION_PERCENT", VALUEFUNC(_wrap_ContAmtType_COMMISSION_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_INITIAL_CHARGE_AMOUNT", VALUEFUNC(_wrap_ContAmtType_INITIAL_CHARGE_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_INITIAL_CHARGE_PERCENT", VALUEFUNC(_wrap_ContAmtType_INITIAL_CHARGE_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_DISCOUNT_AMOUNT", VALUEFUNC(_wrap_ContAmtType_DISCOUNT_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_DISCOUNT_PERCENT", VALUEFUNC(_wrap_ContAmtType_DISCOUNT_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_DILUTION_LEVY_AMOUNT", VALUEFUNC(_wrap_ContAmtType_DILUTION_LEVY_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_DILUTION_LEVY_PERCENT", VALUEFUNC(_wrap_ContAmtType_DILUTION_LEVY_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "ContAmtType_EXIT_CHARGE_AMOUNT", VALUEFUNC(_wrap_ContAmtType_EXIT_CHARGE_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_INDIVIDUAL_INVESTOR", VALUEFUNC(_wrap_OwnerType_INDIVIDUAL_INVESTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_PUBLIC_COMPANY", VALUEFUNC(_wrap_OwnerType_PUBLIC_COMPANY_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_PRIVATE_COMPANY", VALUEFUNC(_wrap_OwnerType_PRIVATE_COMPANY_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_INDIVIDUAL_TRUSTEE", VALUEFUNC(_wrap_OwnerType_INDIVIDUAL_TRUSTEE_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_COMPANY_TRUSTEE", VALUEFUNC(_wrap_OwnerType_COMPANY_TRUSTEE_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_PENSION_PLAN", VALUEFUNC(_wrap_OwnerType_PENSION_PLAN_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT", VALUEFUNC(_wrap_OwnerType_CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_TRUSTS", VALUEFUNC(_wrap_OwnerType_TRUSTS_get), 0);
  rb_define_singleton_method(mQuickfix, "OwnerType_FIDUCIARIES", VALUEFUNC(_wrap_OwnerType_FIDUCIARIES_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_AGENCY", VALUEFUNC(_wrap_OrderCapacity_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_PROPRIETARY", VALUEFUNC(_wrap_OrderCapacity_PROPRIETARY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_INDIVIDUAL", VALUEFUNC(_wrap_OrderCapacity_INDIVIDUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_PRINCIPAL", VALUEFUNC(_wrap_OrderCapacity_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_RISKLESS_PRINCIPAL", VALUEFUNC(_wrap_OrderCapacity_RISKLESS_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderCapacity_AGENT_FOR_OTHER_MEMBER", VALUEFUNC(_wrap_OrderCapacity_AGENT_FOR_OTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_PROGRAM_TRADE", VALUEFUNC(_wrap_OrderRestrictions_PROGRAM_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_INDEX_ARBITRAGE", VALUEFUNC(_wrap_OrderRestrictions_INDEX_ARBITRAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_NON_INDEX_ARBITRAGE", VALUEFUNC(_wrap_OrderRestrictions_NON_INDEX_ARBITRAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_COMPETING_MARKET_MAKER", VALUEFUNC(_wrap_OrderRestrictions_COMPETING_MARKET_MAKER_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_SECURITY", VALUEFUNC(_wrap_OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_UNDERLYING_SECURITY_OF_A_DERIVATIVE_SECURITY", VALUEFUNC(_wrap_OrderRestrictions_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_UNDERLYING_SECURITY_OF_A_DERIVATIVE_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_FOREIGN_ENTITY", VALUEFUNC(_wrap_OrderRestrictions_FOREIGN_ENTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_EXTERNAL_MARKET_PARTICIPANT", VALUEFUNC(_wrap_OrderRestrictions_EXTERNAL_MARKET_PARTICIPANT_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE", VALUEFUNC(_wrap_OrderRestrictions_EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "OrderRestrictions_RISKLESS_ARBITRAGE", VALUEFUNC(_wrap_OrderRestrictions_RISKLESS_ARBITRAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_PRODUCT", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_CFICODE", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_CFICODE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITYTYPE", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_SECURITYTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ORDERS_FOR_A_TRADING_SESSION", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ORDERS_FOR_A_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRequestType_CANCEL_ALL_ORDERS", VALUEFUNC(_wrap_MassCancelRequestType_CANCEL_ALL_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_REQUEST_REJECTED", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_REQUEST_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_PRODUCT", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_CFICODE", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_CFICODE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITYTYPE", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_SECURITYTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ORDERS_FOR_A_TRADING_SESSION", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ORDERS_FOR_A_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelResponse_CANCEL_ALL_ORDERS", VALUEFUNC(_wrap_MassCancelResponse_CANCEL_ALL_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_MASS_CANCEL_NOT_SUPPORTED", VALUEFUNC(_wrap_MassCancelRejectReason_MASS_CANCEL_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_UNDERLYING", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_UNDERLYING_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_PRODUCT", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_CFICODE", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_CFICODE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_SECURITY_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassCancelRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION", VALUEFUNC(_wrap_MassCancelRejectReason_INVALID_OR_UNKNOWN_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteType_INDICATIVE", VALUEFUNC(_wrap_QuoteType_INDICATIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteType_TRADEABLE", VALUEFUNC(_wrap_QuoteType_TRADEABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteType_RESTRICTED_TRADEABLE", VALUEFUNC(_wrap_QuoteType_RESTRICTED_TRADEABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteType_COUNTER", VALUEFUNC(_wrap_QuoteType_COUNTER_get), 0);
  rb_define_singleton_method(mQuickfix, "CashMargin_CASH", VALUEFUNC(_wrap_CashMargin_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "CashMargin_MARGIN_OPEN", VALUEFUNC(_wrap_CashMargin_MARGIN_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "CashMargin_MARGIN_CLOSE", VALUEFUNC(_wrap_CashMargin_MARGIN_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "Scope_LOCAL", VALUEFUNC(_wrap_Scope_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Scope_NATIONAL", VALUEFUNC(_wrap_Scope_NATIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Scope_GLOBAL", VALUEFUNC(_wrap_Scope_GLOBAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_CROSS_TRADE_WHICH_IS_EXECUTED_COMPLETELY_OR_NOT", VALUEFUNC(_wrap_CrossType_CROSS_TRADE_WHICH_IS_EXECUTED_COMPLETELY_OR_NOT_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_CROSS_TRADE_WHICH_IS_EXECUTED_PARTIALLY_AND_THE_REST_IS_CANCELLED", VALUEFUNC(_wrap_CrossType_CROSS_TRADE_WHICH_IS_EXECUTED_PARTIALLY_AND_THE_REST_IS_CANCELLED_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_CROSS_TRADE_WHICH_IS_PARTIALLY_EXECUTED_WITH_THE_UNFILLED_PORTIONS_REMAINING_ACTIVE", VALUEFUNC(_wrap_CrossType_CROSS_TRADE_WHICH_IS_PARTIALLY_EXECUTED_WITH_THE_UNFILLED_PORTIONS_REMAINING_ACTIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossType_CROSS_TRADE_IS_EXECUTED_WITH_EXISTING_ORDERS_WITH_THE_SAME_PRICE", VALUEFUNC(_wrap_CrossType_CROSS_TRADE_IS_EXECUTED_WITH_EXISTING_ORDERS_WITH_THE_SAME_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossPrioritization_NONE", VALUEFUNC(_wrap_CrossPrioritization_NONE_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossPrioritization_BUY_SIDE_IS_PRIORITIZED", VALUEFUNC(_wrap_CrossPrioritization_BUY_SIDE_IS_PRIORITIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "CrossPrioritization_SELL_SIDE_IS_PRIORITIZED", VALUEFUNC(_wrap_CrossPrioritization_SELL_SIDE_IS_PRIORITIZED_get), 0);
  rb_define_singleton_method(mQuickfix, "NoSides_ONE_SIDE", VALUEFUNC(_wrap_NoSides_ONE_SIDE_get), 0);
  rb_define_singleton_method(mQuickfix, "NoSides_BOTH_SIDES", VALUEFUNC(_wrap_NoSides_BOTH_SIDES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_SYMBOL", VALUEFUNC(_wrap_SecurityListRequestType_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_SECURITYTYPE_AND_OR_CFICODE", VALUEFUNC(_wrap_SecurityListRequestType_SECURITYTYPE_AND_OR_CFICODE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_PRODUCT", VALUEFUNC(_wrap_SecurityListRequestType_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_TRADINGSESSIONID", VALUEFUNC(_wrap_SecurityListRequestType_TRADINGSESSIONID_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityListRequestType_ALL_SECURITIES", VALUEFUNC(_wrap_SecurityListRequestType_ALL_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_VALID_REQUEST", VALUEFUNC(_wrap_SecurityRequestResult_VALID_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_INVALID_OR_UNSUPPORTED_REQUEST", VALUEFUNC(_wrap_SecurityRequestResult_INVALID_OR_UNSUPPORTED_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_NO_INSTRUMENTS_FOUND_THAT_MATCH_SELECTION_CRITERIA", VALUEFUNC(_wrap_SecurityRequestResult_NO_INSTRUMENTS_FOUND_THAT_MATCH_SELECTION_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA", VALUEFUNC(_wrap_SecurityRequestResult_NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE", VALUEFUNC(_wrap_SecurityRequestResult_INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE_get), 0);
  rb_define_singleton_method(mQuickfix, "SecurityRequestResult_REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED", VALUEFUNC(_wrap_SecurityRequestResult_REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegRptTypeReq_REPORT_BY_MULITLEG_SECURITY_ONLY", VALUEFUNC(_wrap_MultiLegRptTypeReq_REPORT_BY_MULITLEG_SECURITY_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegRptTypeReq_REPORT_BY_MULTILEG_SECURITY_AND_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY", VALUEFUNC(_wrap_MultiLegRptTypeReq_REPORT_BY_MULTILEG_SECURITY_AND_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MultiLegRptTypeReq_REPORT_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_ONLY", VALUEFUNC(_wrap_MultiLegRptTypeReq_REPORT_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "TradSesStatusRejReason_UNKNOWN_OR_INVALID_TRADINGSESSIONID", VALUEFUNC(_wrap_TradSesStatusRejReason_UNKNOWN_OR_INVALID_TRADINGSESSIONID_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestType_ALL_TRADES", VALUEFUNC(_wrap_TradeRequestType_ALL_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestType_MATCHED_TRADES_MATCHING_CRITERIA_PROVIDED_ON_REQUEST", VALUEFUNC(_wrap_TradeRequestType_MATCHED_TRADES_MATCHING_CRITERIA_PROVIDED_ON_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestType_UNMATCHED_TRADES_THAT_MATCH_CRITERIA", VALUEFUNC(_wrap_TradeRequestType_UNMATCHED_TRADES_THAT_MATCH_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestType_UNREPORTED_TRADES_THAT_MATCH_CRITERIA", VALUEFUNC(_wrap_TradeRequestType_UNREPORTED_TRADES_THAT_MATCH_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestType_ADVISORIES_THAT_MATCH_CRITERIA", VALUEFUNC(_wrap_TradeRequestType_ADVISORIES_THAT_MATCH_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchStatus_COMPARED_MATCHED_OR_AFFIRMED", VALUEFUNC(_wrap_MatchStatus_COMPARED_MATCHED_OR_AFFIRMED_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchStatus_UNCOMPARED_UNMATCHED_OR_UNAFFIRMED", VALUEFUNC(_wrap_MatchStatus_UNCOMPARED_UNMATCHED_OR_UNAFFIRMED_get), 0);
  rb_define_singleton_method(mQuickfix, "MatchStatus_ADVISORY_OR_ALERT", VALUEFUNC(_wrap_MatchStatus_ADVISORY_OR_ALERT_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_PROCESS_NORMALLY", VALUEFUNC(_wrap_ClearingInstruction_PROCESS_NORMALLY_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_EXCLUDE_FROM_ALL_NETTING", VALUEFUNC(_wrap_ClearingInstruction_EXCLUDE_FROM_ALL_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_BILATERAL_NETTING_ONLY", VALUEFUNC(_wrap_ClearingInstruction_BILATERAL_NETTING_ONLY_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_EX_CLEARING", VALUEFUNC(_wrap_ClearingInstruction_EX_CLEARING_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_SPECIAL_TRADE", VALUEFUNC(_wrap_ClearingInstruction_SPECIAL_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_MULTILATERAL_NETTING", VALUEFUNC(_wrap_ClearingInstruction_MULTILATERAL_NETTING_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_CLEAR_AGAINST_CENTRAL_COUNTERPARTY", VALUEFUNC(_wrap_ClearingInstruction_CLEAR_AGAINST_CENTRAL_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_EXCLUDE_FROM_CENTRAL_COUNTERPARTY", VALUEFUNC(_wrap_ClearingInstruction_EXCLUDE_FROM_CENTRAL_COUNTERPARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_MANUAL_MODE", VALUEFUNC(_wrap_ClearingInstruction_MANUAL_MODE_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingInstruction_AUTOMATIC_POSTING_MODE", VALUEFUNC(_wrap_ClearingInstruction_AUTOMATIC_POSTING_MODE_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS", VALUEFUNC(_wrap_AccountType_ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS", VALUEFUNC(_wrap_AccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_HOUSE_TRADER", VALUEFUNC(_wrap_AccountType_HOUSE_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_FLOOR_TRADER", VALUEFUNC(_wrap_AccountType_FLOOR_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED", VALUEFUNC(_wrap_AccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED", VALUEFUNC(_wrap_AccountType_ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED_get), 0);
  rb_define_singleton_method(mQuickfix, "AccountType_JOINT_BACKOFFICE_ACCOUNT", VALUEFUNC(_wrap_AccountType_JOINT_BACKOFFICE_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT", VALUEFUNC(_wrap_CustOrderCapacity_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT", VALUEFUNC(_wrap_CustOrderCapacity_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER", VALUEFUNC(_wrap_CustOrderCapacity_MEMBER_TRADING_FOR_ANOTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustOrderCapacity_ALL_OTHER", VALUEFUNC(_wrap_CustOrderCapacity_ALL_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PRODUCT", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PRODUCT_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_CFICODE", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_CFICODE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITYTYPE", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_SECURITYTYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ALL_ORDERS", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ALL_ORDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PARTYID", VALUEFUNC(_wrap_MassStatusReqType_STATUS_FOR_ORDERS_FOR_A_PARTYID_get), 0);
  rb_define_singleton_method(mQuickfix, "DayBookingInst_CAN_TRIGGER_BOOKING_WITHOUT_REFERENCE_TO_THE_ORDER_INITIATOR", VALUEFUNC(_wrap_DayBookingInst_CAN_TRIGGER_BOOKING_WITHOUT_REFERENCE_TO_THE_ORDER_INITIATOR_get), 0);
  rb_define_singleton_method(mQuickfix, "DayBookingInst_SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING", VALUEFUNC(_wrap_DayBookingInst_SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING_get), 0);
  rb_define_singleton_method(mQuickfix, "DayBookingInst_ACCUMULATE", VALUEFUNC(_wrap_DayBookingInst_ACCUMULATE_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingUnit_EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT", VALUEFUNC(_wrap_BookingUnit_EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingUnit_AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_AND_BOOK_ONE_TRADE_PER_ORDER", VALUEFUNC(_wrap_BookingUnit_AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_AND_BOOK_ONE_TRADE_PER_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingUnit_AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_SIDE_AND_SETTLEMENT_DATE", VALUEFUNC(_wrap_BookingUnit_AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_SIDE_AND_SETTLEMENT_DATE_get), 0);
  rb_define_singleton_method(mQuickfix, "PreallocMethod_PRO_RATA", VALUEFUNC(_wrap_PreallocMethod_PRO_RATA_get), 0);
  rb_define_singleton_method(mQuickfix, "PreallocMethod_DO_NOT_PRO_RATA", VALUEFUNC(_wrap_PreallocMethod_DO_NOT_PRO_RATA_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_CALCULATED", VALUEFUNC(_wrap_AllocType_CALCULATED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_PRELIMINARY", VALUEFUNC(_wrap_AllocType_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_READY_TO_BOOK_SINGLE_ORDER", VALUEFUNC(_wrap_AllocType_READY_TO_BOOK_SINGLE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_WAREHOUSE_INSTRUCTION", VALUEFUNC(_wrap_AllocType_WAREHOUSE_INSTRUCTION_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocType_REQUEST_TO_INTERMEDIARY", VALUEFUNC(_wrap_AllocType_REQUEST_TO_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_CBOE_MEMBER", VALUEFUNC(_wrap_ClearingFeeIndicator_CBOE_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_NON_MEMBER_AND_CUSTOMER", VALUEFUNC(_wrap_ClearingFeeIndicator_NON_MEMBER_AND_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_EQUITY_MEMBER_AND_CLEARING_MEMBER", VALUEFUNC(_wrap_ClearingFeeIndicator_EQUITY_MEMBER_AND_CLEARING_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_FULL_AND_ASSOCIATE_MEMBER_TRADING_FOR_OWN_ACCOUNT_AND_AS_FLOOR_BROKERS", VALUEFUNC(_wrap_ClearingFeeIndicator_FULL_AND_ASSOCIATE_MEMBER_TRADING_FOR_OWN_ACCOUNT_AND_AS_FLOOR_BROKERS_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_FIRMS_106H_AND_106J", VALUEFUNC(_wrap_ClearingFeeIndicator_FIRMS_106H_AND_106J_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_GIM_IDEM_AND_COM_MEMBERSHIP_INTEREST_HOLDERS", VALUEFUNC(_wrap_ClearingFeeIndicator_GIM_IDEM_AND_COM_MEMBERSHIP_INTEREST_HOLDERS_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_LESSEE_AND_106F_EMPLOYEES", VALUEFUNC(_wrap_ClearingFeeIndicator_LESSEE_AND_106F_EMPLOYEES_get), 0);
  rb_define_singleton_method(mQuickfix, "ClearingFeeIndicator_ALL_OTHER_OWNERSHIP_TYPES", VALUEFUNC(_wrap_ClearingFeeIndicator_ALL_OTHER_OWNERSHIP_TYPES_get), 0);
  rb_define_singleton_method(mQuickfix, "PriorityIndicator_PRIORITY_UNCHANGED", VALUEFUNC(_wrap_PriorityIndicator_PRIORITY_UNCHANGED_get), 0);
  rb_define_singleton_method(mQuickfix, "PriorityIndicator_LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE", VALUEFUNC(_wrap_PriorityIndicator_LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_UNKNOWN_SYMBOL", VALUEFUNC(_wrap_QuoteRequestRejectReason_UNKNOWN_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_EXCHANGE_CLOSED", VALUEFUNC(_wrap_QuoteRequestRejectReason_EXCHANGE_CLOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT", VALUEFUNC(_wrap_QuoteRequestRejectReason_QUOTE_REQUEST_EXCEEDS_LIMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_TOO_LATE_TO_ENTER", VALUEFUNC(_wrap_QuoteRequestRejectReason_TOO_LATE_TO_ENTER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_INVALID_PRICE", VALUEFUNC(_wrap_QuoteRequestRejectReason_INVALID_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_NOT_AUTHORIZED_TO_REQUEST_QUOTE", VALUEFUNC(_wrap_QuoteRequestRejectReason_NOT_AUTHORIZED_TO_REQUEST_QUOTE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_NO_MATCH_FOR_INQUIRY", VALUEFUNC(_wrap_QuoteRequestRejectReason_NO_MATCH_FOR_INQUIRY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_NO_MARKET_FOR_INSTRUMENT", VALUEFUNC(_wrap_QuoteRequestRejectReason_NO_MARKET_FOR_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRequestRejectReason_NO_INVENTORY", VALUEFUNC(_wrap_QuoteRequestRejectReason_NO_INVENTORY_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_BIC", VALUEFUNC(_wrap_AcctIDSource_BIC_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_SID_CODE", VALUEFUNC(_wrap_AcctIDSource_SID_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_TFM", VALUEFUNC(_wrap_AcctIDSource_TFM_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_OMGEO", VALUEFUNC(_wrap_AcctIDSource_OMGEO_get), 0);
  rb_define_singleton_method(mQuickfix, "AcctIDSource_DTCC_CODE", VALUEFUNC(_wrap_AcctIDSource_DTCC_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmStatus_RECEIVED", VALUEFUNC(_wrap_ConfirmStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmStatus_MISMATCHED_ACCOUNT", VALUEFUNC(_wrap_ConfirmStatus_MISMATCHED_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmStatus_MISSING_SETTLEMENT_INSTRUCTIONS", VALUEFUNC(_wrap_ConfirmStatus_MISSING_SETTLEMENT_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmStatus_CONFIRMED", VALUEFUNC(_wrap_ConfirmStatus_CONFIRMED_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmStatus_REQUEST_REJECTED", VALUEFUNC(_wrap_ConfirmStatus_REQUEST_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmTransType_NEW", VALUEFUNC(_wrap_ConfirmTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmTransType_REPLACE", VALUEFUNC(_wrap_ConfirmTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmTransType_CANCEL", VALUEFUNC(_wrap_ConfirmTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryForm_BOOKENTRY", VALUEFUNC(_wrap_DeliveryForm_BOOKENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryForm_BEARER", VALUEFUNC(_wrap_DeliveryForm_BEARER_get), 0);
  rb_define_singleton_method(mQuickfix, "LegSwapType_PAR_FOR_PAR", VALUEFUNC(_wrap_LegSwapType_PAR_FOR_PAR_get), 0);
  rb_define_singleton_method(mQuickfix, "LegSwapType_MODIFIED_DURATION", VALUEFUNC(_wrap_LegSwapType_MODIFIED_DURATION_get), 0);
  rb_define_singleton_method(mQuickfix, "LegSwapType_RISK", VALUEFUNC(_wrap_LegSwapType_RISK_get), 0);
  rb_define_singleton_method(mQuickfix, "LegSwapType_PROCEEDS", VALUEFUNC(_wrap_LegSwapType_PROCEEDS_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PERCENT", VALUEFUNC(_wrap_QuotePriceType_PERCENT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PER_SHARE", VALUEFUNC(_wrap_QuotePriceType_PER_SHARE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_FIXED_AMOUNT", VALUEFUNC(_wrap_QuotePriceType_FIXED_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_DISCOUNT", VALUEFUNC(_wrap_QuotePriceType_DISCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_PREMIUM", VALUEFUNC(_wrap_QuotePriceType_PREMIUM_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_BASIS_POINTS_RELATIVE_TO_BENCHMARK", VALUEFUNC(_wrap_QuotePriceType_BASIS_POINTS_RELATIVE_TO_BENCHMARK_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_TED_PRICE", VALUEFUNC(_wrap_QuotePriceType_TED_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_TED_YIELD", VALUEFUNC(_wrap_QuotePriceType_TED_YIELD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuotePriceType_YIELD_SPREAD", VALUEFUNC(_wrap_QuotePriceType_YIELD_SPREAD_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_HIT_LIFT", VALUEFUNC(_wrap_QuoteRespType_HIT_LIFT_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_COUNTER", VALUEFUNC(_wrap_QuoteRespType_COUNTER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_EXPIRED", VALUEFUNC(_wrap_QuoteRespType_EXPIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_COVER", VALUEFUNC(_wrap_QuoteRespType_COVER_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_DONE_AWAY", VALUEFUNC(_wrap_QuoteRespType_DONE_AWAY_get), 0);
  rb_define_singleton_method(mQuickfix, "QuoteRespType_PASS", VALUEFUNC(_wrap_QuoteRespType_PASS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_TRANSACTION_QUANTITY", VALUEFUNC(_wrap_PosType_TRANSACTION_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_INTRA_SPREAD_QTY", VALUEFUNC(_wrap_PosType_INTRA_SPREAD_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_INTER_SPREAD_QTY", VALUEFUNC(_wrap_PosType_INTER_SPREAD_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_END_OF_DAY_QTY", VALUEFUNC(_wrap_PosType_END_OF_DAY_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_START_OF_DAY_QTY", VALUEFUNC(_wrap_PosType_START_OF_DAY_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_OPTION_EXERCISE_QTY", VALUEFUNC(_wrap_PosType_OPTION_EXERCISE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_OPTION_ASSIGNMENT", VALUEFUNC(_wrap_PosType_OPTION_ASSIGNMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_TRANSACTION_FROM_EXERCISE", VALUEFUNC(_wrap_PosType_TRANSACTION_FROM_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_TRANSACTION_FROM_ASSIGNMENT", VALUEFUNC(_wrap_PosType_TRANSACTION_FROM_ASSIGNMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_PIT_TRADE_QTY", VALUEFUNC(_wrap_PosType_PIT_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_TRANSFER_TRADE_QTY", VALUEFUNC(_wrap_PosType_TRANSFER_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_ELECTRONIC_TRADE_QTY", VALUEFUNC(_wrap_PosType_ELECTRONIC_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_ALLOCATION_TRADE_QTY", VALUEFUNC(_wrap_PosType_ALLOCATION_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_ADJUSTMENT_QTY", VALUEFUNC(_wrap_PosType_ADJUSTMENT_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_AS_OF_TRADE_QTY", VALUEFUNC(_wrap_PosType_AS_OF_TRADE_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_DELIVERY_QTY", VALUEFUNC(_wrap_PosType_DELIVERY_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_TOTAL_TRANSACTION_QTY", VALUEFUNC(_wrap_PosType_TOTAL_TRANSACTION_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_CROSS_MARGIN_QTY", VALUEFUNC(_wrap_PosType_CROSS_MARGIN_QTY_get), 0);
  rb_define_singleton_method(mQuickfix, "PosType_INTEGRAL_SPLIT", VALUEFUNC(_wrap_PosType_INTEGRAL_SPLIT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosQtyStatus_SUBMITTED", VALUEFUNC(_wrap_PosQtyStatus_SUBMITTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosQtyStatus_ACCEPTED", VALUEFUNC(_wrap_PosQtyStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosQtyStatus_REJECTED", VALUEFUNC(_wrap_PosQtyStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_FINAL_MARK_TO_MARKET_AMOUNT", VALUEFUNC(_wrap_PosAmtType_FINAL_MARK_TO_MARKET_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_INCREMENTAL_MARK_TO_MARKET_AMOUNT", VALUEFUNC(_wrap_PosAmtType_INCREMENTAL_MARK_TO_MARKET_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_TRADE_VARIATION_AMOUNT", VALUEFUNC(_wrap_PosAmtType_TRADE_VARIATION_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_START_OF_DAY_MARK_TO_MARKET_AMOUNT", VALUEFUNC(_wrap_PosAmtType_START_OF_DAY_MARK_TO_MARKET_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_PREMIUM_AMOUNT", VALUEFUNC(_wrap_PosAmtType_PREMIUM_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_CASH_RESIDUAL_AMOUNT", VALUEFUNC(_wrap_PosAmtType_CASH_RESIDUAL_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_CASH_AMOUNT", VALUEFUNC(_wrap_PosAmtType_CASH_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosAmtType_VALUE_ADJUSTED_AMOUNT", VALUEFUNC(_wrap_PosAmtType_VALUE_ADJUSTED_AMOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_EXERCISE", VALUEFUNC(_wrap_PosTransType_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_DO_NOT_EXERCISE", VALUEFUNC(_wrap_PosTransType_DO_NOT_EXERCISE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_POSITION_ADJUSTMENT", VALUEFUNC(_wrap_PosTransType_POSITION_ADJUSTMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_POSITION_CHANGE_SUBMISSION_MARGIN_DISPOSITION", VALUEFUNC(_wrap_PosTransType_POSITION_CHANGE_SUBMISSION_MARGIN_DISPOSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "PosTransType_PLEDGE", VALUEFUNC(_wrap_PosTransType_PLEDGE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintAction_NEW", VALUEFUNC(_wrap_PosMaintAction_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintAction_REPLACE", VALUEFUNC(_wrap_PosMaintAction_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintAction_CANCEL", VALUEFUNC(_wrap_PosMaintAction_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "AdjustmentType_PROCESS_REQUEST_AS_MARGIN_DISPOSITION", VALUEFUNC(_wrap_AdjustmentType_PROCESS_REQUEST_AS_MARGIN_DISPOSITION_get), 0);
  rb_define_singleton_method(mQuickfix, "AdjustmentType_DELTA_PLUS", VALUEFUNC(_wrap_AdjustmentType_DELTA_PLUS_get), 0);
  rb_define_singleton_method(mQuickfix, "AdjustmentType_DELTA_MINUS", VALUEFUNC(_wrap_AdjustmentType_DELTA_MINUS_get), 0);
  rb_define_singleton_method(mQuickfix, "AdjustmentType_FINAL", VALUEFUNC(_wrap_AdjustmentType_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintStatus_ACCEPTED", VALUEFUNC(_wrap_PosMaintStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintStatus_ACCEPTED_WITH_WARNINGS", VALUEFUNC(_wrap_PosMaintStatus_ACCEPTED_WITH_WARNINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintStatus_REJECTED", VALUEFUNC(_wrap_PosMaintStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintStatus_COMPLETED", VALUEFUNC(_wrap_PosMaintStatus_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintStatus_COMPLETED_WITH_WARNINGS", VALUEFUNC(_wrap_PosMaintStatus_COMPLETED_WITH_WARNINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintResult_SUCCESSFUL_COMPLETION_NO_WARNINGS_OR_ERRORS", VALUEFUNC(_wrap_PosMaintResult_SUCCESSFUL_COMPLETION_NO_WARNINGS_OR_ERRORS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosMaintResult_REJECTED", VALUEFUNC(_wrap_PosMaintResult_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_POSITIONS", VALUEFUNC(_wrap_PosReqType_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_TRADES", VALUEFUNC(_wrap_PosReqType_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_EXERCISES", VALUEFUNC(_wrap_PosReqType_EXERCISES_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqType_ASSIGNMENTS", VALUEFUNC(_wrap_PosReqType_ASSIGNMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "ResponseTransportType_INBAND", VALUEFUNC(_wrap_ResponseTransportType_INBAND_get), 0);
  rb_define_singleton_method(mQuickfix, "ResponseTransportType_OUT_OF_BAND", VALUEFUNC(_wrap_ResponseTransportType_OUT_OF_BAND_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_VALID_REQUEST", VALUEFUNC(_wrap_PosReqResult_VALID_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_INVALID_OR_UNSUPPORTED_REQUEST", VALUEFUNC(_wrap_PosReqResult_INVALID_OR_UNSUPPORTED_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA", VALUEFUNC(_wrap_PosReqResult_NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_NOT_AUTHORIZED_TO_REQUEST_POSITIONS", VALUEFUNC(_wrap_PosReqResult_NOT_AUTHORIZED_TO_REQUEST_POSITIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_REQUEST_FOR_POSITION_NOT_SUPPORTED", VALUEFUNC(_wrap_PosReqResult_REQUEST_FOR_POSITION_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqResult_OTHER", VALUEFUNC(_wrap_PosReqResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqStatus_COMPLETED", VALUEFUNC(_wrap_PosReqStatus_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqStatus_COMPLETED_WITH_WARNINGS", VALUEFUNC(_wrap_PosReqStatus_COMPLETED_WITH_WARNINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "PosReqStatus_REJECTED", VALUEFUNC(_wrap_PosReqStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlPriceType_FINAL", VALUEFUNC(_wrap_SettlPriceType_FINAL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlPriceType_THEORETICAL", VALUEFUNC(_wrap_SettlPriceType_THEORETICAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AssignmentMethod_RANDOM", VALUEFUNC(_wrap_AssignmentMethod_RANDOM_get), 0);
  rb_define_singleton_method(mQuickfix, "AssignmentMethod_PRORATA", VALUEFUNC(_wrap_AssignmentMethod_PRORATA_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseMethod_AUTOMATIC", VALUEFUNC(_wrap_ExerciseMethod_AUTOMATIC_get), 0);
  rb_define_singleton_method(mQuickfix, "ExerciseMethod_MANUAL", VALUEFUNC(_wrap_ExerciseMethod_MANUAL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_SUCCESSFUL", VALUEFUNC(_wrap_TradeRequestResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_INVALID_OR_UNKNOWN_INSTRUMENT", VALUEFUNC(_wrap_TradeRequestResult_INVALID_OR_UNKNOWN_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_INVALID_TYPE_OF_TRADE_REQUESTED", VALUEFUNC(_wrap_TradeRequestResult_INVALID_TYPE_OF_TRADE_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_INVALID_PARTIES", VALUEFUNC(_wrap_TradeRequestResult_INVALID_PARTIES_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_INVALID_TRANSPORT_TYPE_REQUESTED", VALUEFUNC(_wrap_TradeRequestResult_INVALID_TRANSPORT_TYPE_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_INVALID_DESTINATION_REQUESTED", VALUEFUNC(_wrap_TradeRequestResult_INVALID_DESTINATION_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_TRADEREQUESTTYPE_NOT_SUPPORTED", VALUEFUNC(_wrap_TradeRequestResult_TRADEREQUESTTYPE_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestResult_UNAUTHORIZED_FOR_TRADE_CAPTURE_REPORT_REQUEST", VALUEFUNC(_wrap_TradeRequestResult_UNAUTHORIZED_FOR_TRADE_CAPTURE_REPORT_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestStatus_ACCEPTED", VALUEFUNC(_wrap_TradeRequestStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestStatus_COMPLETED", VALUEFUNC(_wrap_TradeRequestStatus_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeRequestStatus_REJECTED", VALUEFUNC(_wrap_TradeRequestStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_SUCCESSFUL", VALUEFUNC(_wrap_TradeReportRejectReason_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_INVALID_PARTY_INFORMATION", VALUEFUNC(_wrap_TradeReportRejectReason_INVALID_PARTY_INFORMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_UNKNOWN_INSTRUMENT", VALUEFUNC(_wrap_TradeReportRejectReason_UNKNOWN_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_UNAUTHORIZED_TO_REPORT_TRADES", VALUEFUNC(_wrap_TradeReportRejectReason_UNAUTHORIZED_TO_REPORT_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportRejectReason_INVALID_TRADE_TYPE", VALUEFUNC(_wrap_TradeReportRejectReason_INVALID_TRADE_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "SideMultiLegReportingType_SINGLE_SECURITY", VALUEFUNC(_wrap_SideMultiLegReportingType_SINGLE_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SideMultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY", VALUEFUNC(_wrap_SideMultiLegReportingType_INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SideMultiLegReportingType_MULTI_LEG_SECURITY", VALUEFUNC(_wrap_SideMultiLegReportingType_MULTI_LEG_SECURITY_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_EXECUTION_TIME", VALUEFUNC(_wrap_TrdRegTimestampType_EXECUTION_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_TIME_IN", VALUEFUNC(_wrap_TrdRegTimestampType_TIME_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_TIME_OUT", VALUEFUNC(_wrap_TrdRegTimestampType_TIME_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_BROKER_RECEIPT", VALUEFUNC(_wrap_TrdRegTimestampType_BROKER_RECEIPT_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRegTimestampType_BROKER_EXECUTION", VALUEFUNC(_wrap_TrdRegTimestampType_BROKER_EXECUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmType_STATUS", VALUEFUNC(_wrap_ConfirmType_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmType_CONFIRMATION", VALUEFUNC(_wrap_ConfirmType_CONFIRMATION_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmType_CONFIRMATION_REQUEST_REJECTED", VALUEFUNC(_wrap_ConfirmType_CONFIRMATION_REQUEST_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_MISMATCHED_ACCOUNT", VALUEFUNC(_wrap_ConfirmRejReason_MISMATCHED_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "ConfirmRejReason_MISSING_SETTLEMENT_INSTRUCTIONS", VALUEFUNC(_wrap_ConfirmRejReason_MISSING_SETTLEMENT_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingType_REGULAR_BOOKING", VALUEFUNC(_wrap_BookingType_REGULAR_BOOKING_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingType_CFD", VALUEFUNC(_wrap_BookingType_CFD_get), 0);
  rb_define_singleton_method(mQuickfix, "BookingType_TOTAL_RETURN_SWAP", VALUEFUNC(_wrap_BookingType_TOTAL_RETURN_SWAP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocSettlInstType_USE_DEFAULT_INSTRUCTIONS", VALUEFUNC(_wrap_AllocSettlInstType_USE_DEFAULT_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocSettlInstType_DERIVE_FROM_PARAMETERS_PROVIDED", VALUEFUNC(_wrap_AllocSettlInstType_DERIVE_FROM_PARAMETERS_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocSettlInstType_FULL_DETAILS_PROVIDED", VALUEFUNC(_wrap_AllocSettlInstType_FULL_DETAILS_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocSettlInstType_SSI_DB_IDS_PROVIDED", VALUEFUNC(_wrap_AllocSettlInstType_SSI_DB_IDS_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocSettlInstType_PHONE_FOR_INSTRUCTIONS", VALUEFUNC(_wrap_AllocSettlInstType_PHONE_FOR_INSTRUCTIONS_get), 0);
  rb_define_singleton_method(mQuickfix, "DlvyInstType_SECURITIES", VALUEFUNC(_wrap_DlvyInstType_SECURITIES_get), 0);
  rb_define_singleton_method(mQuickfix, "DlvyInstType_CASH", VALUEFUNC(_wrap_DlvyInstType_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "TerminationType_OVERNIGHT", VALUEFUNC(_wrap_TerminationType_OVERNIGHT_get), 0);
  rb_define_singleton_method(mQuickfix, "TerminationType_TERM", VALUEFUNC(_wrap_TerminationType_TERM_get), 0);
  rb_define_singleton_method(mQuickfix, "TerminationType_FLEXIBLE", VALUEFUNC(_wrap_TerminationType_FLEXIBLE_get), 0);
  rb_define_singleton_method(mQuickfix, "TerminationType_OPEN", VALUEFUNC(_wrap_TerminationType_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstReqRejCode_UNABLE_TO_PROCESS_REQUEST", VALUEFUNC(_wrap_SettlInstReqRejCode_UNABLE_TO_PROCESS_REQUEST_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstReqRejCode_UNKNOWN_ACCOUNT", VALUEFUNC(_wrap_SettlInstReqRejCode_UNKNOWN_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlInstReqRejCode_NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND", VALUEFUNC(_wrap_SettlInstReqRejCode_NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_SELLSIDE_CALCULATED_USING_PRELIMINARY", VALUEFUNC(_wrap_AllocReportType_SELLSIDE_CALCULATED_USING_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY", VALUEFUNC(_wrap_AllocReportType_SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_WAREHOUSE_RECAP", VALUEFUNC(_wrap_AllocReportType_WAREHOUSE_RECAP_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocReportType_REQUEST_TO_INTERMEDIARY", VALUEFUNC(_wrap_AllocReportType_REQUEST_TO_INTERMEDIARY_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocCancReplaceReason_ORIGINAL_DETAILS_INCOMPLETE_INCORRECT", VALUEFUNC(_wrap_AllocCancReplaceReason_ORIGINAL_DETAILS_INCOMPLETE_INCORRECT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocCancReplaceReason_CHANGE_IN_UNDERLYING_ORDER_DETAILS", VALUEFUNC(_wrap_AllocCancReplaceReason_CHANGE_IN_UNDERLYING_ORDER_DETAILS_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS", VALUEFUNC(_wrap_AllocAccountType_ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS", VALUEFUNC(_wrap_AllocAccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_HOUSE_TRADER", VALUEFUNC(_wrap_AllocAccountType_HOUSE_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_FLOOR_TRADER", VALUEFUNC(_wrap_AllocAccountType_FLOOR_TRADER_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED", VALUEFUNC(_wrap_AllocAccountType_ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED", VALUEFUNC(_wrap_AllocAccountType_ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocAccountType_JOINT_BACKOFFICE_ACCOUNT", VALUEFUNC(_wrap_AllocAccountType_JOINT_BACKOFFICE_ACCOUNT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_PENDING_ACCEPT", VALUEFUNC(_wrap_AllocIntermedReqType_PENDING_ACCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_PENDING_RELEASE", VALUEFUNC(_wrap_AllocIntermedReqType_PENDING_RELEASE_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_PENDING_REVERSAL", VALUEFUNC(_wrap_AllocIntermedReqType_PENDING_REVERSAL_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_ACCEPT", VALUEFUNC(_wrap_AllocIntermedReqType_ACCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_BLOCK_LEVEL_REJECT", VALUEFUNC(_wrap_AllocIntermedReqType_BLOCK_LEVEL_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocIntermedReqType_ACCOUNT_LEVEL_REJECT", VALUEFUNC(_wrap_AllocIntermedReqType_ACCOUNT_LEVEL_REJECT_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueResolution_NO_ACTION_TAKEN", VALUEFUNC(_wrap_ApplQueueResolution_NO_ACTION_TAKEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueResolution_QUEUE_FLUSHED", VALUEFUNC(_wrap_ApplQueueResolution_QUEUE_FLUSHED_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueResolution_OVERLAY_LAST", VALUEFUNC(_wrap_ApplQueueResolution_OVERLAY_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueResolution_END_SESSION", VALUEFUNC(_wrap_ApplQueueResolution_END_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueAction_NO_ACTION_TAKEN", VALUEFUNC(_wrap_ApplQueueAction_NO_ACTION_TAKEN_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueAction_QUEUE_FLUSHED", VALUEFUNC(_wrap_ApplQueueAction_QUEUE_FLUSHED_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueAction_OVERLAY_LAST", VALUEFUNC(_wrap_ApplQueueAction_OVERLAY_LAST_get), 0);
  rb_define_singleton_method(mQuickfix, "ApplQueueAction_END_SESSION", VALUEFUNC(_wrap_ApplQueueAction_END_SESSION_get), 0);
  rb_define_singleton_method(mQuickfix, "AvgPxIndicator_NO_AVERAGE_PRICING", VALUEFUNC(_wrap_AvgPxIndicator_NO_AVERAGE_PRICING_get), 0);
  rb_define_singleton_method(mQuickfix, "AvgPxIndicator_TRADE_IS_PART_OF_AN_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID", VALUEFUNC(_wrap_AvgPxIndicator_TRADE_IS_PART_OF_AN_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID_get), 0);
  rb_define_singleton_method(mQuickfix, "AvgPxIndicator_LAST_TRADE_IN_THE_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID", VALUEFUNC(_wrap_AvgPxIndicator_LAST_TRADE_IN_THE_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocIndicator_ALLOCATION_NOT_REQUIRED", VALUEFUNC(_wrap_TradeAllocIndicator_ALLOCATION_NOT_REQUIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocIndicator_ALLOCATION_REQUIRED", VALUEFUNC(_wrap_TradeAllocIndicator_ALLOCATION_REQUIRED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeAllocIndicator_USE_ALLOCATION_PROVIDED_WITH_THE_TRADE", VALUEFUNC(_wrap_TradeAllocIndicator_USE_ALLOCATION_PROVIDED_WITH_THE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpirationCycle_EXPIRE_ON_TRADING_SESSION_CLOSE", VALUEFUNC(_wrap_ExpirationCycle_EXPIRE_ON_TRADING_SESSION_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "ExpirationCycle_EXPIRE_ON_TRADING_SESSION_OPEN", VALUEFUNC(_wrap_ExpirationCycle_EXPIRE_ON_TRADING_SESSION_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_REGULAR_TRADE", VALUEFUNC(_wrap_TrdType_REGULAR_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_BLOCK_TRADE", VALUEFUNC(_wrap_TrdType_BLOCK_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_EFP", VALUEFUNC(_wrap_TrdType_EFP_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_TRANSFER", VALUEFUNC(_wrap_TrdType_TRANSFER_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_LATE_TRADE", VALUEFUNC(_wrap_TrdType_LATE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_T_TRADE", VALUEFUNC(_wrap_TrdType_T_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_WEIGHTED_AVERAGE_PRICE_TRADE", VALUEFUNC(_wrap_TrdType_WEIGHTED_AVERAGE_PRICE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_BUNCHED_TRADE", VALUEFUNC(_wrap_TrdType_BUNCHED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_LATE_BUNCHED_TRADE", VALUEFUNC(_wrap_TrdType_LATE_BUNCHED_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdType_PRIOR_REFERENCE_PRICE_TRADE", VALUEFUNC(_wrap_TrdType_PRIOR_REFERENCE_PRICE_TRADE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegMoveType_FLOATING", VALUEFUNC(_wrap_PegMoveType_FLOATING_get), 0);
  rb_define_singleton_method(mQuickfix, "PegMoveType_FIXED", VALUEFUNC(_wrap_PegMoveType_FIXED_get), 0);
  rb_define_singleton_method(mQuickfix, "PegOffsetType_PRICE", VALUEFUNC(_wrap_PegOffsetType_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegOffsetType_BASIS_POINTS", VALUEFUNC(_wrap_PegOffsetType_BASIS_POINTS_get), 0);
  rb_define_singleton_method(mQuickfix, "PegOffsetType_TICKS", VALUEFUNC(_wrap_PegOffsetType_TICKS_get), 0);
  rb_define_singleton_method(mQuickfix, "PegOffsetType_PRICE_TIER_LEVEL", VALUEFUNC(_wrap_PegOffsetType_PRICE_TIER_LEVEL_get), 0);
  rb_define_singleton_method(mQuickfix, "PegLimitType_OR_BETTER", VALUEFUNC(_wrap_PegLimitType_OR_BETTER_get), 0);
  rb_define_singleton_method(mQuickfix, "PegLimitType_STRICT", VALUEFUNC(_wrap_PegLimitType_STRICT_get), 0);
  rb_define_singleton_method(mQuickfix, "PegLimitType_OR_WORSE", VALUEFUNC(_wrap_PegLimitType_OR_WORSE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegRoundDirection_MORE_AGGRESSIVE", VALUEFUNC(_wrap_PegRoundDirection_MORE_AGGRESSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegRoundDirection_MORE_PASSIVE", VALUEFUNC(_wrap_PegRoundDirection_MORE_PASSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "PegScope_LOCAL", VALUEFUNC(_wrap_PegScope_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PegScope_NATIONAL", VALUEFUNC(_wrap_PegScope_NATIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PegScope_GLOBAL", VALUEFUNC(_wrap_PegScope_GLOBAL_get), 0);
  rb_define_singleton_method(mQuickfix, "PegScope_NATIONAL_EXCLUDING_LOCAL", VALUEFUNC(_wrap_PegScope_NATIONAL_EXCLUDING_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionMoveType_FLOATING", VALUEFUNC(_wrap_DiscretionMoveType_FLOATING_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionMoveType_FIXED", VALUEFUNC(_wrap_DiscretionMoveType_FIXED_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionOffsetType_PRICE", VALUEFUNC(_wrap_DiscretionOffsetType_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionOffsetType_BASIS_POINTS", VALUEFUNC(_wrap_DiscretionOffsetType_BASIS_POINTS_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionOffsetType_TICKS", VALUEFUNC(_wrap_DiscretionOffsetType_TICKS_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionOffsetType_PRICE_TIER_LEVEL", VALUEFUNC(_wrap_DiscretionOffsetType_PRICE_TIER_LEVEL_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionLimitType_OR_BETTER", VALUEFUNC(_wrap_DiscretionLimitType_OR_BETTER_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionLimitType_STRICT", VALUEFUNC(_wrap_DiscretionLimitType_STRICT_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionLimitType_OR_WORSE", VALUEFUNC(_wrap_DiscretionLimitType_OR_WORSE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionRoundDirection_MORE_AGGRESSIVE", VALUEFUNC(_wrap_DiscretionRoundDirection_MORE_AGGRESSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionRoundDirection_MORE_PASSIVE", VALUEFUNC(_wrap_DiscretionRoundDirection_MORE_PASSIVE_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionScope_LOCAL", VALUEFUNC(_wrap_DiscretionScope_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionScope_NATIONAL", VALUEFUNC(_wrap_DiscretionScope_NATIONAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionScope_GLOBAL", VALUEFUNC(_wrap_DiscretionScope_GLOBAL_get), 0);
  rb_define_singleton_method(mQuickfix, "DiscretionScope_NATIONAL_EXCLUDING_LOCAL", VALUEFUNC(_wrap_DiscretionScope_NATIONAL_EXCLUDING_LOCAL_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_ADDED_LIQUIDITY", VALUEFUNC(_wrap_LastLiquidityInd_ADDED_LIQUIDITY_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_REMOVED_LIQUIDITY", VALUEFUNC(_wrap_LastLiquidityInd_REMOVED_LIQUIDITY_get), 0);
  rb_define_singleton_method(mQuickfix, "LastLiquidityInd_LIQUIDITY_ROUTED_OUT", VALUEFUNC(_wrap_LastLiquidityInd_LIQUIDITY_ROUTED_OUT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_DEALER_SOLD_SHORT", VALUEFUNC(_wrap_ShortSaleReason_DEALER_SOLD_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_DEALER_SOLD_SHORT_EXEMPT", VALUEFUNC(_wrap_ShortSaleReason_DEALER_SOLD_SHORT_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT", VALUEFUNC(_wrap_ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_EXEMPT", VALUEFUNC(_wrap_ShortSaleReason_SELLING_CUSTOMER_SOLD_SHORT_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_QUALIFED_SERVICE_REPRESENTATIVE_OR_AUTOMATIC_GIVEUP_CONTRA_SIDE_SOLD_SHORT", VALUEFUNC(_wrap_ShortSaleReason_QUALIFED_SERVICE_REPRESENTATIVE_OR_AUTOMATIC_GIVEUP_CONTRA_SIDE_SOLD_SHORT_get), 0);
  rb_define_singleton_method(mQuickfix, "ShortSaleReason_QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT", VALUEFUNC(_wrap_ShortSaleReason_QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT_get), 0);
  rb_define_singleton_method(mQuickfix, "QtyType_UNITS", VALUEFUNC(_wrap_QtyType_UNITS_get), 0);
  rb_define_singleton_method(mQuickfix, "QtyType_CONTRACTS", VALUEFUNC(_wrap_QtyType_CONTRACTS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_SUBMIT", VALUEFUNC(_wrap_TradeReportType_SUBMIT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ALLEGED", VALUEFUNC(_wrap_TradeReportType_ALLEGED_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ACCEPT", VALUEFUNC(_wrap_TradeReportType_ACCEPT_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_DECLINE", VALUEFUNC(_wrap_TradeReportType_DECLINE_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_ADDENDUM", VALUEFUNC(_wrap_TradeReportType_ADDENDUM_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_NO_WAS", VALUEFUNC(_wrap_TradeReportType_NO_WAS_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_TRADE_REPORT_CANCEL", VALUEFUNC(_wrap_TradeReportType_TRADE_REPORT_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "TradeReportType_LOCKED_IN_TRADE_BREAK", VALUEFUNC(_wrap_TradeReportType_LOCKED_IN_TRADE_BREAK_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocNoOrdersType_NOT_SPECIFIED", VALUEFUNC(_wrap_AllocNoOrdersType_NOT_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "AllocNoOrdersType_EXPLICIT_LIST_PROVIDED", VALUEFUNC(_wrap_AllocNoOrdersType_EXPLICIT_LIST_PROVIDED_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_PUT", VALUEFUNC(_wrap_EventType_PUT_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_CALL", VALUEFUNC(_wrap_EventType_CALL_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_TENDER", VALUEFUNC(_wrap_EventType_TENDER_get), 0);
  rb_define_singleton_method(mQuickfix, "EventType_SINKING_FUND_CALL", VALUEFUNC(_wrap_EventType_SINKING_FUND_CALL_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_FLAT", VALUEFUNC(_wrap_InstrAttribType_FLAT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_ZERO_COUPON", VALUEFUNC(_wrap_InstrAttribType_ZERO_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_INTEREST_BEARING", VALUEFUNC(_wrap_InstrAttribType_INTEREST_BEARING_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_NO_PERIODIC_PAYMENTS", VALUEFUNC(_wrap_InstrAttribType_NO_PERIODIC_PAYMENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_VARIABLE_RATE", VALUEFUNC(_wrap_InstrAttribType_VARIABLE_RATE_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_LESS_FEE_FOR_PUT", VALUEFUNC(_wrap_InstrAttribType_LESS_FEE_FOR_PUT_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_STEPPED_COUPON", VALUEFUNC(_wrap_InstrAttribType_STEPPED_COUPON_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_COUPON_PERIOD", VALUEFUNC(_wrap_InstrAttribType_COUPON_PERIOD_get), 0);
  rb_define_singleton_method(mQuickfix, "InstrAttribType_WHEN_AND_IF_ISSUED", VALUEFUNC(_wrap_InstrAttribType_WHEN_AND_IF_ISSUED_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeBasis_ABSOLUTE", VALUEFUNC(_wrap_MiscFeeBasis_ABSOLUTE_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeBasis_PER_UNIT", VALUEFUNC(_wrap_MiscFeeBasis_PER_UNIT_get), 0);
  rb_define_singleton_method(mQuickfix, "MiscFeeBasis_PERCENTAGE", VALUEFUNC(_wrap_MiscFeeBasis_PERCENTAGE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_INITIAL", VALUEFUNC(_wrap_CollAsgnReason_INITIAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_SCHEDULED", VALUEFUNC(_wrap_CollAsgnReason_SCHEDULED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_TIME_WARNING", VALUEFUNC(_wrap_CollAsgnReason_TIME_WARNING_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_MARGIN_DEFICIENCY", VALUEFUNC(_wrap_CollAsgnReason_MARGIN_DEFICIENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_MARGIN_EXCESS", VALUEFUNC(_wrap_CollAsgnReason_MARGIN_EXCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_FORWARD_COLLATERAL_DEMAND", VALUEFUNC(_wrap_CollAsgnReason_FORWARD_COLLATERAL_DEMAND_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_EVENT_OF_DEFAULT", VALUEFUNC(_wrap_CollAsgnReason_EVENT_OF_DEFAULT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnReason_ADVERSE_TAX_EVENT", VALUEFUNC(_wrap_CollAsgnReason_ADVERSE_TAX_EVENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_TRADEDATE", VALUEFUNC(_wrap_CollInquiryQualifier_TRADEDATE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_GC_INSTRUMENT", VALUEFUNC(_wrap_CollInquiryQualifier_GC_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_COLLATERALINSTRUMENT", VALUEFUNC(_wrap_CollInquiryQualifier_COLLATERALINSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_SUBSTITUTION_ELIGIBLE", VALUEFUNC(_wrap_CollInquiryQualifier_SUBSTITUTION_ELIGIBLE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_NOT_ASSIGNED", VALUEFUNC(_wrap_CollInquiryQualifier_NOT_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_PARTIALLY_ASSIGNED", VALUEFUNC(_wrap_CollInquiryQualifier_PARTIALLY_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_FULLY_ASSIGNED", VALUEFUNC(_wrap_CollInquiryQualifier_FULLY_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryQualifier_OUTSTANDING_TRADES", VALUEFUNC(_wrap_CollInquiryQualifier_OUTSTANDING_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnTransType_NEW", VALUEFUNC(_wrap_CollAsgnTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnTransType_REPLACE", VALUEFUNC(_wrap_CollAsgnTransType_REPLACE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnTransType_CANCEL", VALUEFUNC(_wrap_CollAsgnTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnTransType_RELEASE", VALUEFUNC(_wrap_CollAsgnTransType_RELEASE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnTransType_REVERSE", VALUEFUNC(_wrap_CollAsgnTransType_REVERSE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRespType_RECEIVED", VALUEFUNC(_wrap_CollAsgnRespType_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRespType_ACCEPTED", VALUEFUNC(_wrap_CollAsgnRespType_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRespType_DECLINED", VALUEFUNC(_wrap_CollAsgnRespType_DECLINED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRespType_REJECTED", VALUEFUNC(_wrap_CollAsgnRespType_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_UNKNOWN_DEAL", VALUEFUNC(_wrap_CollAsgnRejectReason_UNKNOWN_DEAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_UNKNOWN_OR_INVALID_INSTRUMENT", VALUEFUNC(_wrap_CollAsgnRejectReason_UNKNOWN_OR_INVALID_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_UNAUTHORIZED_TRANSACTION", VALUEFUNC(_wrap_CollAsgnRejectReason_UNAUTHORIZED_TRANSACTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_INSUFFICIENT_COLLATERAL", VALUEFUNC(_wrap_CollAsgnRejectReason_INSUFFICIENT_COLLATERAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_INVALID_TYPE_OF_COLLATERAL", VALUEFUNC(_wrap_CollAsgnRejectReason_INVALID_TYPE_OF_COLLATERAL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAsgnRejectReason_EXCESSIVE_SUBSTITUTION", VALUEFUNC(_wrap_CollAsgnRejectReason_EXCESSIVE_SUBSTITUTION_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_UNASSIGNED", VALUEFUNC(_wrap_CollStatus_UNASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_PARTIALLY_ASSIGNED", VALUEFUNC(_wrap_CollStatus_PARTIALLY_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_ASSIGNMENT_PROPOSED", VALUEFUNC(_wrap_CollStatus_ASSIGNMENT_PROPOSED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_ASSIGNED", VALUEFUNC(_wrap_CollStatus_ASSIGNED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollStatus_CHALLENGED", VALUEFUNC(_wrap_CollStatus_CHALLENGED_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryType_VERSUS_PAYMENT", VALUEFUNC(_wrap_DeliveryType_VERSUS_PAYMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryType_FREE", VALUEFUNC(_wrap_DeliveryType_FREE_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryType_TRI_PARTY", VALUEFUNC(_wrap_DeliveryType_TRI_PARTY_get), 0);
  rb_define_singleton_method(mQuickfix, "DeliveryType_HOLD_IN_CUSTODY", VALUEFUNC(_wrap_DeliveryType_HOLD_IN_CUSTODY_get), 0);
  rb_define_singleton_method(mQuickfix, "UserRequestType_LOGONUSER", VALUEFUNC(_wrap_UserRequestType_LOGONUSER_get), 0);
  rb_define_singleton_method(mQuickfix, "UserRequestType_LOGOFFUSER", VALUEFUNC(_wrap_UserRequestType_LOGOFFUSER_get), 0);
  rb_define_singleton_method(mQuickfix, "UserRequestType_CHANGEPASSWORDFORUSER", VALUEFUNC(_wrap_UserRequestType_CHANGEPASSWORDFORUSER_get), 0);
  rb_define_singleton_method(mQuickfix, "UserRequestType_REQUEST_INDIVIDUAL_USER_STATUS", VALUEFUNC(_wrap_UserRequestType_REQUEST_INDIVIDUAL_USER_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_LOGGED_IN", VALUEFUNC(_wrap_UserStatus_LOGGED_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_NOT_LOGGED_IN", VALUEFUNC(_wrap_UserStatus_NOT_LOGGED_IN_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_USER_NOT_RECOGNISED", VALUEFUNC(_wrap_UserStatus_USER_NOT_RECOGNISED_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_PASSWORD_INCORRECT", VALUEFUNC(_wrap_UserStatus_PASSWORD_INCORRECT_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_PASSWORD_CHANGED", VALUEFUNC(_wrap_UserStatus_PASSWORD_CHANGED_get), 0);
  rb_define_singleton_method(mQuickfix, "UserStatus_OTHER", VALUEFUNC(_wrap_UserStatus_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "StatusValue_CONNECTED", VALUEFUNC(_wrap_StatusValue_CONNECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "StatusValue_NOT_CONNECTED_DOWN_EXPECTED_UP", VALUEFUNC(_wrap_StatusValue_NOT_CONNECTED_DOWN_EXPECTED_UP_get), 0);
  rb_define_singleton_method(mQuickfix, "StatusValue_NOT_CONNECTED_DOWN_EXPECTED_DOWN", VALUEFUNC(_wrap_StatusValue_NOT_CONNECTED_DOWN_EXPECTED_DOWN_get), 0);
  rb_define_singleton_method(mQuickfix, "StatusValue_IN_PROCESS", VALUEFUNC(_wrap_StatusValue_IN_PROCESS_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkRequestType_SNAPSHOT", VALUEFUNC(_wrap_NetworkRequestType_SNAPSHOT_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkRequestType_SUBSCRIBE", VALUEFUNC(_wrap_NetworkRequestType_SUBSCRIBE_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkRequestType_STOP_SUBSCRIBING", VALUEFUNC(_wrap_NetworkRequestType_STOP_SUBSCRIBING_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkRequestType_LEVEL_OF_DETAIL", VALUEFUNC(_wrap_NetworkRequestType_LEVEL_OF_DETAIL_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkStatusResponseType_FULL", VALUEFUNC(_wrap_NetworkStatusResponseType_FULL_get), 0);
  rb_define_singleton_method(mQuickfix, "NetworkStatusResponseType_INCREMENTAL_UPDATE", VALUEFUNC(_wrap_NetworkStatusResponseType_INCREMENTAL_UPDATE_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_ACCEPTED", VALUEFUNC(_wrap_TrdRptStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "TrdRptStatus_REJECTED", VALUEFUNC(_wrap_TrdRptStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "AffirmStatus_RECEIVED", VALUEFUNC(_wrap_AffirmStatus_RECEIVED_get), 0);
  rb_define_singleton_method(mQuickfix, "AffirmStatus_CONFIRM_REJECTED", VALUEFUNC(_wrap_AffirmStatus_CONFIRM_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "AffirmStatus_AFFIRMED", VALUEFUNC(_wrap_AffirmStatus_AFFIRMED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAction_RETAIN", VALUEFUNC(_wrap_CollAction_RETAIN_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAction_ADD", VALUEFUNC(_wrap_CollAction_ADD_get), 0);
  rb_define_singleton_method(mQuickfix, "CollAction_REMOVE", VALUEFUNC(_wrap_CollAction_REMOVE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryStatus_ACCEPTED", VALUEFUNC(_wrap_CollInquiryStatus_ACCEPTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryStatus_ACCEPTED_WITH_WARNINGS", VALUEFUNC(_wrap_CollInquiryStatus_ACCEPTED_WITH_WARNINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryStatus_COMPLETED", VALUEFUNC(_wrap_CollInquiryStatus_COMPLETED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryStatus_COMPLETED_WITH_WARNINGS", VALUEFUNC(_wrap_CollInquiryStatus_COMPLETED_WITH_WARNINGS_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryStatus_REJECTED", VALUEFUNC(_wrap_CollInquiryStatus_REJECTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_SUCCESSFUL", VALUEFUNC(_wrap_CollInquiryResult_SUCCESSFUL_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_INVALID_OR_UNKNOWN_INSTRUMENT", VALUEFUNC(_wrap_CollInquiryResult_INVALID_OR_UNKNOWN_INSTRUMENT_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_INVALID_OR_UNKNOWN_COLLATERAL_TYPE", VALUEFUNC(_wrap_CollInquiryResult_INVALID_OR_UNKNOWN_COLLATERAL_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_INVALID_PARTIES", VALUEFUNC(_wrap_CollInquiryResult_INVALID_PARTIES_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_INVALID_TRANSPORT_TYPE_REQUESTED", VALUEFUNC(_wrap_CollInquiryResult_INVALID_TRANSPORT_TYPE_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_INVALID_DESTINATION_REQUESTED", VALUEFUNC(_wrap_CollInquiryResult_INVALID_DESTINATION_REQUESTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED", VALUEFUNC(_wrap_CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED", VALUEFUNC(_wrap_CollInquiryResult_NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED", VALUEFUNC(_wrap_CollInquiryResult_COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_UNAUTHORIZED_FOR_COLLATERAL_INQUIRY", VALUEFUNC(_wrap_CollInquiryResult_UNAUTHORIZED_FOR_COLLATERAL_INQUIRY_get), 0);
  rb_define_singleton_method(mQuickfix, "CollInquiryResult_OTHER", VALUEFUNC(_wrap_CollInquiryResult_OTHER_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INVALID_TAG_NUMBER_TEXT", VALUEFUNC(_wrap_SessionRejectReason_INVALID_TAG_NUMBER_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_REQUIRED_TAG_MISSING_TEXT", VALUEFUNC(_wrap_SessionRejectReason_REQUIRED_TAG_MISSING_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_TEXT", VALUEFUNC(_wrap_SessionRejectReason_TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_UNDEFINED_TAG_TEXT", VALUEFUNC(_wrap_SessionRejectReason_UNDEFINED_TAG_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_TEXT", VALUEFUNC(_wrap_SessionRejectReason_TAG_SPECIFIED_WITHOUT_A_VALUE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_VALUE_IS_INCORRECT_TEXT", VALUEFUNC(_wrap_SessionRejectReason_VALUE_IS_INCORRECT_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_TEXT", VALUEFUNC(_wrap_SessionRejectReason_INCORRECT_DATA_FORMAT_FOR_VALUE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_DECRYPTION_PROBLEM_TEXT", VALUEFUNC(_wrap_SessionRejectReason_DECRYPTION_PROBLEM_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_SIGNATURE_PROBLEM_TEXT", VALUEFUNC(_wrap_SessionRejectReason_SIGNATURE_PROBLEM_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_COMPID_PROBLEM_TEXT", VALUEFUNC(_wrap_SessionRejectReason_COMPID_PROBLEM_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_TEXT", VALUEFUNC(_wrap_SessionRejectReason_SENDINGTIME_ACCURACY_PROBLEM_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INVALID_MSGTYPE_TEXT", VALUEFUNC(_wrap_SessionRejectReason_INVALID_MSGTYPE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_TEXT", VALUEFUNC(_wrap_SessionRejectReason_TAG_APPEARS_MORE_THAN_ONCE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_TEXT", VALUEFUNC(_wrap_SessionRejectReason_TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_TEXT", VALUEFUNC(_wrap_SessionRejectReason_INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_OTHER_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_OTHER_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNKNOWN_ID_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_UNKNOWN_ID_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNKNOWN_SECURITY_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_UNKNOWN_SECURITY_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_UNSUPPORTED_MESSAGE_TYPE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_APPLICATION_NOT_AVAILABLE_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_APPLICATION_NOT_AVAILABLE_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_CONDITIONALLY_REQUIRED_FIELD_MISSING_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_NOT_AUTHORIZED_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_NOT_AUTHORIZED_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "BusinessRejectReason_DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_TEXT", VALUEFUNC(_wrap_BusinessRejectReason_DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME_TEXT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTransType_NEW", VALUEFUNC(_wrap_ExecTransType_NEW_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTransType_CANCEL", VALUEFUNC(_wrap_ExecTransType_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTransType_CORRECT", VALUEFUNC(_wrap_ExecTransType_CORRECT_get), 0);
  rb_define_singleton_method(mQuickfix, "ExecTransType_STATUS", VALUEFUNC(_wrap_ExecTransType_STATUS_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_CUSIP", VALUEFUNC(_wrap_IDSource_CUSIP_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_SEDOL", VALUEFUNC(_wrap_IDSource_SEDOL_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_QUIK", VALUEFUNC(_wrap_IDSource_QUIK_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_ISIN_NUMBER", VALUEFUNC(_wrap_IDSource_ISIN_NUMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_RIC_CODE", VALUEFUNC(_wrap_IDSource_RIC_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_ISO_CURRENCY_CODE", VALUEFUNC(_wrap_IDSource_ISO_CURRENCY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_ISO_COUNTRY_CODE", VALUEFUNC(_wrap_IDSource_ISO_COUNTRY_CODE_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_EXCHANGE_SYMBOL", VALUEFUNC(_wrap_IDSource_EXCHANGE_SYMBOL_get), 0);
  rb_define_singleton_method(mQuickfix, "IDSource_CONSOLIDATED_TAPE_ASSOCIATION", VALUEFUNC(_wrap_IDSource_CONSOLIDATED_TAPE_ASSOCIATION_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIShares_SMALL", VALUEFUNC(_wrap_IOIShares_SMALL_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIShares_MEDIUM", VALUEFUNC(_wrap_IOIShares_MEDIUM_get), 0);
  rb_define_singleton_method(mQuickfix, "IOIShares_LARGE", VALUEFUNC(_wrap_IOIShares_LARGE_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_AGENCY_SINGLE_ORDER", VALUEFUNC(_wrap_Rule80A_AGENCY_SINGLE_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_A_TYPE", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_A_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_MEMBER_FIRM", VALUEFUNC(_wrap_Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_MEMBER_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_MEMBER_FIRM", VALUEFUNC(_wrap_Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_MEMBER_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_FOR_PRINCIPAL", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_FOR_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_W_TYPE", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_W_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_I_TYPE", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_TRANSACTION_REFER_TO_I_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_INDIVIDUAL_INVESTOR", VALUEFUNC(_wrap_Rule80A_INDIVIDUAL_INVESTOR_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_INDIVIDUAL_CUSTOMER", VALUEFUNC(_wrap_Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_INDIVIDUAL_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_INDIVIDUAL_CUSTOMER", VALUEFUNC(_wrap_Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_INDIVIDUAL_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_AFFILIATED", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_AFFILIATED_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_OTHER_MEMBER", VALUEFUNC(_wrap_Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_OTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_OTHER_MEMBER", VALUEFUNC(_wrap_Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_OTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROPRIETARY_AFFILIATED", VALUEFUNC(_wrap_Rule80A_PROPRIETARY_AFFILIATED_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PRINCIPAL", VALUEFUNC(_wrap_Rule80A_PRINCIPAL_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_TRANSACTIONS_NON_MEMBER", VALUEFUNC(_wrap_Rule80A_TRANSACTIONS_NON_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SPECIALIST_TRADES", VALUEFUNC(_wrap_Rule80A_SPECIALIST_TRADES_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_TRANSACTIONS_UNAFFILIATED_MEMBER", VALUEFUNC(_wrap_Rule80A_TRANSACTIONS_UNAFFILIATED_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_OTHER_AGENCY", VALUEFUNC(_wrap_Rule80A_PROGRAM_ORDER_INDEX_ARB_FOR_OTHER_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_ALL_OTHER_ORDERS_AS_AGENT_FOR_OTHER_MEMBER", VALUEFUNC(_wrap_Rule80A_ALL_OTHER_ORDERS_AS_AGENT_FOR_OTHER_MEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_NOT_AFFILIATED", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_NOT_AFFILIATED_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_OTHER_AGENCY", VALUEFUNC(_wrap_Rule80A_PROGRAM_ORDER_NON_INDEX_ARB_FOR_OTHER_AGENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "Rule80A_SHORT_EXEMPT_NONMEMBER", VALUEFUNC(_wrap_Rule80A_SHORT_EXEMPT_NONMEMBER_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_REGULAR", VALUEFUNC(_wrap_SettlmntTyp_REGULAR_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_CASH", VALUEFUNC(_wrap_SettlmntTyp_CASH_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_NEXT_DAY", VALUEFUNC(_wrap_SettlmntTyp_NEXT_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_T_PLUS_2", VALUEFUNC(_wrap_SettlmntTyp_T_PLUS_2_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_T_PLUS_3", VALUEFUNC(_wrap_SettlmntTyp_T_PLUS_3_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_T_PLUS_4", VALUEFUNC(_wrap_SettlmntTyp_T_PLUS_4_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_FUTURE", VALUEFUNC(_wrap_SettlmntTyp_FUTURE_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_WHEN_AND_IF_ISSUED", VALUEFUNC(_wrap_SettlmntTyp_WHEN_AND_IF_ISSUED_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_SELLERS_OPTION", VALUEFUNC(_wrap_SettlmntTyp_SELLERS_OPTION_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_T_PLUS_5", VALUEFUNC(_wrap_SettlmntTyp_T_PLUS_5_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlmntTyp_T_PLUS_1", VALUEFUNC(_wrap_SettlmntTyp_T_PLUS_1_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenClose_OPEN", VALUEFUNC(_wrap_OpenClose_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenClose_CLOSE", VALUEFUNC(_wrap_OpenClose_CLOSE_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlType_PARTIAL_CANCEL", VALUEFUNC(_wrap_CxlType_PARTIAL_CANCEL_get), 0);
  rb_define_singleton_method(mQuickfix, "CxlType_FULL_REMAINING_QUANTITY", VALUEFUNC(_wrap_CxlType_FULL_REMAINING_QUANTITY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_CEDEL", VALUEFUNC(_wrap_SettlLocation_CEDEL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_DEPOSITORY_TRUST_COMPANY", VALUEFUNC(_wrap_SettlLocation_DEPOSITORY_TRUST_COMPANY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_EUROCLEAR", VALUEFUNC(_wrap_SettlLocation_EUROCLEAR_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_FEDERAL_BOOK_ENTRY", VALUEFUNC(_wrap_SettlLocation_FEDERAL_BOOK_ENTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_PHYSICAL", VALUEFUNC(_wrap_SettlLocation_PHYSICAL_get), 0);
  rb_define_singleton_method(mQuickfix, "SettlLocation_PARTICIPANT_TRUST_COMPANY_ISO_COUNTRY", VALUEFUNC(_wrap_SettlLocation_PARTICIPANT_TRUST_COMPANY_ISO_COUNTRY_get), 0);
  rb_define_singleton_method(mQuickfix, "PutOrCall_PUT", VALUEFUNC(_wrap_PutOrCall_PUT_get), 0);
  rb_define_singleton_method(mQuickfix, "PutOrCall_CALL", VALUEFUNC(_wrap_PutOrCall_CALL_get), 0);
  rb_define_singleton_method(mQuickfix, "CustomerOrFirm_CUSTOMER", VALUEFUNC(_wrap_CustomerOrFirm_CUSTOMER_get), 0);
  rb_define_singleton_method(mQuickfix, "CustomerOrFirm_FIRM", VALUEFUNC(_wrap_CustomerOrFirm_FIRM_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_CURVE", VALUEFUNC(_wrap_Benchmark_CURVE_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_FIVEYR", VALUEFUNC(_wrap_Benchmark_FIVEYR_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_OLD5", VALUEFUNC(_wrap_Benchmark_OLD5_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_TENYR", VALUEFUNC(_wrap_Benchmark_TENYR_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_OLD10", VALUEFUNC(_wrap_Benchmark_OLD10_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_THIRTYYR", VALUEFUNC(_wrap_Benchmark_THIRTYYR_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_OLD30", VALUEFUNC(_wrap_Benchmark_OLD30_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_THREEMOLIBOR", VALUEFUNC(_wrap_Benchmark_THREEMOLIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "Benchmark_SIXMOLIBOR", VALUEFUNC(_wrap_Benchmark_SIXMOLIBOR_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettleFlag_DAILY_OPEN", VALUEFUNC(_wrap_OpenCloseSettleFlag_DAILY_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettleFlag_SESSION_OPEN", VALUEFUNC(_wrap_OpenCloseSettleFlag_SESSION_OPEN_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettleFlag_DELIVERY_SETTLEMENT_PRICE", VALUEFUNC(_wrap_OpenCloseSettleFlag_DELIVERY_SETTLEMENT_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettleFlag_EXPECTED_PRICE", VALUEFUNC(_wrap_OpenCloseSettleFlag_EXPECTED_PRICE_get), 0);
  rb_define_singleton_method(mQuickfix, "OpenCloseSettleFlag_PRICE_FROM_PREVIOUS_BUSINESS_DAY", VALUEFUNC(_wrap_OpenCloseSettleFlag_PRICE_FROM_PREVIOUS_BUSINESS_DAY_get), 0);
  
  cSessionID.klass = rb_define_class_under(mQuickfix, "SessionID", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SessionID, (void *) &cSessionID);
  rb_define_alloc_func(cSessionID.klass, _wrap_SessionID_allocate);
  rb_define_method(cSessionID.klass, "initialize", VALUEFUNC(_wrap_new_SessionID), -1);
  rb_define_method(cSessionID.klass, "getBeginString", VALUEFUNC(_wrap_SessionID_getBeginString), -1);
  rb_define_method(cSessionID.klass, "getSenderCompID", VALUEFUNC(_wrap_SessionID_getSenderCompID), -1);
  rb_define_method(cSessionID.klass, "getTargetCompID", VALUEFUNC(_wrap_SessionID_getTargetCompID), -1);
  rb_define_method(cSessionID.klass, "getSessionQualifier", VALUEFUNC(_wrap_SessionID_getSessionQualifier), -1);
  rb_define_method(cSessionID.klass, "fromString", VALUEFUNC(_wrap_SessionID_fromString), -1);
  rb_define_method(cSessionID.klass, "toString", VALUEFUNC(_wrap_SessionID_toString), -1);
  rb_define_method(cSessionID.klass, "~", VALUEFUNC(_wrap_SessionID___invert__), -1);
  rb_define_method(cSessionID.klass, "to_s", VALUEFUNC(_wrap_SessionID___str__), -1);
  cSessionID.mark = 0;
  cSessionID.destroy = (void (*)(void *)) free_FIX_SessionID;
  cSessionID.trackObjects = 0;
  rb_define_module_function(mQuickfix, "<", VALUEFUNC(_wrap___lt__), -1);
  rb_define_module_function(mQuickfix, "==", VALUEFUNC(_wrap___eq__), -1);
  
  cDictionary.klass = rb_define_class_under(mQuickfix, "Dictionary", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Dictionary, (void *) &cDictionary);
  rb_define_alloc_func(cDictionary.klass, _wrap_Dictionary_allocate);
  rb_define_method(cDictionary.klass, "initialize", VALUEFUNC(_wrap_new_Dictionary), -1);
  rb_define_method(cDictionary.klass, "getName", VALUEFUNC(_wrap_Dictionary_getName), -1);
  rb_define_method(cDictionary.klass, "size", VALUEFUNC(_wrap_Dictionary_size), -1);
  rb_define_method(cDictionary.klass, "getString", VALUEFUNC(_wrap_Dictionary_getString), -1);
  rb_define_method(cDictionary.klass, "getLong", VALUEFUNC(_wrap_Dictionary_getLong), -1);
  rb_define_method(cDictionary.klass, "getDouble", VALUEFUNC(_wrap_Dictionary_getDouble), -1);
  rb_define_method(cDictionary.klass, "getBool", VALUEFUNC(_wrap_Dictionary_getBool), -1);
  rb_define_method(cDictionary.klass, "getDay", VALUEFUNC(_wrap_Dictionary_getDay), -1);
  rb_define_method(cDictionary.klass, "setString", VALUEFUNC(_wrap_Dictionary_setString), -1);
  rb_define_method(cDictionary.klass, "setLong", VALUEFUNC(_wrap_Dictionary_setLong), -1);
  rb_define_method(cDictionary.klass, "setDouble", VALUEFUNC(_wrap_Dictionary_setDouble), -1);
  rb_define_method(cDictionary.klass, "setBool", VALUEFUNC(_wrap_Dictionary_setBool), -1);
  rb_define_method(cDictionary.klass, "setDay", VALUEFUNC(_wrap_Dictionary_setDay), -1);
  rb_define_method(cDictionary.klass, "has", VALUEFUNC(_wrap_Dictionary_has), -1);
  rb_define_method(cDictionary.klass, "merge", VALUEFUNC(_wrap_Dictionary_merge), -1);
  rb_define_method(cDictionary.klass, "begin", VALUEFUNC(_wrap_Dictionary_begin), -1);
  rb_define_method(cDictionary.klass, "end", VALUEFUNC(_wrap_Dictionary_end), -1);
  cDictionary.mark = 0;
  cDictionary.destroy = (void (*)(void *)) free_FIX_Dictionary;
  cDictionary.trackObjects = 0;
  rb_define_singleton_method(mQuickfix, "BEGINSTRING", VALUEFUNC(_wrap_BEGINSTRING_get), 0);
  rb_define_singleton_method(mQuickfix, "SENDERCOMPID", VALUEFUNC(_wrap_SENDERCOMPID_get), 0);
  rb_define_singleton_method(mQuickfix, "TARGETCOMPID", VALUEFUNC(_wrap_TARGETCOMPID_get), 0);
  rb_define_singleton_method(mQuickfix, "SESSION_QUALIFIER", VALUEFUNC(_wrap_SESSION_QUALIFIER_get), 0);
  rb_define_singleton_method(mQuickfix, "CONNECTION_TYPE", VALUEFUNC(_wrap_CONNECTION_TYPE_get), 0);
  rb_define_singleton_method(mQuickfix, "USE_DATA_DICTIONARY", VALUEFUNC(_wrap_USE_DATA_DICTIONARY_get), 0);
  rb_define_singleton_method(mQuickfix, "SEND_RESETSEQNUMFLAG", VALUEFUNC(_wrap_SEND_RESETSEQNUMFLAG_get), 0);
  rb_define_singleton_method(mQuickfix, "SEND_REDUNDANT_RESENDREQUESTS", VALUEFUNC(_wrap_SEND_REDUNDANT_RESENDREQUESTS_get), 0);
  rb_define_singleton_method(mQuickfix, "DATA_DICTIONARY", VALUEFUNC(_wrap_DATA_DICTIONARY_get), 0);
  rb_define_singleton_method(mQuickfix, "START_TIME", VALUEFUNC(_wrap_START_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "END_TIME", VALUEFUNC(_wrap_END_TIME_get), 0);
  rb_define_singleton_method(mQuickfix, "START_DAY", VALUEFUNC(_wrap_START_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "END_DAY", VALUEFUNC(_wrap_END_DAY_get), 0);
  rb_define_singleton_method(mQuickfix, "CHECK_COMPID", VALUEFUNC(_wrap_CHECK_COMPID_get), 0);
  rb_define_singleton_method(mQuickfix, "CHECK_LATENCY", VALUEFUNC(_wrap_CHECK_LATENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "MAX_LATENCY", VALUEFUNC(_wrap_MAX_LATENCY_get), 0);
  rb_define_singleton_method(mQuickfix, "HEARTBTINT", VALUEFUNC(_wrap_HEARTBTINT_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_ACCEPT_PORT", VALUEFUNC(_wrap_SOCKET_ACCEPT_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_REUSE_ADDRESS", VALUEFUNC(_wrap_SOCKET_REUSE_ADDRESS_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_CONNECT_HOST", VALUEFUNC(_wrap_SOCKET_CONNECT_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_CONNECT_PORT", VALUEFUNC(_wrap_SOCKET_CONNECT_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "SOCKET_NODELAY", VALUEFUNC(_wrap_SOCKET_NODELAY_get), 0);
  rb_define_singleton_method(mQuickfix, "RECONNECT_INTERVAL", VALUEFUNC(_wrap_RECONNECT_INTERVAL_get), 0);
  rb_define_singleton_method(mQuickfix, "VALIDATE_FIELDS_OUT_OF_ORDER", VALUEFUNC(_wrap_VALIDATE_FIELDS_OUT_OF_ORDER_get), 0);
  rb_define_singleton_method(mQuickfix, "VALIDATE_FIELDS_HAVE_VALUES", VALUEFUNC(_wrap_VALIDATE_FIELDS_HAVE_VALUES_get), 0);
  rb_define_singleton_method(mQuickfix, "VALIDATE_USER_DEFINED_FIELDS", VALUEFUNC(_wrap_VALIDATE_USER_DEFINED_FIELDS_get), 0);
  rb_define_singleton_method(mQuickfix, "LOGON_TIMEOUT", VALUEFUNC(_wrap_LOGON_TIMEOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "LOGOUT_TIMEOUT", VALUEFUNC(_wrap_LOGOUT_TIMEOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "FILE_STORE_PATH", VALUEFUNC(_wrap_FILE_STORE_PATH_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_USECONNECTIONPOOL", VALUEFUNC(_wrap_MYSQL_STORE_USECONNECTIONPOOL_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_DATABASE", VALUEFUNC(_wrap_MYSQL_STORE_DATABASE_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_USER", VALUEFUNC(_wrap_MYSQL_STORE_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_PASSWORD", VALUEFUNC(_wrap_MYSQL_STORE_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_HOST", VALUEFUNC(_wrap_MYSQL_STORE_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_STORE_PORT", VALUEFUNC(_wrap_MYSQL_STORE_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_USECONNECTIONPOOL", VALUEFUNC(_wrap_POSTGRESQL_STORE_USECONNECTIONPOOL_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_DATABASE", VALUEFUNC(_wrap_POSTGRESQL_STORE_DATABASE_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_USER", VALUEFUNC(_wrap_POSTGRESQL_STORE_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_PASSWORD", VALUEFUNC(_wrap_POSTGRESQL_STORE_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_HOST", VALUEFUNC(_wrap_POSTGRESQL_STORE_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_STORE_PORT", VALUEFUNC(_wrap_POSTGRESQL_STORE_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_STORE_USER", VALUEFUNC(_wrap_ODBC_STORE_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_STORE_PASSWORD", VALUEFUNC(_wrap_ODBC_STORE_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_STORE_CONNECTION_STRING", VALUEFUNC(_wrap_ODBC_STORE_CONNECTION_STRING_get), 0);
  rb_define_singleton_method(mQuickfix, "FILE_LOG_PATH", VALUEFUNC(_wrap_FILE_LOG_PATH_get), 0);
  rb_define_singleton_method(mQuickfix, "SCREEN_LOG_SHOW_INCOMING", VALUEFUNC(_wrap_SCREEN_LOG_SHOW_INCOMING_get), 0);
  rb_define_singleton_method(mQuickfix, "SCREEN_LOG_SHOW_OUTGOING", VALUEFUNC(_wrap_SCREEN_LOG_SHOW_OUTGOING_get), 0);
  rb_define_singleton_method(mQuickfix, "SCREEN_LOG_SHOW_EVENTS", VALUEFUNC(_wrap_SCREEN_LOG_SHOW_EVENTS_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_USECONNECTIONPOOL", VALUEFUNC(_wrap_MYSQL_LOG_USECONNECTIONPOOL_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_DATABASE", VALUEFUNC(_wrap_MYSQL_LOG_DATABASE_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_USER", VALUEFUNC(_wrap_MYSQL_LOG_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_PASSWORD", VALUEFUNC(_wrap_MYSQL_LOG_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_HOST", VALUEFUNC(_wrap_MYSQL_LOG_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "MYSQL_LOG_PORT", VALUEFUNC(_wrap_MYSQL_LOG_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_USECONNECTIONPOOL", VALUEFUNC(_wrap_POSTGRESQL_LOG_USECONNECTIONPOOL_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_DATABASE", VALUEFUNC(_wrap_POSTGRESQL_LOG_DATABASE_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_USER", VALUEFUNC(_wrap_POSTGRESQL_LOG_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_PASSWORD", VALUEFUNC(_wrap_POSTGRESQL_LOG_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_HOST", VALUEFUNC(_wrap_POSTGRESQL_LOG_HOST_get), 0);
  rb_define_singleton_method(mQuickfix, "POSTGRESQL_LOG_PORT", VALUEFUNC(_wrap_POSTGRESQL_LOG_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_LOG_USER", VALUEFUNC(_wrap_ODBC_LOG_USER_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_LOG_PASSWORD", VALUEFUNC(_wrap_ODBC_LOG_PASSWORD_get), 0);
  rb_define_singleton_method(mQuickfix, "ODBC_LOG_CONNECTION_STRING", VALUEFUNC(_wrap_ODBC_LOG_CONNECTION_STRING_get), 0);
  rb_define_singleton_method(mQuickfix, "RESET_ON_LOGON", VALUEFUNC(_wrap_RESET_ON_LOGON_get), 0);
  rb_define_singleton_method(mQuickfix, "RESET_ON_LOGOUT", VALUEFUNC(_wrap_RESET_ON_LOGOUT_get), 0);
  rb_define_singleton_method(mQuickfix, "RESET_ON_DISCONNECT", VALUEFUNC(_wrap_RESET_ON_DISCONNECT_get), 0);
  rb_define_singleton_method(mQuickfix, "REFRESH_ON_LOGON", VALUEFUNC(_wrap_REFRESH_ON_LOGON_get), 0);
  rb_define_singleton_method(mQuickfix, "MILLISECONDS_IN_TIMESTAMP", VALUEFUNC(_wrap_MILLISECONDS_IN_TIMESTAMP_get), 0);
  rb_define_singleton_method(mQuickfix, "HTTP_ACCEPT_PORT", VALUEFUNC(_wrap_HTTP_ACCEPT_PORT_get), 0);
  rb_define_singleton_method(mQuickfix, "PERSIST_MESSAGES", VALUEFUNC(_wrap_PERSIST_MESSAGES_get), 0);
  
  cSessionSettings.klass = rb_define_class_under(mQuickfix, "SessionSettings", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SessionSettings, (void *) &cSessionSettings);
  rb_define_alloc_func(cSessionSettings.klass, _wrap_SessionSettings_allocate);
  rb_define_method(cSessionSettings.klass, "initialize", VALUEFUNC(_wrap_new_SessionSettings), -1);
  rb_define_method(cSessionSettings.klass, "has", VALUEFUNC(_wrap_SessionSettings_has), -1);
  rb_define_method(cSessionSettings.klass, "get", VALUEFUNC(_wrap_SessionSettings_get), -1);
  rb_define_method(cSessionSettings.klass, "set", VALUEFUNC(_wrap_SessionSettings_set), -1);
  rb_define_method(cSessionSettings.klass, "size", VALUEFUNC(_wrap_SessionSettings_size), -1);
  rb_define_method(cSessionSettings.klass, "getSessions", VALUEFUNC(_wrap_SessionSettings_getSessions), -1);
  cSessionSettings.mark = 0;
  cSessionSettings.destroy = (void (*)(void *)) free_FIX_SessionSettings;
  cSessionSettings.trackObjects = 0;
  rb_define_module_function(mQuickfix, ">>", VALUEFUNC(_wrap___rshift__), -1);
  rb_define_module_function(mQuickfix, "<<", VALUEFUNC(_wrap___lshift__), -1);
  
  cSession.klass = rb_define_class_under(mQuickfix, "Session", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Session, (void *) &cSession);
  rb_define_alloc_func(cSession.klass, _wrap_Session_allocate);
  rb_define_method(cSession.klass, "initialize", VALUEFUNC(_wrap_new_Session), -1);
  rb_define_method(cSession.klass, "logon", VALUEFUNC(_wrap_Session_logon), -1);
  rb_define_method(cSession.klass, "logout", VALUEFUNC(_wrap_Session_logout), -1);
  rb_define_method(cSession.klass, "isEnabled", VALUEFUNC(_wrap_Session_isEnabled), -1);
  rb_define_method(cSession.klass, "sentLogon", VALUEFUNC(_wrap_Session_sentLogon), -1);
  rb_define_method(cSession.klass, "sentLogout", VALUEFUNC(_wrap_Session_sentLogout), -1);
  rb_define_method(cSession.klass, "receivedLogon", VALUEFUNC(_wrap_Session_receivedLogon), -1);
  rb_define_method(cSession.klass, "isLoggedOn", VALUEFUNC(_wrap_Session_isLoggedOn), -1);
  rb_define_method(cSession.klass, "reset", VALUEFUNC(_wrap_Session_reset), -1);
  rb_define_method(cSession.klass, "refresh", VALUEFUNC(_wrap_Session_refresh), -1);
  rb_define_method(cSession.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_Session_setNextSenderMsgSeqNum), -1);
  rb_define_method(cSession.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_Session_setNextTargetMsgSeqNum), -1);
  rb_define_method(cSession.klass, "getSessionID", VALUEFUNC(_wrap_Session_getSessionID), -1);
  rb_define_method(cSession.klass, "setDataDictionary", VALUEFUNC(_wrap_Session_setDataDictionary), -1);
  rb_define_method(cSession.klass, "getDataDictionary", VALUEFUNC(_wrap_Session_getDataDictionary), -1);
  rb_define_singleton_method(cSession.klass, "sendToTarget", VALUEFUNC(_wrap_Session_sendToTarget), -1);
  rb_define_singleton_method(cSession.klass, "getSessions", VALUEFUNC(_wrap_Session_getSessions), -1);
  rb_define_singleton_method(cSession.klass, "doesSessionExist", VALUEFUNC(_wrap_Session_doesSessionExist), -1);
  rb_define_singleton_method(cSession.klass, "lookupSession", VALUEFUNC(_wrap_Session_lookupSession), -1);
  rb_define_singleton_method(cSession.klass, "isSessionRegistered", VALUEFUNC(_wrap_Session_isSessionRegistered), -1);
  rb_define_singleton_method(cSession.klass, "registerSession", VALUEFUNC(_wrap_Session_registerSession), -1);
  rb_define_singleton_method(cSession.klass, "unregisterSession", VALUEFUNC(_wrap_Session_unregisterSession), -1);
  rb_define_singleton_method(cSession.klass, "numSessions", VALUEFUNC(_wrap_Session_numSessions), -1);
  rb_define_method(cSession.klass, "isSessionTime", VALUEFUNC(_wrap_Session_isSessionTime), -1);
  rb_define_method(cSession.klass, "isInitiator", VALUEFUNC(_wrap_Session_isInitiator), -1);
  rb_define_method(cSession.klass, "isAcceptor", VALUEFUNC(_wrap_Session_isAcceptor), -1);
  rb_define_method(cSession.klass, "getSendRedundantResendRequests", VALUEFUNC(_wrap_Session_getSendRedundantResendRequests), -1);
  rb_define_method(cSession.klass, "setSendRedundantResendRequests", VALUEFUNC(_wrap_Session_setSendRedundantResendRequests), -1);
  rb_define_method(cSession.klass, "getCheckCompId", VALUEFUNC(_wrap_Session_getCheckCompId), -1);
  rb_define_method(cSession.klass, "setCheckCompId", VALUEFUNC(_wrap_Session_setCheckCompId), -1);
  rb_define_method(cSession.klass, "getCheckLatency", VALUEFUNC(_wrap_Session_getCheckLatency), -1);
  rb_define_method(cSession.klass, "setCheckLatency", VALUEFUNC(_wrap_Session_setCheckLatency), -1);
  rb_define_method(cSession.klass, "getMaxLatency", VALUEFUNC(_wrap_Session_getMaxLatency), -1);
  rb_define_method(cSession.klass, "setMaxLatency", VALUEFUNC(_wrap_Session_setMaxLatency), -1);
  rb_define_method(cSession.klass, "getLogonTimeout", VALUEFUNC(_wrap_Session_getLogonTimeout), -1);
  rb_define_method(cSession.klass, "setLogonTimeout", VALUEFUNC(_wrap_Session_setLogonTimeout), -1);
  rb_define_method(cSession.klass, "getLogoutTimeout", VALUEFUNC(_wrap_Session_getLogoutTimeout), -1);
  rb_define_method(cSession.klass, "setLogoutTimeout", VALUEFUNC(_wrap_Session_setLogoutTimeout), -1);
  rb_define_method(cSession.klass, "getResetOnLogon", VALUEFUNC(_wrap_Session_getResetOnLogon), -1);
  rb_define_method(cSession.klass, "setResetOnLogon", VALUEFUNC(_wrap_Session_setResetOnLogon), -1);
  rb_define_method(cSession.klass, "getResetOnLogout", VALUEFUNC(_wrap_Session_getResetOnLogout), -1);
  rb_define_method(cSession.klass, "setResetOnLogout", VALUEFUNC(_wrap_Session_setResetOnLogout), -1);
  rb_define_method(cSession.klass, "getResetOnDisconnect", VALUEFUNC(_wrap_Session_getResetOnDisconnect), -1);
  rb_define_method(cSession.klass, "setResetOnDisconnect", VALUEFUNC(_wrap_Session_setResetOnDisconnect), -1);
  rb_define_method(cSession.klass, "getRefreshOnLogon", VALUEFUNC(_wrap_Session_getRefreshOnLogon), -1);
  rb_define_method(cSession.klass, "setRefreshOnLogon", VALUEFUNC(_wrap_Session_setRefreshOnLogon), -1);
  rb_define_method(cSession.klass, "getMillisecondsInTimeStamp", VALUEFUNC(_wrap_Session_getMillisecondsInTimeStamp), -1);
  rb_define_method(cSession.klass, "setMillisecondsInTimeStamp", VALUEFUNC(_wrap_Session_setMillisecondsInTimeStamp), -1);
  rb_define_method(cSession.klass, "getPersistMessages", VALUEFUNC(_wrap_Session_getPersistMessages), -1);
  rb_define_method(cSession.klass, "setPersistMessages", VALUEFUNC(_wrap_Session_setPersistMessages), -1);
  rb_define_method(cSession.klass, "setResponder", VALUEFUNC(_wrap_Session_setResponder), -1);
  rb_define_method(cSession.klass, "send", VALUEFUNC(_wrap_Session_send), -1);
  rb_define_method(cSession.klass, "next", VALUEFUNC(_wrap_Session_next), -1);
  rb_define_method(cSession.klass, "disconnect", VALUEFUNC(_wrap_Session_disconnect), -1);
  rb_define_method(cSession.klass, "getExpectedSenderNum", VALUEFUNC(_wrap_Session_getExpectedSenderNum), -1);
  rb_define_method(cSession.klass, "getExpectedTargetNum", VALUEFUNC(_wrap_Session_getExpectedTargetNum), -1);
  rb_define_method(cSession.klass, "getLog", VALUEFUNC(_wrap_Session_getLog), -1);
  rb_define_method(cSession.klass, "getStore", VALUEFUNC(_wrap_Session_getStore), -1);
  cSession.mark = 0;
  cSession.destroy = (void (*)(void *)) free_FIX_Session;
  cSession.trackObjects = 0;
  
  cLogFactory.klass = rb_define_class_under(mQuickfix, "LogFactory", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__LogFactory, (void *) &cLogFactory);
  rb_undef_alloc_func(cLogFactory.klass);
  rb_define_method(cLogFactory.klass, "create", VALUEFUNC(_wrap_LogFactory_create), -1);
  rb_define_method(cLogFactory.klass, "destroy", VALUEFUNC(_wrap_LogFactory_destroy), -1);
  cLogFactory.mark = 0;
  cLogFactory.destroy = (void (*)(void *)) free_FIX_LogFactory;
  cLogFactory.trackObjects = 0;
  
  cScreenLogFactory.klass = rb_define_class_under(mQuickfix, "ScreenLogFactory", ((swig_class *) SWIGTYPE_p_FIX__LogFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ScreenLogFactory, (void *) &cScreenLogFactory);
  rb_define_alloc_func(cScreenLogFactory.klass, _wrap_ScreenLogFactory_allocate);
  rb_define_method(cScreenLogFactory.klass, "initialize", VALUEFUNC(_wrap_new_ScreenLogFactory), -1);
  rb_define_method(cScreenLogFactory.klass, "create", VALUEFUNC(_wrap_ScreenLogFactory_create), -1);
  rb_define_method(cScreenLogFactory.klass, "destroy", VALUEFUNC(_wrap_ScreenLogFactory_destroy), -1);
  cScreenLogFactory.mark = 0;
  cScreenLogFactory.destroy = (void (*)(void *)) free_FIX_ScreenLogFactory;
  cScreenLogFactory.trackObjects = 0;
  
  cLog.klass = rb_define_class_under(mQuickfix, "Log", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Log, (void *) &cLog);
  rb_undef_alloc_func(cLog.klass);
  rb_define_method(cLog.klass, "clear", VALUEFUNC(_wrap_Log_clear), -1);
  rb_define_method(cLog.klass, "onIncoming", VALUEFUNC(_wrap_Log_onIncoming), -1);
  rb_define_method(cLog.klass, "onOutgoing", VALUEFUNC(_wrap_Log_onOutgoing), -1);
  rb_define_method(cLog.klass, "onEvent", VALUEFUNC(_wrap_Log_onEvent), -1);
  cLog.mark = 0;
  cLog.destroy = (void (*)(void *)) free_FIX_Log;
  cLog.trackObjects = 0;
  
  cScreenLog.klass = rb_define_class_under(mQuickfix, "ScreenLog", ((swig_class *) SWIGTYPE_p_FIX__Log->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__ScreenLog, (void *) &cScreenLog);
  rb_define_alloc_func(cScreenLog.klass, _wrap_ScreenLog_allocate);
  rb_define_method(cScreenLog.klass, "initialize", VALUEFUNC(_wrap_new_ScreenLog), -1);
  rb_define_method(cScreenLog.klass, "clear", VALUEFUNC(_wrap_ScreenLog_clear), -1);
  rb_define_method(cScreenLog.klass, "onIncoming", VALUEFUNC(_wrap_ScreenLog_onIncoming), -1);
  rb_define_method(cScreenLog.klass, "onOutgoing", VALUEFUNC(_wrap_ScreenLog_onOutgoing), -1);
  rb_define_method(cScreenLog.klass, "onEvent", VALUEFUNC(_wrap_ScreenLog_onEvent), -1);
  cScreenLog.mark = 0;
  cScreenLog.destroy = (void (*)(void *)) free_FIX_ScreenLog;
  cScreenLog.trackObjects = 0;
  
  cFileLogFactory.klass = rb_define_class_under(mQuickfix, "FileLogFactory", ((swig_class *) SWIGTYPE_p_FIX__LogFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FileLogFactory, (void *) &cFileLogFactory);
  rb_define_alloc_func(cFileLogFactory.klass, _wrap_FileLogFactory_allocate);
  rb_define_method(cFileLogFactory.klass, "initialize", VALUEFUNC(_wrap_new_FileLogFactory), -1);
  rb_define_method(cFileLogFactory.klass, "create", VALUEFUNC(_wrap_FileLogFactory_create), -1);
  rb_define_method(cFileLogFactory.klass, "destroy", VALUEFUNC(_wrap_FileLogFactory_destroy), -1);
  cFileLogFactory.mark = 0;
  cFileLogFactory.destroy = (void (*)(void *)) free_FIX_FileLogFactory;
  cFileLogFactory.trackObjects = 0;
  
  cFileLog.klass = rb_define_class_under(mQuickfix, "FileLog", ((swig_class *) SWIGTYPE_p_FIX__Log->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FileLog, (void *) &cFileLog);
  rb_define_alloc_func(cFileLog.klass, _wrap_FileLog_allocate);
  rb_define_method(cFileLog.klass, "initialize", VALUEFUNC(_wrap_new_FileLog), -1);
  rb_define_method(cFileLog.klass, "clear", VALUEFUNC(_wrap_FileLog_clear), -1);
  rb_define_method(cFileLog.klass, "onIncoming", VALUEFUNC(_wrap_FileLog_onIncoming), -1);
  rb_define_method(cFileLog.klass, "onOutgoing", VALUEFUNC(_wrap_FileLog_onOutgoing), -1);
  rb_define_method(cFileLog.klass, "onEvent", VALUEFUNC(_wrap_FileLog_onEvent), -1);
  cFileLog.mark = 0;
  cFileLog.destroy = (void (*)(void *)) free_FIX_FileLog;
  cFileLog.trackObjects = 0;
  
  cMessageStoreFactory.klass = rb_define_class_under(mQuickfix, "MessageStoreFactory", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MessageStoreFactory, (void *) &cMessageStoreFactory);
  rb_undef_alloc_func(cMessageStoreFactory.klass);
  rb_define_method(cMessageStoreFactory.klass, "create", VALUEFUNC(_wrap_MessageStoreFactory_create), -1);
  rb_define_method(cMessageStoreFactory.klass, "destroy", VALUEFUNC(_wrap_MessageStoreFactory_destroy), -1);
  cMessageStoreFactory.mark = 0;
  cMessageStoreFactory.destroy = (void (*)(void *)) free_FIX_MessageStoreFactory;
  cMessageStoreFactory.trackObjects = 0;
  
  cMemoryStoreFactory.klass = rb_define_class_under(mQuickfix, "MemoryStoreFactory", ((swig_class *) SWIGTYPE_p_FIX__MessageStoreFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MemoryStoreFactory, (void *) &cMemoryStoreFactory);
  rb_define_alloc_func(cMemoryStoreFactory.klass, _wrap_MemoryStoreFactory_allocate);
  rb_define_method(cMemoryStoreFactory.klass, "initialize", VALUEFUNC(_wrap_new_MemoryStoreFactory), -1);
  rb_define_method(cMemoryStoreFactory.klass, "create", VALUEFUNC(_wrap_MemoryStoreFactory_create), -1);
  rb_define_method(cMemoryStoreFactory.klass, "destroy", VALUEFUNC(_wrap_MemoryStoreFactory_destroy), -1);
  cMemoryStoreFactory.mark = 0;
  cMemoryStoreFactory.destroy = (void (*)(void *)) free_FIX_MemoryStoreFactory;
  cMemoryStoreFactory.trackObjects = 0;
  
  cMessageStore.klass = rb_define_class_under(mQuickfix, "MessageStore", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MessageStore, (void *) &cMessageStore);
  rb_undef_alloc_func(cMessageStore.klass);
  rb_define_method(cMessageStore.klass, "set", VALUEFUNC(_wrap_MessageStore_set), -1);
  rb_define_method(cMessageStore.klass, "get", VALUEFUNC(_wrap_MessageStore_get), -1);
  rb_define_method(cMessageStore.klass, "getNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStore_getNextSenderMsgSeqNum), -1);
  rb_define_method(cMessageStore.klass, "getNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStore_getNextTargetMsgSeqNum), -1);
  rb_define_method(cMessageStore.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStore_setNextSenderMsgSeqNum), -1);
  rb_define_method(cMessageStore.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStore_setNextTargetMsgSeqNum), -1);
  rb_define_method(cMessageStore.klass, "incrNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStore_incrNextSenderMsgSeqNum), -1);
  rb_define_method(cMessageStore.klass, "incrNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStore_incrNextTargetMsgSeqNum), -1);
  rb_define_method(cMessageStore.klass, "getCreationTime", VALUEFUNC(_wrap_MessageStore_getCreationTime), -1);
  rb_define_method(cMessageStore.klass, "reset", VALUEFUNC(_wrap_MessageStore_reset), -1);
  rb_define_method(cMessageStore.klass, "refresh", VALUEFUNC(_wrap_MessageStore_refresh), -1);
  cMessageStore.mark = 0;
  cMessageStore.destroy = (void (*)(void *)) free_FIX_MessageStore;
  cMessageStore.trackObjects = 0;
  
  cMemoryStore.klass = rb_define_class_under(mQuickfix, "MemoryStore", ((swig_class *) SWIGTYPE_p_FIX__MessageStore->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MemoryStore, (void *) &cMemoryStore);
  rb_define_alloc_func(cMemoryStore.klass, _wrap_MemoryStore_allocate);
  rb_define_method(cMemoryStore.klass, "initialize", VALUEFUNC(_wrap_new_MemoryStore), -1);
  rb_define_method(cMemoryStore.klass, "set", VALUEFUNC(_wrap_MemoryStore_set), -1);
  rb_define_method(cMemoryStore.klass, "get", VALUEFUNC(_wrap_MemoryStore_get), -1);
  rb_define_method(cMemoryStore.klass, "getNextSenderMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_getNextSenderMsgSeqNum), -1);
  rb_define_method(cMemoryStore.klass, "getNextTargetMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_getNextTargetMsgSeqNum), -1);
  rb_define_method(cMemoryStore.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_setNextSenderMsgSeqNum), -1);
  rb_define_method(cMemoryStore.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_setNextTargetMsgSeqNum), -1);
  rb_define_method(cMemoryStore.klass, "incrNextSenderMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_incrNextSenderMsgSeqNum), -1);
  rb_define_method(cMemoryStore.klass, "incrNextTargetMsgSeqNum", VALUEFUNC(_wrap_MemoryStore_incrNextTargetMsgSeqNum), -1);
  rb_define_method(cMemoryStore.klass, "setCreationTime", VALUEFUNC(_wrap_MemoryStore_setCreationTime), -1);
  rb_define_method(cMemoryStore.klass, "getCreationTime", VALUEFUNC(_wrap_MemoryStore_getCreationTime), -1);
  rb_define_method(cMemoryStore.klass, "reset", VALUEFUNC(_wrap_MemoryStore_reset), -1);
  rb_define_method(cMemoryStore.klass, "refresh", VALUEFUNC(_wrap_MemoryStore_refresh), -1);
  cMemoryStore.mark = 0;
  cMemoryStore.destroy = (void (*)(void *)) free_FIX_MemoryStore;
  cMemoryStore.trackObjects = 0;
  
  cMessageStoreFactoryExceptionWrapper.klass = rb_define_class_under(mQuickfix, "MessageStoreFactoryExceptionWrapper", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MessageStoreFactoryExceptionWrapper, (void *) &cMessageStoreFactoryExceptionWrapper);
  rb_define_alloc_func(cMessageStoreFactoryExceptionWrapper.klass, _wrap_MessageStoreFactoryExceptionWrapper_allocate);
  rb_define_method(cMessageStoreFactoryExceptionWrapper.klass, "initialize", VALUEFUNC(_wrap_new_MessageStoreFactoryExceptionWrapper), -1);
  rb_define_method(cMessageStoreFactoryExceptionWrapper.klass, "create", VALUEFUNC(_wrap_MessageStoreFactoryExceptionWrapper_create), -1);
  rb_define_method(cMessageStoreFactoryExceptionWrapper.klass, "destroy", VALUEFUNC(_wrap_MessageStoreFactoryExceptionWrapper_destroy), -1);
  cMessageStoreFactoryExceptionWrapper.mark = 0;
  cMessageStoreFactoryExceptionWrapper.destroy = (void (*)(void *)) free_FIX_MessageStoreFactoryExceptionWrapper;
  cMessageStoreFactoryExceptionWrapper.trackObjects = 0;
  
  cMessageStoreExceptionWrapper.klass = rb_define_class_under(mQuickfix, "MessageStoreExceptionWrapper", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__MessageStoreExceptionWrapper, (void *) &cMessageStoreExceptionWrapper);
  rb_define_alloc_func(cMessageStoreExceptionWrapper.klass, _wrap_MessageStoreExceptionWrapper_allocate);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "initialize", VALUEFUNC(_wrap_new_MessageStoreExceptionWrapper), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "set", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_set), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "get", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_get), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "getNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_getNextSenderMsgSeqNum), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "getNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_getNextTargetMsgSeqNum), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_setNextSenderMsgSeqNum), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_setNextTargetMsgSeqNum), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "incrNextSenderMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_incrNextSenderMsgSeqNum), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "incrNextTargetMsgSeqNum", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_incrNextTargetMsgSeqNum), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "getCreationTime", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_getCreationTime), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "reset", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_reset), -1);
  rb_define_method(cMessageStoreExceptionWrapper.klass, "refresh", VALUEFUNC(_wrap_MessageStoreExceptionWrapper_refresh), -1);
  cMessageStoreExceptionWrapper.mark = 0;
  cMessageStoreExceptionWrapper.destroy = (void (*)(void *)) free_FIX_MessageStoreExceptionWrapper;
  cMessageStoreExceptionWrapper.trackObjects = 0;
  
  cFileStoreFactory.klass = rb_define_class_under(mQuickfix, "FileStoreFactory", ((swig_class *) SWIGTYPE_p_FIX__MessageStoreFactory->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FileStoreFactory, (void *) &cFileStoreFactory);
  rb_define_alloc_func(cFileStoreFactory.klass, _wrap_FileStoreFactory_allocate);
  rb_define_method(cFileStoreFactory.klass, "initialize", VALUEFUNC(_wrap_new_FileStoreFactory), -1);
  rb_define_method(cFileStoreFactory.klass, "create", VALUEFUNC(_wrap_FileStoreFactory_create), -1);
  rb_define_method(cFileStoreFactory.klass, "destroy", VALUEFUNC(_wrap_FileStoreFactory_destroy), -1);
  cFileStoreFactory.mark = 0;
  cFileStoreFactory.destroy = (void (*)(void *)) free_FIX_FileStoreFactory;
  cFileStoreFactory.trackObjects = 0;
  
  cFileStore.klass = rb_define_class_under(mQuickfix, "FileStore", ((swig_class *) SWIGTYPE_p_FIX__MessageStore->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__FileStore, (void *) &cFileStore);
  rb_define_alloc_func(cFileStore.klass, _wrap_FileStore_allocate);
  rb_define_method(cFileStore.klass, "initialize", VALUEFUNC(_wrap_new_FileStore), -1);
  rb_define_method(cFileStore.klass, "set", VALUEFUNC(_wrap_FileStore_set), -1);
  rb_define_method(cFileStore.klass, "get", VALUEFUNC(_wrap_FileStore_get), -1);
  rb_define_method(cFileStore.klass, "getNextSenderMsgSeqNum", VALUEFUNC(_wrap_FileStore_getNextSenderMsgSeqNum), -1);
  rb_define_method(cFileStore.klass, "getNextTargetMsgSeqNum", VALUEFUNC(_wrap_FileStore_getNextTargetMsgSeqNum), -1);
  rb_define_method(cFileStore.klass, "setNextSenderMsgSeqNum", VALUEFUNC(_wrap_FileStore_setNextSenderMsgSeqNum), -1);
  rb_define_method(cFileStore.klass, "setNextTargetMsgSeqNum", VALUEFUNC(_wrap_FileStore_setNextTargetMsgSeqNum), -1);
  rb_define_method(cFileStore.klass, "incrNextSenderMsgSeqNum", VALUEFUNC(_wrap_FileStore_incrNextSenderMsgSeqNum), -1);
  rb_define_method(cFileStore.klass, "incrNextTargetMsgSeqNum", VALUEFUNC(_wrap_FileStore_incrNextTargetMsgSeqNum), -1);
  rb_define_method(cFileStore.klass, "getCreationTime", VALUEFUNC(_wrap_FileStore_getCreationTime), -1);
  rb_define_method(cFileStore.klass, "reset", VALUEFUNC(_wrap_FileStore_reset), -1);
  rb_define_method(cFileStore.klass, "refresh", VALUEFUNC(_wrap_FileStore_refresh), -1);
  cFileStore.mark = 0;
  cFileStore.destroy = (void (*)(void *)) free_FIX_FileStore;
  cFileStore.trackObjects = 0;
  rb_define_module_function(mQuickfix, "disown_Application", VALUEFUNC(_wrap_disown_Application), -1);
  
  cApplication.klass = rb_define_class_under(mQuickfix, "Application", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Application, (void *) &cApplication);
  rb_define_alloc_func(cApplication.klass, _wrap_Application_allocate);
  rb_define_method(cApplication.klass, "initialize", VALUEFUNC(_wrap_new_Application), -1);
  rb_define_method(cApplication.klass, "onCreate", VALUEFUNC(_wrap_Application_onCreate), -1);
  rb_define_method(cApplication.klass, "onLogon", VALUEFUNC(_wrap_Application_onLogon), -1);
  rb_define_method(cApplication.klass, "onLogout", VALUEFUNC(_wrap_Application_onLogout), -1);
  rb_define_method(cApplication.klass, "toAdmin", VALUEFUNC(_wrap_Application_toAdmin), -1);
  rb_define_method(cApplication.klass, "toApp", VALUEFUNC(_wrap_Application_toApp), -1);
  rb_define_method(cApplication.klass, "fromAdmin", VALUEFUNC(_wrap_Application_fromAdmin), -1);
  rb_define_method(cApplication.klass, "fromApp", VALUEFUNC(_wrap_Application_fromApp), -1);
  cApplication.mark = 0;
  cApplication.destroy = (void (*)(void *)) free_FIX_Application;
  cApplication.trackObjects = 0;
  
  cSynchronizedApplication.klass = rb_define_class_under(mQuickfix, "SynchronizedApplication", ((swig_class *) SWIGTYPE_p_FIX__Application->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SynchronizedApplication, (void *) &cSynchronizedApplication);
  rb_define_alloc_func(cSynchronizedApplication.klass, _wrap_SynchronizedApplication_allocate);
  rb_define_method(cSynchronizedApplication.klass, "initialize", VALUEFUNC(_wrap_new_SynchronizedApplication), -1);
  rb_define_method(cSynchronizedApplication.klass, "onCreate", VALUEFUNC(_wrap_SynchronizedApplication_onCreate), -1);
  rb_define_method(cSynchronizedApplication.klass, "onLogon", VALUEFUNC(_wrap_SynchronizedApplication_onLogon), -1);
  rb_define_method(cSynchronizedApplication.klass, "onLogout", VALUEFUNC(_wrap_SynchronizedApplication_onLogout), -1);
  rb_define_method(cSynchronizedApplication.klass, "toAdmin", VALUEFUNC(_wrap_SynchronizedApplication_toAdmin), -1);
  rb_define_method(cSynchronizedApplication.klass, "toApp", VALUEFUNC(_wrap_SynchronizedApplication_toApp), -1);
  rb_define_method(cSynchronizedApplication.klass, "fromAdmin", VALUEFUNC(_wrap_SynchronizedApplication_fromAdmin), -1);
  rb_define_method(cSynchronizedApplication.klass, "fromApp", VALUEFUNC(_wrap_SynchronizedApplication_fromApp), -1);
  rb_define_method(cSynchronizedApplication.klass, "m_mutex=", VALUEFUNC(_wrap_SynchronizedApplication_m_mutex_set), -1);
  rb_define_method(cSynchronizedApplication.klass, "m_mutex", VALUEFUNC(_wrap_SynchronizedApplication_m_mutex_get), -1);
  rb_define_method(cSynchronizedApplication.klass, "app", VALUEFUNC(_wrap_SynchronizedApplication_app), -1);
  rb_define_method(cSynchronizedApplication.klass, "m_app=", VALUEFUNC(_wrap_SynchronizedApplication_m_app_set), -1);
  rb_define_method(cSynchronizedApplication.klass, "m_app", VALUEFUNC(_wrap_SynchronizedApplication_m_app_get), -1);
  cSynchronizedApplication.mark = 0;
  cSynchronizedApplication.destroy = (void (*)(void *)) free_FIX_SynchronizedApplication;
  cSynchronizedApplication.trackObjects = 0;
  
  cNullApplication.klass = rb_define_class_under(mQuickfix, "NullApplication", ((swig_class *) SWIGTYPE_p_FIX__Application->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__NullApplication, (void *) &cNullApplication);
  rb_define_alloc_func(cNullApplication.klass, _wrap_NullApplication_allocate);
  rb_define_method(cNullApplication.klass, "initialize", VALUEFUNC(_wrap_new_NullApplication), -1);
  cNullApplication.mark = 0;
  cNullApplication.destroy = (void (*)(void *)) free_FIX_NullApplication;
  cNullApplication.trackObjects = 0;
  
  cInitiator.klass = rb_define_class_under(mQuickfix, "Initiator", ((swig_class *) SWIGTYPE_p_FIX__Log->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Initiator, (void *) &cInitiator);
  rb_undef_alloc_func(cInitiator.klass);
  rb_define_method(cInitiator.klass, "start", VALUEFUNC(_wrap_Initiator_start), -1);
  rb_define_method(cInitiator.klass, "block", VALUEFUNC(_wrap_Initiator_block), -1);
  rb_define_method(cInitiator.klass, "poll", VALUEFUNC(_wrap_Initiator_poll), -1);
  rb_define_method(cInitiator.klass, "stop", VALUEFUNC(_wrap_Initiator_stop), -1);
  rb_define_method(cInitiator.klass, "isLoggedOn", VALUEFUNC(_wrap_Initiator_isLoggedOn), -1);
  rb_define_method(cInitiator.klass, "getSession", VALUEFUNC(_wrap_Initiator_getSession), -1);
  rb_define_method(cInitiator.klass, "getSessions", VALUEFUNC(_wrap_Initiator_getSessions), -1);
  rb_define_method(cInitiator.klass, "has", VALUEFUNC(_wrap_Initiator_has), -1);
  rb_define_method(cInitiator.klass, "isStopped", VALUEFUNC(_wrap_Initiator_isStopped), -1);
  rb_define_method(cInitiator.klass, "getApplication", VALUEFUNC(_wrap_Initiator_getApplication), -1);
  rb_define_method(cInitiator.klass, "getMessageStoreFactory", VALUEFUNC(_wrap_Initiator_getMessageStoreFactory), -1);
  rb_define_method(cInitiator.klass, "onEvent", VALUEFUNC(_wrap_Initiator_onEvent), -1);
  rb_define_method(cInitiator.klass, "onIncoming", VALUEFUNC(_wrap_Initiator_onIncoming), -1);
  rb_define_method(cInitiator.klass, "onOutgoing", VALUEFUNC(_wrap_Initiator_onOutgoing), -1);
  rb_define_method(cInitiator.klass, "clear", VALUEFUNC(_wrap_Initiator_clear), -1);
  cInitiator.mark = 0;
  cInitiator.destroy = (void (*)(void *)) free_FIX_Initiator;
  cInitiator.trackObjects = 0;
  
  cSocketInitiatorBase.klass = rb_define_class_under(mQuickfix, "SocketInitiatorBase", ((swig_class *) SWIGTYPE_p_FIX__Initiator->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketInitiator, (void *) &cSocketInitiatorBase);
  rb_define_alloc_func(cSocketInitiatorBase.klass, _wrap_SocketInitiatorBase_allocate);
  rb_define_method(cSocketInitiatorBase.klass, "initialize", VALUEFUNC(_wrap_new_SocketInitiatorBase), -1);
  cSocketInitiatorBase.mark = 0;
  cSocketInitiatorBase.destroy = (void (*)(void *)) free_FIX_SocketInitiator;
  cSocketInitiatorBase.trackObjects = 0;
  
  cAcceptor.klass = rb_define_class_under(mQuickfix, "Acceptor", ((swig_class *) SWIGTYPE_p_FIX__Log->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__Acceptor, (void *) &cAcceptor);
  rb_undef_alloc_func(cAcceptor.klass);
  rb_define_method(cAcceptor.klass, "start", VALUEFUNC(_wrap_Acceptor_start), -1);
  rb_define_method(cAcceptor.klass, "block", VALUEFUNC(_wrap_Acceptor_block), -1);
  rb_define_method(cAcceptor.klass, "poll", VALUEFUNC(_wrap_Acceptor_poll), -1);
  rb_define_method(cAcceptor.klass, "stop", VALUEFUNC(_wrap_Acceptor_stop), -1);
  rb_define_method(cAcceptor.klass, "isLoggedOn", VALUEFUNC(_wrap_Acceptor_isLoggedOn), -1);
  rb_define_method(cAcceptor.klass, "getSession", VALUEFUNC(_wrap_Acceptor_getSession), -1);
  rb_define_method(cAcceptor.klass, "getSessions", VALUEFUNC(_wrap_Acceptor_getSessions), -1);
  rb_define_method(cAcceptor.klass, "has", VALUEFUNC(_wrap_Acceptor_has), -1);
  rb_define_method(cAcceptor.klass, "isStopped", VALUEFUNC(_wrap_Acceptor_isStopped), -1);
  rb_define_method(cAcceptor.klass, "getApplication", VALUEFUNC(_wrap_Acceptor_getApplication), -1);
  rb_define_method(cAcceptor.klass, "getMessageStoreFactory", VALUEFUNC(_wrap_Acceptor_getMessageStoreFactory), -1);
  rb_define_method(cAcceptor.klass, "onEvent", VALUEFUNC(_wrap_Acceptor_onEvent), -1);
  rb_define_method(cAcceptor.klass, "onIncoming", VALUEFUNC(_wrap_Acceptor_onIncoming), -1);
  rb_define_method(cAcceptor.klass, "onOutgoing", VALUEFUNC(_wrap_Acceptor_onOutgoing), -1);
  rb_define_method(cAcceptor.klass, "clear", VALUEFUNC(_wrap_Acceptor_clear), -1);
  cAcceptor.mark = 0;
  cAcceptor.destroy = (void (*)(void *)) free_FIX_Acceptor;
  cAcceptor.trackObjects = 0;
  
  cSocketAcceptorBase.klass = rb_define_class_under(mQuickfix, "SocketAcceptorBase", ((swig_class *) SWIGTYPE_p_FIX__Acceptor->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__SocketAcceptor, (void *) &cSocketAcceptorBase);
  rb_define_alloc_func(cSocketAcceptorBase.klass, _wrap_SocketAcceptorBase_allocate);
  rb_define_method(cSocketAcceptorBase.klass, "initialize", VALUEFUNC(_wrap_new_SocketAcceptorBase), -1);
  cSocketAcceptorBase.mark = 0;
  cSocketAcceptorBase.destroy = (void (*)(void *)) free_FIX_SocketAcceptor;
  cSocketAcceptorBase.trackObjects = 0;
  
  cDataDictionary.klass = rb_define_class_under(mQuickfix, "DataDictionary", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_FIX__DataDictionary, (void *) &cDataDictionary);
  rb_define_alloc_func(cDataDictionary.klass, _wrap_DataDictionary_allocate);
  rb_define_method(cDataDictionary.klass, "initialize", VALUEFUNC(_wrap_new_DataDictionary), -1);
  rb_define_method(cDataDictionary.klass, "readFromURL", VALUEFUNC(_wrap_DataDictionary_readFromURL), -1);
  rb_define_method(cDataDictionary.klass, "readFromDocument", VALUEFUNC(_wrap_DataDictionary_readFromDocument), -1);
  rb_define_method(cDataDictionary.klass, "readFromStream", VALUEFUNC(_wrap_DataDictionary_readFromStream), -1);
  rb_define_method(cDataDictionary.klass, "getOrderedFields", VALUEFUNC(_wrap_DataDictionary_getOrderedFields), -1);
  rb_define_method(cDataDictionary.klass, "setVersion", VALUEFUNC(_wrap_DataDictionary_setVersion), -1);
  rb_define_method(cDataDictionary.klass, "getVersion", VALUEFUNC(_wrap_DataDictionary_getVersion), -1);
  rb_define_method(cDataDictionary.klass, "addField", VALUEFUNC(_wrap_DataDictionary_addField), -1);
  rb_define_method(cDataDictionary.klass, "addFieldName", VALUEFUNC(_wrap_DataDictionary_addFieldName), -1);
  rb_define_method(cDataDictionary.klass, "_getFieldName", VALUEFUNC(_wrap_DataDictionary__getFieldName), -1);
  rb_define_method(cDataDictionary.klass, "_getFieldTag", VALUEFUNC(_wrap_DataDictionary__getFieldTag), -1);
  rb_define_method(cDataDictionary.klass, "addValueName", VALUEFUNC(_wrap_DataDictionary_addValueName), -1);
  rb_define_method(cDataDictionary.klass, "_getValueName", VALUEFUNC(_wrap_DataDictionary__getValueName), -1);
  rb_define_method(cDataDictionary.klass, "isField", VALUEFUNC(_wrap_DataDictionary_isField), -1);
  rb_define_method(cDataDictionary.klass, "addMsgType", VALUEFUNC(_wrap_DataDictionary_addMsgType), -1);
  rb_define_method(cDataDictionary.klass, "isMsgType", VALUEFUNC(_wrap_DataDictionary_isMsgType), -1);
  rb_define_method(cDataDictionary.klass, "addMsgField", VALUEFUNC(_wrap_DataDictionary_addMsgField), -1);
  rb_define_method(cDataDictionary.klass, "isMsgField", VALUEFUNC(_wrap_DataDictionary_isMsgField), -1);
  rb_define_method(cDataDictionary.klass, "addHeaderField", VALUEFUNC(_wrap_DataDictionary_addHeaderField), -1);
  rb_define_method(cDataDictionary.klass, "isHeaderField", VALUEFUNC(_wrap_DataDictionary_isHeaderField), -1);
  rb_define_method(cDataDictionary.klass, "addTrailerField", VALUEFUNC(_wrap_DataDictionary_addTrailerField), -1);
  rb_define_method(cDataDictionary.klass, "isTrailerField", VALUEFUNC(_wrap_DataDictionary_isTrailerField), -1);
  rb_define_method(cDataDictionary.klass, "addFieldType", VALUEFUNC(_wrap_DataDictionary_addFieldType), -1);
  rb_define_method(cDataDictionary.klass, "getFieldType", VALUEFUNC(_wrap_DataDictionary_getFieldType), -1);
  rb_define_method(cDataDictionary.klass, "addRequiredField", VALUEFUNC(_wrap_DataDictionary_addRequiredField), -1);
  rb_define_method(cDataDictionary.klass, "isRequiredField", VALUEFUNC(_wrap_DataDictionary_isRequiredField), -1);
  rb_define_method(cDataDictionary.klass, "addFieldValue", VALUEFUNC(_wrap_DataDictionary_addFieldValue), -1);
  rb_define_method(cDataDictionary.klass, "hasFieldValue", VALUEFUNC(_wrap_DataDictionary_hasFieldValue), -1);
  rb_define_method(cDataDictionary.klass, "isFieldValue", VALUEFUNC(_wrap_DataDictionary_isFieldValue), -1);
  rb_define_method(cDataDictionary.klass, "addGroup", VALUEFUNC(_wrap_DataDictionary_addGroup), -1);
  rb_define_method(cDataDictionary.klass, "isGroup", VALUEFUNC(_wrap_DataDictionary_isGroup), -1);
  rb_define_method(cDataDictionary.klass, "_getGroup", VALUEFUNC(_wrap_DataDictionary__getGroup), -1);
  rb_define_method(cDataDictionary.klass, "isDataField", VALUEFUNC(_wrap_DataDictionary_isDataField), -1);
  rb_define_method(cDataDictionary.klass, "isMultipleValueStringField", VALUEFUNC(_wrap_DataDictionary_isMultipleValueStringField), -1);
  rb_define_method(cDataDictionary.klass, "checkFieldsOutOfOrder", VALUEFUNC(_wrap_DataDictionary_checkFieldsOutOfOrder), -1);
  rb_define_method(cDataDictionary.klass, "checkFieldsHaveValues", VALUEFUNC(_wrap_DataDictionary_checkFieldsHaveValues), -1);
  rb_define_method(cDataDictionary.klass, "checkUserDefinedFields", VALUEFUNC(_wrap_DataDictionary_checkUserDefinedFields), -1);
  rb_define_method(cDataDictionary.klass, "validate", VALUEFUNC(_wrap_DataDictionary_validate), -1);
  cDataDictionary.mark = 0;
  cDataDictionary.destroy = (void (*)(void *)) free_FIX_DataDictionary;
  cDataDictionary.trackObjects = 0;
}

#endif //HAVE_RUBY
